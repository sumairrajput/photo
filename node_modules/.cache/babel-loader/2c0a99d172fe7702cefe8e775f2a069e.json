{"ast":null,"code":"import { __assign, __spreadArrays, __rest, __extends } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, mix, clamp, distance, progress, linear as linear$1, circOut, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\nimport React__default, { useRef, createContext, useContext, useEffect, createElement, useMemo, forwardRef, Fragment, Component, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\n\nvar isRefObject = function (ref) {\n  return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function (value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v;\n\n      if (_this.updateSubscribers && _this.prev !== _this.current) {\n        _this.updateSubscribers.forEach(_this.notifySubscriber);\n      }\n\n      if (render && _this.renderSubscribers) {\n        _this.renderSubscribers.forEach(_this.notifySubscriber);\n      } // Update timestamp\n\n\n      var _a = getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync.postRender(_this.scheduleVelocityCheck);\n      }\n    };\n    /**\n     * Notify a subscriber with the latest value.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @param subscriber - The subscriber to notify.\n     *\n     * @internal\n     */\n\n\n    this.notifySubscriber = function (subscriber) {\n      subscriber(_this.current);\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync.postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n      }\n    };\n\n    this.set(init, false);\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Subscribes a subscriber function to a subscription list.\n   *\n   * @param subscriptions - A `Set` of subscribers.\n   * @param subscription - A subscriber function.\n   */\n\n\n  MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n    var _this = this;\n\n    var updateSubscriber = function () {\n      return subscription(_this.current);\n    };\n\n    subscriptions.add(updateSubscriber);\n    return function () {\n      return subscriptions.delete(updateSubscriber);\n    };\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    if (!this.updateSubscribers) this.updateSubscribers = new Set();\n    return this.subscribeTo(this.updateSubscribers, subscription);\n  };\n\n  MotionValue.prototype.clearListeners = function () {\n    var _a;\n\n    (_a = this.updateSubscribers) === null || _a === void 0 ? void 0 : _a.clear();\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    if (!this.renderSubscribers) this.renderSubscribers = new Set(); // Render immediately\n\n    this.notifySubscriber(subscription);\n    return this.subscribeTo(this.renderSubscribers, subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers && this.updateSubscribers.clear();\n    this.renderSubscribers && this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\n * @internal\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\n * underlying renderer.\n *\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\n * VisualElement and we can quickly offer all the same features.\n */\n\n\nvar VisualElement =\n/** @class */\nfunction () {\n  function VisualElement(parent, ref) {\n    var _this = this; // An iterable list of current children\n\n\n    this.children = new Set(); // The latest resolved MotionValues\n\n    this.latest = {}; // A map of MotionValues used to animate this element\n\n    this.values = new Map(); // Unsubscription callbacks for each MotionValue\n\n    this.valueSubscriptions = new Map(); // A configuration for this VisualElement, each derived class can extend this.\n\n    this.config = {}; // A pre-bound call to the user-provided `onUpdate` callback. This won't\n    // be called more than once per frame.\n\n    this.update = function () {\n      return _this.config.onUpdate(_this.latest);\n    }; // Pre-bound version of render\n\n\n    this.triggerRender = function () {\n      return _this.render();\n    };\n\n    this.scheduleRender = function () {\n      return sync.render(_this.triggerRender, false, true);\n    }; // This function gets passed to the rendered component's `ref` prop\n    // and is used to mount/unmount the VisualElement\n\n\n    this.ref = function (element) {\n      element ? _this.mount(element) : _this.unmount();\n      if (!_this.externalRef) return;\n\n      if (typeof _this.externalRef === \"function\") {\n        _this.externalRef(element);\n      } else if (isRefObject(_this.externalRef)) {\n        _this.externalRef.current = element;\n      }\n    }; // Create a relationship with the provided parent.\n\n\n    this.parent = parent;\n    this.rootParent = parent ? parent.rootParent : this;\n    this.treePath = parent ? __spreadArrays(parent.treePath, [parent]) : []; // Calculate the depth of this node in the VisualElement graph\n\n    this.depth = parent ? parent.depth + 1 : 0; // A reference to any externally-defined React ref. This might live better\n    // outside the VisualElement and be handled in a hook.\n\n    this.externalRef = ref;\n  }\n\n  VisualElement.prototype.subscribe = function (child) {\n    var _this = this;\n\n    this.children.add(child);\n    return function () {\n      return _this.children.delete(child);\n    };\n  }; // Check whether this element has a MotionValue of the provided key\n\n\n  VisualElement.prototype.hasValue = function (key) {\n    return this.values.has(key);\n  }; // Add a MotionValue\n\n\n  VisualElement.prototype.addValue = function (key, value) {\n    if (this.hasValue(key)) this.removeValue(key);\n    this.values.set(key, value);\n    this.latest[key] = value.get();\n    if (this.element) this.subscribeToValue(key, value);\n  }; // Remove a MotionValue\n\n\n  VisualElement.prototype.removeValue = function (key) {\n    var unsubscribe = this.valueSubscriptions.get(key);\n    unsubscribe && unsubscribe();\n    this.values.delete(key);\n    delete this.latest[key];\n    this.valueSubscriptions.delete(key);\n  };\n\n  VisualElement.prototype.getValue = function (key, defaultValue) {\n    var value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = new MotionValue(defaultValue);\n      this.addValue(key, value);\n    }\n\n    return value;\n  }; // Iterate over all MotionValues\n\n\n  VisualElement.prototype.forEachValue = function (callback) {\n    this.values.forEach(callback);\n  }; // Get the underlying rendered instance of this VisualElement. For instance in\n  // HTMLVisualElement this will be a HTMLElement.\n\n\n  VisualElement.prototype.getInstance = function () {\n    return this.element;\n  };\n\n  VisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign({}, config);\n  }; // Set a single `latest` value\n\n\n  VisualElement.prototype.setSingleStaticValue = function (key, value) {\n    this.latest[key] = value;\n  }; // Statically set values to `latest` without needing a MotionValue\n\n\n  VisualElement.prototype.setStaticValues = function (values, value) {\n    if (typeof values === \"string\") {\n      this.setSingleStaticValue(values, value);\n    } else {\n      for (var key in values) {\n        this.setSingleStaticValue(key, values[key]);\n      }\n    }\n  };\n\n  VisualElement.prototype.scheduleUpdateLayoutDelta = function () {\n    sync.update(this.rootParent.updateLayoutDelta, false, true);\n  }; // Subscribe to changes in a MotionValue\n\n\n  VisualElement.prototype.subscribeToValue = function (key, value) {\n    var _this = this;\n\n    var onChange = function (latest) {\n      _this.setSingleStaticValue(key, latest);\n\n      _this.latest[key] = latest;\n      _this.config.onUpdate && sync.update(_this.update, false, true);\n    };\n\n    var unsubscribeOnChange = value.onChange(onChange);\n    var unsubscribeOnRender = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, function () {\n      unsubscribeOnChange();\n      unsubscribeOnRender();\n    });\n  }; // Mount the VisualElement with the actual DOM element\n\n\n  VisualElement.prototype.mount = function (element) {\n    var _this = this;\n\n    invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n\n    if (this.parent) {\n      this.removeFromParent = this.parent.subscribe(this);\n    }\n    /**\n     * Save the element to this.element as a semantic API, this.current to the VisualElement\n     * is compatible with existing RefObject APIs.\n     */\n\n\n    this.element = this.current = element; // Subscribe to any pre-existing MotionValues\n\n    this.forEachValue(function (value, key) {\n      return _this.subscribeToValue(key, value);\n    });\n  }; // Unmount the VisualElement and cancel any scheduled updates\n\n\n  VisualElement.prototype.unmount = function () {\n    var _this = this;\n\n    this.forEachValue(function (_, key) {\n      return _this.removeValue(key);\n    });\n    cancelSync.update(this.update);\n    cancelSync.render(this.render);\n    this.removeFromParent && this.removeFromParent();\n  };\n\n  return VisualElement;\n}();\n\nfunction noop(any) {\n  return any;\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Create an empty axis box of zero size\n */\n\n\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\n\nfunction copyAxisBox(box) {\n  return {\n    x: __assign({}, box.x),\n    y: __assign({}, box.y)\n  };\n}\n/**\n * Create an empty box delta\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n\nfunction delta() {\n  return {\n    x: __assign({}, zeroDelta),\n    y: __assign({}, zeroDelta)\n  };\n}\n/**\n * ValueType for \"auto\"\n */\n\n\nvar auto = {\n  test: function (v) {\n    return v === \"auto\";\n  },\n  parse: function (v) {\n    return v;\n  }\n};\n/**\n * ValueType for ints\n */\n\nvar int = __assign(__assign({}, number), {\n  transform: Math.round\n});\n/**\n * A map of default value types for common values\n */\n\n\nvar defaultValueTypes = {\n  // Color props\n  color: color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale: scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a provided value against a ValueType\n */\n\nvar testValueType = function (v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\n\nvar findDimensionValueType = function (v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\n\n\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\n\n\nvar findValueType = function (v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\n * Gets the default ValueType for the provided value key\n */\n\n\nvar getDefaultValueType = function (key) {\n  return defaultValueTypes[key];\n};\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\n\nvar getValueAsType = function (value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\n\n\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\n * Generate a list of every possible transform key.\n */\n\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  axes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n  if (enableHardwareAcceleration === void 0) {\n    enableHardwareAcceleration = true;\n  }\n\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  } // The transform string we're going to build into\n\n\n  var transformString = \"\"; // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\n * Returns true if the provided key is a CSS variable\n */\n\n\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\n\n\nfunction correctBorderRadius(latest, viewportBox) {\n  /**\n   * If latest is a string, we either presume it's already a percentage, in which case it'll\n   * already be stretched appropriately, or it's another value type which we don't support.\n   */\n  if (typeof latest !== \"number\") return latest;\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n\n  var x = pixelsToPercent(latest, viewportBox.x);\n  var y = pixelsToPercent(latest, viewportBox.y);\n  return x + \"% \" + y + \"%\";\n}\n\nfunction correctBoxShadow(latest, _viewportBox, delta, treeScale) {\n  // GC Warning - this creates a function and object every frame\n  var shadow = complex.parse(latest);\n  var template = complex.createTransformer(latest); // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y; // Scale x/y\n\n  shadow[1] /= xScale;\n  shadow[2] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[3] === \"number\") shadow[3] /= averageScale; // Spread\n\n  if (typeof shadow[4] === \"number\") shadow[4] /= averageScale;\n  return template(shadow);\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar valueScaleCorrection = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\n/**\n * @internal\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n\nfunction createDeltaTransform(delta, treeScale) {\n  var x = delta.x.translate / treeScale.x;\n  var y = delta.y.translate / treeScale.y;\n  var scaleX = delta.x.scale;\n  var scaleY = delta.y.scale;\n  return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scaleX + \", \" + scaleY + \")\";\n}\n/**\n * Build style and CSS variables\n *\n * This function converts a Motion style prop:\n *\n * { x: 100, width: 100, originX: 0.5 }\n *\n * Into an object with default value types applied and default\n * transform order set:\n *\n * {\n *   transform: 'translateX(100px) translateZ(0)`,\n *   width: '100px',\n *   transformOrigin: '50% 50%'\n * }\n *\n * Styles are saved to `style` and CSS vars to `vars`.\n *\n * This function works with mutative data structures.\n */\n\n\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a, isLayoutProjectionEnabled, delta, deltaFinal, treeScale, targetBox) {\n  var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n      transformTemplate = _a.transformTemplate,\n      allowTransformNone = _a.allowTransformNone; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = !!isLayoutProjectionEnabled;\n  var hasTransformOrigin = !!isLayoutProjectionEnabled; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable. Transforms and transform origins are kept seperately\n   * for further processing\n   */\n\n  for (var key in latest) {\n    var value = latest[key]; // Convert the value to its default value type, ie 0 -> \"0px\"\n\n    var valueType = getDefaultValueType(key);\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag and enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n      if (!transformIsNone) continue; // If all the transform keys we've so far encountered are their default value\n      // then check to see if this one isn't\n\n      var defaultValue = valueType.default !== undefined ? valueType.default : 0;\n      if (value !== defaultValue) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      // If this is a transform origin, flag and enable further transform-origin processing\n      transformOrigin[key] = valueAsType;\n      hasTransformOrigin = true;\n    } else if (key !== \"transform\" || typeof value !== \"function\") {\n      // Handle all remaining values. Decide which map to save to depending\n      // on whether this is a CSS variable\n      var bucket = isCSSVariable(key) ? vars : style; // If we need to perform scale correction, and we have a handler for this\n      // value type (ie borderRadius), perform it\n\n      if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {\n        var corrected = valueScaleCorrection[key].process(value, targetBox, delta, treeScale);\n        /**\n         * Scale-correctable values can define a number of other values to break\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n         */\n\n        var applyTo = valueScaleCorrection[key].applyTo;\n\n        if (applyTo) {\n          var num = applyTo.length;\n\n          for (var i = 0; i < num; i++) {\n            bucket[applyTo[i]] = corrected;\n          }\n        } else {\n          bucket[key] = corrected;\n        }\n      } else {\n        bucket[key] = valueAsType;\n      }\n    }\n  } // Only process transform if values aren't defaults\n\n\n  if (hasTransform || transformTemplate) {\n    if (!isLayoutProjectionEnabled) {\n      style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n    } else {\n      style.transform = createDeltaTransform(deltaFinal, treeScale);\n      if (transformTemplate) style.transform = transformTemplate(transform, style.transform);\n    }\n  } // Only process transform origin if values aren't default\n\n\n  if (hasTransformOrigin) {\n    var originX = isLayoutProjectionEnabled ? deltaFinal.x.origin * 100 + \"%\" : transformOrigin.originX || \"50%\";\n    var originY = isLayoutProjectionEnabled ? deltaFinal.y.origin * 100 + \"%\" : transformOrigin.originY || \"50%\";\n    var originZ = transformOrigin.originZ || \"0\";\n    style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n  }\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2]; // Copy the current axis to the final axis before mutation\n\n  final.min = axis.min;\n  final.max = axis.max;\n  var originPoint = mix(axis.min, axis.max, transforms[originKey] || 0.5); // Apply the axis delta to the final axis\n\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\n\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\n\n\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  var originPoint = mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2];\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within HTMLVisualElement.updateLayoutDelta\n */\n\n\nfunction applyTreeDeltas(box, treePath) {\n  var treeLength = treePath.length;\n\n  for (var i = 0; i < treeLength; i++) {\n    applyBoxDelta(box, treePath[i].delta);\n  }\n}\n\nvar clampProgress = clamp(0, 1);\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n/**\n * Calculate the translate needed to be applied to source to get target\n */\n\n\nfunction calcTranslate(source, target, origin) {\n  var sourcePoint = mix(source.min, source.max, origin);\n  var targetPoint = mix(target.min, target.max, origin);\n  return targetPoint - sourcePoint;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n  delta.origin = origin === undefined ? calcOrigin(source, target) : origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = targetLength / sourceLength;\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = calcTranslate(source, target, delta.origin);\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, origin);\n  updateAxisDelta(delta.y, source.y, target.y, origin);\n}\n/**\n * Update the treeScale by incorporating the parent's latest scale into its treeScale.\n */\n\n\nfunction updateTreeScale(treeScale, parentTreeScale, parentDelta) {\n  treeScale.x = parentTreeScale.x * parentDelta.x.scale;\n  treeScale.y = parentTreeScale.y * parentDelta.y.scale;\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nvar isKeyframesTarget = function (v) {\n  return Array.isArray(v);\n};\n\nvar underDampedSpring = function () {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar overDampedSpring = function (to) {\n  return {\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35\n  };\n};\n\nvar linearTween = function () {\n  return {\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function (values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: overDampedSpring,\n  scaleY: overDampedSpring,\n  scale: overDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: overDampedSpring\n};\n\nvar getDefaultTransition = function (valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n\n  return __assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\n * updates with `to` and then completes. By using this we can compose instant transitions\n * in with the same logic that applies `delay` or returns a `Promise` etc.\n *\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\n * the animation until after the duration finishes. This is for situations when you're **only**\n * animating non-animatable values and then setting something on `transitionEnd`. Really\n * you want this to fire after the \"animation\" finishes, rather than instantly.\n *\n * ```\n * animate={{\n *   display: 'block',\n *   transitionEnd: { display: 'none' }\n * }}\n * ```\n */\n\n\nvar just = function (_a) {\n  var to = _a.to,\n      duration = _a.duration;\n  return action(function (_a) {\n    var update = _a.update,\n        complete = _a.complete;\n    update(to);\n    duration ? delay(duration).start({\n      complete: complete\n    }) : complete();\n  });\n};\n\nvar easingDefinitionToFunction = function (definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var x1 = definition[0],\n        y1 = definition[1],\n        x2 = definition[2],\n        y2 = definition[3];\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function (ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function (v) {\n  return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nvar isAnimatable = function (key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n      return true;\n    }\n\n  return false;\n};\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nvar secondsToMilliseconds = function (seconds) {\n  return seconds * 1000;\n};\n\nvar transitions = {\n  tween: tween,\n  spring: spring,\n  keyframes: keyframes$1,\n  inertia: inertia,\n  just: just\n};\nvar transitionOptionParser = {\n  tween: function (opts) {\n    if (opts.ease) {\n      var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n      opts.ease = easingDefinitionToFunction(ease);\n    }\n\n    return opts;\n  },\n  keyframes: function (_a) {\n    var from = _a.from,\n        to = _a.to,\n        velocity = _a.velocity,\n        opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n\n    if (opts.values && opts.values[0] === null) {\n      var values = __spreadArrays(opts.values);\n\n      values[0] = from;\n      opts.values = values;\n    }\n\n    if (opts.ease) {\n      opts.easings = isEasingArray(opts.ease) ? opts.ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(opts.ease);\n    }\n\n    opts.ease = linear;\n    return opts;\n  }\n};\n\nvar isTransitionDefined = function (_a) {\n  var when = _a.when,\n      delay = _a.delay,\n      delayChildren = _a.delayChildren,\n      staggerChildren = _a.staggerChildren,\n      staggerDirection = _a.staggerDirection,\n      transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n\n  return Object.keys(transition).length;\n};\n\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\n  var delay = transitionDefinition ? transitionDefinition.delay : 0; // If no object, return default transition\n  // A better way to handle this would be to deconstruct out all the shared Orchestration props\n  // and see if there's any props remaining\n\n  if (transitionDefinition === undefined || !isTransitionDefined(transitionDefinition)) {\n    return __assign({\n      delay: delay\n    }, getDefaultTransition(key, to));\n  }\n\n  var valueTransitionDefinition = transitionDefinition[key] || transitionDefinition.default || transitionDefinition;\n\n  if (valueTransitionDefinition.type === false) {\n    return {\n      delay: valueTransitionDefinition.hasOwnProperty(\"delay\") ? valueTransitionDefinition.delay : delay,\n      to: isKeyframesTarget(to) ? to[to.length - 1] : to,\n      type: \"just\"\n    };\n  } else if (isKeyframesTarget(to)) {\n    return __assign(__assign({\n      values: to,\n      duration: 0.8,\n      delay: delay,\n      ease: \"linear\"\n    }, valueTransitionDefinition), {\n      // This animation must be keyframes if we're animating through an array\n      type: \"keyframes\"\n    });\n  } else {\n    return __assign({\n      type: \"tween\",\n      to: to,\n      delay: delay\n    }, valueTransitionDefinition);\n  }\n};\n\nvar preprocessOptions = function (type, opts) {\n  return transitionOptionParser[type] ? transitionOptionParser[type](opts) : opts;\n};\n\nvar getAnimation = function (key, value, target, transition) {\n  var origin = value.get();\n  var isOriginAnimatable = isAnimatable(key, origin);\n  var isTargetAnimatable = isAnimatable(key, target); // TODO we could probably improve this check to ensure both values are of the same type -\n  // for instance 100 to #fff. This might live better in Popmotion.\n\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\"); // Parse the `transition` prop and return options for the Popmotion animation\n\n  var _a = getTransitionDefinition(key, target, transition),\n      _b = _a.type,\n      type = _b === void 0 ? \"tween\" : _b,\n      transitionDefinition = __rest(_a, [\"type\"]); // If this is an animatable pair of values, return an animation, otherwise use `just`\n\n\n  var actionFactory = isOriginAnimatable && isTargetAnimatable ? transitions[type] : just;\n  var opts = preprocessOptions(type, __assign({\n    from: origin,\n    velocity: value.getVelocity()\n  }, transitionDefinition)); // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n\n  if (isDurationAnimation(opts)) {\n    if (opts.duration) {\n      opts.duration = secondsToMilliseconds(opts.duration);\n    }\n\n    if (opts.repeatDelay) {\n      opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n    }\n  }\n\n  return [actionFactory, opts];\n};\n/**\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\n *\n * @internal\n */\n\n\nfunction startAnimation(key, value, target, _a) {\n  if (_a === void 0) {\n    _a = {};\n  }\n\n  var _b = _a.delay,\n      delay$1 = _b === void 0 ? 0 : _b,\n      transition = __rest(_a, [\"delay\"]);\n\n  return value.start(function (complete) {\n    var activeAnimation;\n\n    var _a = getAnimation(key, value, target, transition),\n        animationFactory = _a[0],\n        _b = _a[1],\n        valueDelay = _b.delay,\n        options = __rest(_b, [\"delay\"]);\n\n    if (valueDelay !== undefined) {\n      delay$1 = valueDelay;\n    }\n\n    var animate = function () {\n      var animation = animationFactory(options); // Bind animation opts to animation\n\n      activeAnimation = animation.start({\n        update: function (v) {\n          return value.set(v);\n        },\n        complete: complete\n      });\n    }; // If we're delaying this animation, only resolve it **after** the delay to\n    // ensure the value's resolve velocity is up-to-date.\n\n\n    if (delay$1) {\n      activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n        complete: animate\n      });\n    } else {\n      animate();\n    }\n\n    return function () {\n      if (activeAnimation) activeAnimation.stop();\n    };\n  });\n}\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\n\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n/**\n * A VisualElement for HTMLElements\n */\n\n\nvar HTMLVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(HTMLVisualElement, _super);\n\n  function HTMLVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     *\n     */\n\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: true,\n      allowTransformNone: true\n    };\n    /**\n     * A mutable record of styles we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.style = {};\n    /**\n     * A record of styles we only want to apply via React. This gets set in useMotionValues\n     * and applied in the render function. I'd prefer this to live somewhere else to decouple\n     * VisualElement from React but works for now.\n     */\n\n    _this.reactStyle = {};\n    /**\n     * A mutable record of CSS variables we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.vars = {};\n    /**\n     * A mutable record of transforms we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transform = {};\n    /**\n     * A mutable record of transform origins we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformOrigin = {};\n    /**\n     * A mutable record of transform keys we want to apply to the rendered Element. We order\n     * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformKeys = [];\n    _this.config = _this.defaultConfig;\n    /**\n     * ========================================\n     * Layout\n     * ========================================\n     */\n\n    _this.isLayoutProjectionEnabled = false;\n    /**\n     * A set of layout update event handlers. These are only called once all layouts have been read,\n     * making it safe to perform DOM write operations.\n     */\n\n    _this.layoutUpdateListeners = new Set();\n    /**\n     * Keep track of whether the viewport box has been updated since the last render.\n     * If it has, we want to fire the onViewportBoxUpdate listener.\n     */\n\n    _this.hasViewportBoxUpdated = false;\n    /**\n     * The visual target we want to project our component into on a given frame\n     * before applying transforms defined in `animate` or `style`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.targetBoxFinal = axisBox();\n    /**\n     * The overall scale of the local coordinate system as transformed by all parents\n     * of this component. We use this for scale correction on our calculated layouts\n     * and scale-affected values like `boxShadow`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.treeScale = {\n      x: 1,\n      y: 1\n    };\n    /**\n     * The delta between the boxCorrected and the desired\n     * targetBox (before user-set transforms are applied). The calculated output will be\n     * handed to the renderer and used as part of the style correction calculations, for\n     * instance calculating how to display the desired border-radius correctly.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.delta = delta();\n    /**\n     * The delta between the boxCorrected and the desired targetBoxFinal. The calculated\n     * output will be handed to the renderer and used to project the boxCorrected into\n     * the targetBoxFinal.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.deltaFinal = delta();\n    /**\n     *\n     */\n\n    _this.stopLayoutAxisAnimation = {\n      x: function () {},\n      y: function () {}\n    };\n    _this.isTargetBoxLocked = false;\n    /**\n     *\n     */\n\n    _this.axisProgress = {\n      x: motionValue(0),\n      y: motionValue(0)\n    };\n\n    _this.updateLayoutDelta = function () {\n      _this.isLayoutProjectionEnabled && _this.box && _this.updateDeltas();\n      /**\n       * Ensure all children layouts are also updated.\n       *\n       * This uses a pre-bound function executor rather than a lamda to avoid creating a new function\n       * multiple times per frame (source of mid-animation GC)\n       */\n\n      _this.children.forEach(fireUpdateLayoutDelta);\n    };\n\n    return _this;\n  }\n  /**\n   * When a value is removed, we want to make sure it's removed from all rendered data structures.\n   */\n\n\n  HTMLVisualElement.prototype.removeValue = function (key) {\n    _super.prototype.removeValue.call(this, key);\n\n    delete this.vars[key];\n    delete this.style[key];\n  };\n  /**\n   * Empty the mutable data structures by re-creating them. We can do this every React render\n   * as the comparative workload to the rest of the render is very low and this is also when\n   * we want to reflect values that might have been removed by the render.\n   */\n\n\n  HTMLVisualElement.prototype.clean = function () {\n    this.style = {};\n    this.vars = {};\n    this.transform = {};\n  };\n\n  HTMLVisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign(__assign({}, this.defaultConfig), config);\n  };\n  /**\n   * Read a value directly from the HTMLElement style.\n   */\n\n\n  HTMLVisualElement.prototype.read = function (key) {\n    return this.getComputedStyle()[key] || 0;\n  };\n  /**\n   * Read a value directly from the HTMLElement in case it's not defined by a Motion\n   * prop. If it's a transform, we just return a pre-defined default value as reading these\n   * out of a matrix is either error-prone or can incur a big payload for little benefit.\n   */\n\n\n  HTMLVisualElement.prototype.readNativeValue = function (key) {\n    if (isTransformProp(key)) {\n      var defaultValueType = getDefaultValueType(key);\n      return defaultValueType ? defaultValueType.default || 0 : 0;\n    } else {\n      return this.read(key);\n    }\n  };\n\n  HTMLVisualElement.prototype.enableLayoutProjection = function () {\n    this.isLayoutProjectionEnabled = true;\n  };\n\n  HTMLVisualElement.prototype.hide = function () {\n    if (this.isVisible === false) return;\n    this.isVisible = false;\n    this.scheduleRender();\n  };\n\n  HTMLVisualElement.prototype.show = function () {\n    if (this.isVisible === true) return;\n    this.isVisible = true;\n    this.scheduleRender();\n  };\n  /**\n   * Register an event listener to fire when the layout is updated. We might want to expose support\n   * for this via a `motion` prop.\n   */\n\n\n  HTMLVisualElement.prototype.onLayoutUpdate = function (callback) {\n    var _this = this;\n\n    this.layoutUpdateListeners.add(callback);\n    return function () {\n      return _this.layoutUpdateListeners.delete(callback);\n    };\n  };\n  /**\n   * To be called when all layouts are successfully updated. In turn we can notify layoutUpdate\n   * subscribers.\n   */\n\n\n  HTMLVisualElement.prototype.layoutReady = function (config) {\n    var _this = this;\n\n    this.layoutUpdateListeners.forEach(function (listener) {\n      listener(_this.box, _this.prevViewportBox || _this.box, config);\n    });\n  };\n  /**\n   * Measure and return the Element's bounding box. We convert it to a AxisBox2D\n   * structure to make it easier to work on each individual axis generically.\n   */\n\n\n  HTMLVisualElement.prototype.getBoundingBox = function () {\n    var transformPagePoint = this.config.transformPagePoint;\n    return getBoundingBox(this.element, transformPagePoint);\n  };\n\n  HTMLVisualElement.prototype.getBoundingBoxWithoutTransforms = function () {\n    var bbox = this.getBoundingBox();\n    removeBoxTransforms(bbox, this.latest);\n    return bbox;\n  };\n  /**\n   * Return the computed style after a render.\n   */\n\n\n  HTMLVisualElement.prototype.getComputedStyle = function () {\n    return window.getComputedStyle(this.element);\n  };\n  /**\n   *\n   */\n\n\n  HTMLVisualElement.prototype.snapshotBoundingBox = function () {\n    this.prevViewportBox = this.getBoundingBoxWithoutTransforms();\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n\n    var _a = this.axisProgress,\n        x = _a.x,\n        y = _a.y;\n\n    if (!this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating()) {\n      this.targetBox = copyAxisBox(this.prevViewportBox);\n    }\n  };\n\n  HTMLVisualElement.prototype.measureLayout = function () {\n    this.box = this.getBoundingBox();\n    this.boxCorrected = copyAxisBox(this.box);\n    if (!this.targetBox) this.targetBox = copyAxisBox(this.box);\n  };\n  /**\n   * Ensure the targetBox reflects the latest visual box on screen\n   */\n\n\n  HTMLVisualElement.prototype.refreshTargetBox = function () {\n    this.targetBox = this.getBoundingBoxWithoutTransforms();\n  };\n\n  HTMLVisualElement.prototype.lockTargetBox = function () {\n    this.isTargetBoxLocked = true;\n  };\n\n  HTMLVisualElement.prototype.unlockTargetBox = function () {\n    this.stopLayoutAnimation();\n    this.isTargetBoxLocked = false;\n  };\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n\n\n  HTMLVisualElement.prototype.resetTransform = function () {\n    var transformTemplate = this.config.transformTemplate;\n    this.element.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform\n\n    this.scheduleRender();\n  };\n  /**\n   * Set new min/max boundaries to project an axis into\n   */\n\n\n  HTMLVisualElement.prototype.setAxisTarget = function (axis, min, max) {\n    var targetAxis = this.targetBox[axis];\n    targetAxis.min = min;\n    targetAxis.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n    this.hasViewportBoxUpdated = true;\n    this.rootParent.scheduleUpdateLayoutDelta();\n  };\n  /**\n   *\n   */\n\n\n  HTMLVisualElement.prototype.startLayoutAxisAnimation = function (axis, transition) {\n    var _this = this;\n\n    var progress = this.axisProgress[axis];\n    var _a = this.targetBox[axis],\n        min = _a.min,\n        max = _a.max;\n    var length = max - min;\n    progress.clearListeners();\n    progress.set(min);\n    progress.set(min); // Set twice to hard-reset velocity\n\n    progress.onChange(function (v) {\n      return _this.setAxisTarget(axis, v, v + length);\n    });\n    return startAnimation(axis, progress, 0, transition);\n  };\n\n  HTMLVisualElement.prototype.stopLayoutAnimation = function () {\n    var _this = this;\n\n    eachAxis(function (axis) {\n      return _this.axisProgress[axis].stop();\n    });\n  };\n  /**\n   * Update the layout deltas to reflect the relative positions of the layout\n   * and the desired target box\n   */\n\n\n  HTMLVisualElement.prototype.updateDeltas = function () {\n    var _a, _b;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n\n\n    resetBox(this.boxCorrected, this.box);\n    /**\n     * If this component has a parent, update this treeScale by incorporating the parent's\n     * delta into its treeScale.\n     */\n\n    if (this.parent) {\n      updateTreeScale(this.treeScale, this.parent.treeScale, this.parent.delta);\n    }\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n\n\n    applyTreeDeltas(this.boxCorrected, this.treePath);\n    /**\n     * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n     * This is the final box that we will then project into by calculating a transform delta and\n     * applying it to the corrected box.\n     */\n\n    applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n\n    updateBoxDelta(this.delta, this.boxCorrected, this.targetBox);\n    /**\n     * Update the delta between the corrected box and the final target box, after\n     * user-set transforms are applied to it. This will be used by the renderer to\n     * create a transform style that will reproject the element from its actual layout\n     * into the desired bounding box.\n     */\n\n    updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal);\n    /**\n     * If we have a listener for the viewport box, fire it.\n     */\n\n    this.hasViewportBoxUpdated && ((_b = (_a = this.config).onViewportBoxUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, this.targetBox, this.delta));\n    this.hasViewportBoxUpdated = false;\n    /**\n     * Ensure this element renders on the next frame if the projection transform has changed.\n     */\n\n    var deltaTransform = createDeltaTransform(this.deltaFinal, this.treeScale);\n    deltaTransform !== this.deltaTransform && this.scheduleRender();\n    this.deltaTransform = deltaTransform;\n  };\n  /**\n   * ========================================\n   * Build & render\n   * ========================================\n   */\n\n  /**\n   * Build a style prop using the latest resolved MotionValues\n   */\n\n\n  HTMLVisualElement.prototype.build = function () {\n    if (this.isVisible !== undefined) {\n      this.style.visibility = this.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);\n  };\n  /**\n   * Render the Element by rebuilding and applying the latest styles and vars.\n   */\n\n\n  HTMLVisualElement.prototype.render = function () {\n    // Rebuild the latest animated values into style and vars caches.\n    this.build(); // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n\n    Object.assign(this.element.style, this.style); // Loop over any CSS variables and assign those.\n\n    for (var key in this.vars) {\n      this.element.style.setProperty(key, this.vars[key]);\n    }\n  };\n\n  return HTMLVisualElement;\n}(VisualElement);\n/**\n * Pre-bound version of updateLayoutDelta so we're not creating a new function multiple\n * times per frame.\n */\n\n\nvar fireUpdateLayoutDelta = function (child) {\n  return child.updateLayoutDelta();\n};\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\n\n\nfunction useConstant(init) {\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function (progress, length) {\n  return px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  /**\n   * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\n   */\n\n\n  buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (originX !== undefined || originY !== undefined || style.transform) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n\n  return attrs;\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\"]);\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n/**\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\n * share data structures.\n */\n\n\nvar SVGVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(SVGVisualElement, _super);\n\n  function SVGVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable record of attributes we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n\n    _this.attrs = {};\n    /**\n     * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\n     */\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: false\n    };\n    /**\n     * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\n     * being assigned to config\n     */\n\n    _this.config = _this.defaultConfig;\n    return _this;\n  }\n  /**\n   * Measure the SVG element on mount. This can affect page rendering so there might be a\n   * better time to perform this - for instance dynamically only if there's a transform-origin dependent\n   * transform being set (like rotate)\n   */\n\n\n  SVGVisualElement.prototype.mount = function (element) {\n    _super.prototype.mount.call(this, element);\n\n    this.measure();\n  };\n  /**\n   * Update the SVG dimensions and path length\n   */\n\n\n  SVGVisualElement.prototype.measure = function () {\n    try {\n      this.dimensions = typeof this.element.getBBox === \"function\" ? this.element.getBBox() : this.element.getBoundingClientRect();\n    } catch (e) {\n      // Most likely trying to measure an unrendered element under Firefox\n      this.dimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    if (isPath(this.element)) {\n      this.totalPathLength = this.element.getTotalLength();\n    }\n  };\n  /**\n   * Empty the mutable data structures in case attrs have been removed between renders.\n   */\n\n\n  SVGVisualElement.prototype.clean = function () {\n    _super.prototype.clean.call(this);\n\n    this.attrs = {};\n  };\n  /**\n   * Read an attribute directly from the SVGElement\n   */\n\n\n  SVGVisualElement.prototype.read = function (key) {\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return this.element.getAttribute(key);\n  };\n\n  SVGVisualElement.prototype.build = function () {\n    buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n  };\n\n  SVGVisualElement.prototype.render = function () {\n    // Update HTML styles and CSS variables\n    _super.prototype.render.call(this); // Loop through attributes and apply them to the SVGElement\n\n\n    for (var key in this.attrs) {\n      this.element.setAttribute(camelToDash(key), this.attrs[key]);\n    }\n  };\n\n  return SVGVisualElement;\n}(HTMLVisualElement);\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n\nvar svgElements = [\"animate\", \"circle\", \"clipPath\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"tspan\", \"use\", \"view\"];\nvar svgTagNames = new Set(svgElements);\n/**\n * Determine whether this is a HTML or SVG component based on if the provided\n * Component is a string and a recognised SVG tag. A potentially better way to\n * do this would be to offer a `motion.customSVG` function and determine this\n * when we generate the `motion.circle` etc components.\n */\n\nfunction isSVGComponent(Component) {\n  return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n/**\n * @public\n */\n\n\nvar PresenceContext = createContext(null);\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\n\nfunction usePresence() {\n  var context = useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n\n  var id = useUniqueId();\n  useEffect(function () {\n    return register(id);\n  }, []);\n\n  var safeToRemove = function () {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * @public\n */\n\n\nfunction useIsPresent() {\n  var context = useContext(PresenceContext);\n  return context === null ? true : context.isPresent;\n}\n\nvar counter = 0;\n\nvar incrementId = function () {\n  return counter++;\n};\n\nvar useUniqueId = function () {\n  return useConstant(incrementId);\n};\n/**\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\n * or SVGVisualElement for the component.\n */\n\n\nvar useDomVisualElement = function (Component, props, parent, isStatic, ref) {\n  var visualElement = useConstant(function () {\n    var DOMVisualElement = isSVGComponent(Component) ? SVGVisualElement : HTMLVisualElement;\n    return new DOMVisualElement(parent, ref);\n  });\n  visualElement.updateConfig(__assign({\n    enableHardwareAcceleration: !isStatic\n  }, props));\n  visualElement.layoutId = props.layoutId;\n  var isPresent = useIsPresent();\n  visualElement.isPresent = props.isPresent !== undefined ? props.isPresent : isPresent;\n  return visualElement;\n};\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"static\", \"layout\", \"layoutId\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileHover\", \"whileTap\", \"onHoverEnd\", \"onHoverStart\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar isPropValid = function (key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n\n  isPropValid = function (key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props) {\n  var domProps = {};\n\n  for (var key in props) {\n    if (isPropValid(key)) domProps[key] = props[key];\n  }\n\n  return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n  var drag = _a.drag; // The `any` isn't ideal but it is the type of createElement props argument\n\n  var htmlProps = {\n    style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars)\n  };\n\n  if (!!drag) {\n    // Disable text selection\n    htmlProps.style.userSelect = \"none\"; // Disable the ghost element when a user drags\n\n    htmlProps.draggable = false;\n  }\n\n  return htmlProps;\n}\n/**\n * Build React props for SVG elements\n */\n\n\nfunction buildSVGProps(visualElement) {\n  return __assign(__assign({}, visualElement.attrs), {\n    style: __assign({}, visualElement.reactStyle)\n  });\n}\n\nfunction render(Component, props, visualElement) {\n  // Only filter props from components we control, ie `motion.div`. If this\n  // is a custom component pass along everything provided to it.\n  var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n  /**\n   * Every render, empty and rebuild the animated values to be applied to our Element.\n   * During animation these data structures are used in a mutable fashion to reduce\n   * garbage collection, but between renders we can flush them to remove values\n   * that might have been taken out of the provided props.\n   */\n\n  visualElement.clean();\n  visualElement.build(); // Generate props to visually render this component\n\n  var visualProps = isSVGComponent(Component) ? buildSVGProps(visualElement) : buildHTMLProps(visualElement, props);\n  return createElement(Component, __assign(__assign(__assign({}, forwardedProps), {\n    ref: visualElement.ref\n  }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var token = match[1],\n      fallback = match[2];\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = parseCSSVariable(current),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved;\n  } else if (isCSSVariable$1(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable$1(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable$1(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function (v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.getBoundingBox();\n  var elementComputedStyle = visualElement.getComputedStyle();\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValues(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.render();\n  var targetBbox = visualElement.getBoundingBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var key = _a[0],\n            value = _a[1];\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n/**\n * Use callback either only on the initial render or on all renders. In concurrent mode\n * the \"initial\" render might run multiple times\n *\n * @param callback - Callback to run\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\n *\n * @public\n */\n\n\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n  if (isInitialOnly === void 0) {\n    isInitialOnly = false;\n  }\n\n  var isInitialRender = useRef(true);\n\n  if (!isInitialOnly || isInitialOnly && isInitialRender.current) {\n    callback();\n  }\n\n  isInitialRender.current = false;\n}\n/**\n * Control animations on one or more components.\n *\n * @public\n */\n\n\nvar AnimationControls =\n/** @class */\nfunction () {\n  function AnimationControls() {\n    /**\n     * Track whether the host component has mounted.\n     *\n     * @internal\n     */\n    this.hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     *\n     * @internal\n     */\n\n    this.pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     *\n     * @internal\n     */\n\n    this.componentControls = new Set();\n  }\n  /**\n   * Set variants on this and all child components.\n   *\n   * @param variants - The variants to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setVariants = function (variants) {\n    this.variants = variants;\n    this.componentControls.forEach(function (controls) {\n      return controls.setVariants(variants);\n    });\n  };\n  /**\n   * Set a default transition on this and all child components\n   *\n   * @param transition - The default transition to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setDefaultTransition = function (transition) {\n    this.defaultTransition = transition;\n    this.componentControls.forEach(function (controls) {\n      return controls.setDefaultTransition(transition);\n    });\n  };\n  /**\n   * Subscribes a component's animation controls to this.\n   *\n   * @param controls - The controls to subscribe\n   * @returns An unsubscribe function.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    if (this.variants) controls.setVariants(this.variants);\n    if (this.defaultTransition) controls.setDefaultTransition(this.defaultTransition);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Starts an animation on all linked components.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * controls.start(\"variantLabel\")\n   * controls.start({\n   *   x: 0,\n   *   transition: { duration: 1 }\n   * })\n   * ```\n   *\n   * @param definition - Properties or variant label to animate to\n   * @param transition - Optional `transtion` to apply to a variant\n   * @returns - A `Promise` that resolves when all animations have completed.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.start = function (definition, transitionOverride) {\n    var _this = this;\n\n    if (this.hasMounted) {\n      var animations_1 = [];\n      this.componentControls.forEach(function (controls) {\n        var animation = controls.start(definition, {\n          transitionOverride: transitionOverride\n        });\n        animations_1.push(animation);\n      });\n      return Promise.all(animations_1);\n    } else {\n      return new Promise(function (resolve) {\n        _this.pendingAnimations.push({\n          animation: [definition, transitionOverride],\n          resolve: resolve\n        });\n      });\n    }\n  };\n  /**\n   * Instantly set to a set of properties or a variant.\n   *\n   * ```jsx\n   * // With properties\n   * controls.set({ opacity: 0 })\n   *\n   * // With variants\n   * controls.set(\"hidden\")\n   * ```\n   *\n   * @internalremarks\n   * We could perform a similar trick to `.start` where this can be called before mount\n   * and we maintain a list of of pending actions that get applied on mount. But the\n   * expectation of `set` is that it happens synchronously and this would be difficult\n   * to do before any children have even attached themselves. It's also poor practise\n   * and we should discourage render-synchronous `.start` calls rather than lean into this.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.set = function (definition) {\n    invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n    return this.componentControls.forEach(function (controls) {\n      return controls.apply(definition);\n    });\n  };\n  /**\n   * Stops animations on all linked components.\n   *\n   * ```jsx\n   * controls.stop()\n   * ```\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.stop = function () {\n    this.componentControls.forEach(function (controls) {\n      return controls.stop();\n    });\n  };\n  /**\n   * Initialises the animation controls.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.mount = function () {\n    var _this = this;\n\n    this.hasMounted = true;\n    this.pendingAnimations.forEach(function (_a) {\n      var animation = _a.animation,\n          resolve = _a.resolve;\n      return _this.start.apply(_this, animation).then(resolve);\n    });\n  };\n  /**\n   * Stops all child animations when the host component unmounts.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.unmount = function () {\n    this.hasMounted = false;\n    this.stop();\n  };\n\n  return AnimationControls;\n}();\n/**\n * @internal\n */\n\n\nvar animationControls = function () {\n  return new AnimationControls();\n};\n/**\n * @internal\n */\n\n\nvar MotionContext = createContext({\n  static: false\n});\n\nvar isVariantLabel = function (v) {\n  return typeof v === \"string\" || Array.isArray(v);\n};\n\nvar isAnimationControls = function (v) {\n  return v instanceof AnimationControls;\n};\n/**\n * Set up the context for children motion components.\n *\n * We also use this opportunity to apply `initial` values\n */\n\n\nvar useMotionContext = function (parentContext, controls, visualElement, isStatic, _a) {\n  if (isStatic === void 0) {\n    isStatic = false;\n  }\n\n  var initial = _a.initial,\n      animate = _a.animate,\n      variants = _a.variants,\n      whileTap = _a.whileTap,\n      whileHover = _a.whileHover,\n      layoutId = _a.layoutId; // Determine whether this is a root element of an AnimatePresence component\n\n  var presenceContext = useContext(PresenceContext);\n  var presenceId = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;\n  visualElement.isPresenceRoot = parentContext.presenceId !== presenceId; // Override initial with that from a parent context, if defined\n\n  if ((presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== undefined) {\n    initial = presenceContext.initial;\n  }\n\n  var initialState;\n\n  if (initial === false && !isAnimationControls(animate)) {\n    initialState = animate;\n  } else if (typeof initial !== \"boolean\") {\n    initialState = initial;\n  } // Track mounted status so children can detect whether they were present during their\n  // parent's first render\n\n\n  var hasMounted = useRef(false); // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n  // if we're being used to control variants, or if we're being passed animation controls.\n  // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n  // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n  // that this restriction is removed.\n\n  var shouldPropagateControls = variants || isVariantLabel(animate) || isVariantLabel(whileTap) || isVariantLabel(whileHover) || isAnimationControls(animate); // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n\n  var targetInitial = isVariantLabel(initialState) ? initialState : parentContext.initial; // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n  // the tree initially animates.\n\n  var targetAnimate = isVariantLabel(animate) ? animate : parentContext.animate; // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n  // or in another non-animation/interaction environment.\n\n  var initialDependency = isStatic ? targetInitial : null; // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n  // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n  // We want to do this as we rely on React's component rendering order each render cycle to determine\n  // the new order of any child components for the `staggerChildren` functionality.\n\n  var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate) ? targetAnimate : null; // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n  // unlikely to change, by making the context an object it'll be considered a new value every render.\n  // So all child motion components will re-render as a result.\n\n  var context = useMemo(function () {\n    return {\n      controls: shouldPropagateControls ? controls : parentContext.controls,\n      initial: targetInitial,\n      animate: targetAnimate,\n      visualElement: visualElement,\n      hasMounted: hasMounted,\n      isReducedMotion: parentContext.isReducedMotion,\n      presenceId: presenceId\n    };\n  }, [initialDependency, animateDependency, parentContext.isReducedMotion, animate, layoutId, presenceId]); // Update the `static` property every render. This is unlikely to change but also essentially free.\n\n  context.static = isStatic; // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n  // in `initial`.\n\n  useInitialOrEveryRender(function () {\n    var initialToApply = initialState || parentContext.initial;\n    initialToApply && controls.apply(initialToApply);\n  }, !isStatic);\n  useEffect(function () {\n    hasMounted.current = true;\n  }, []);\n  return context;\n};\n\nvar checkShouldInheritVariant = function (_a) {\n  var animate = _a.animate,\n      variants = _a.variants,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b;\n  return inherit && !!variants && (!animate || animate instanceof AnimationControls);\n};\n\nvar isMotionValue = function (value) {\n  return value instanceof MotionValue;\n};\n/**\n * Scrape props for MotionValues and add/remove them to this component's\n * VisualElement\n */\n\n\nfunction useMotionValues(visualElement, props) {\n  var prev = useConstant(empty);\n  /**\n   * Remove MotionValues that are no longer present\n   */\n\n  for (var key in prev) {\n    var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n    var existsAsProp = props[key];\n    var existsAsStyle = props.style && props.style[key];\n    var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n    var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n    var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n    var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n\n    if (transformRemoved || motionValueRemoved) {\n      visualElement.removeValue(key);\n      delete prev[key];\n    }\n  }\n  /**\n   * Add incoming MotionValues\n   */\n\n\n  addMotionValues(visualElement, prev, props);\n  if (props.style) addMotionValues(visualElement, prev, props.style, true);\n  /**\n   * Transform custom values if provided a handler, ie size -> width/height\n   * Ideally we'd ditch this by removing support for size and other custom values from Framer.\n   */\n\n  if (props.transformValues) {\n    visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n  }\n}\n/**\n * Add incoming MotionValues\n *\n * TODO: Type the VisualElements properly\n */\n\n\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n  if (isStyle === void 0) {\n    isStyle = false;\n  }\n\n  if (isStyle) visualElement.reactStyle = {};\n\n  for (var key in source) {\n    var value = source[key];\n    var foundMotionValue = false;\n\n    if (isMotionValue(value)) {\n      // If this is a MotionValue, add it if it isn't a reserved key\n      if (!reservedNames.has(key)) {\n        visualElement.addValue(key, value);\n        foundMotionValue = true;\n      }\n    } else if (isTransformProp(key) || isTransformOriginProp(key)) {\n      // If this is a transform prop, always create a MotionValue\n      // to ensure we can reconcile them all together.\n      if (!visualElement.hasValue(key)) {\n        visualElement.addValue(key, motionValue(value));\n      } else if (value !== prev[key]) {\n        // If the MotionValue already exists, update it with the\n        // latest incoming value\n        var motion = visualElement.getValue(key);\n        motion.set(value);\n      }\n\n      foundMotionValue = true;\n    } else if (isStyle) {\n      visualElement.reactStyle[key] = value;\n    }\n\n    if (foundMotionValue) prev[key] = value;\n  }\n}\n/**\n * These are props we accept as MotionValues but don't want to add\n * to the VisualElement\n */\n\n\nvar reservedNames = new Set([]);\n\nvar empty = function () {\n  return {};\n};\n\nvar isCustomValue = function (v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function (v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nvar isNumericalString = function (v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\n * Get the current value of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getCurrent = function (visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n};\n/**\n * Get the current velocity of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getVelocity = function (visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n};\n/**\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\n * check, just helps with typing.\n */\n\n\nvar isTargetResolver = function (p) {\n  return typeof p === \"function\";\n};\n/**\n * Check if value is a list of variant labels\n */\n\n\nvar isVariantLabels = function (v) {\n  return Array.isArray(v);\n};\n/**\n * Control animations for a single component\n *\n * @internal\n */\n\n\nvar VisualElementAnimationControls =\n/** @class */\nfunction () {\n  function VisualElementAnimationControls(visualElement, _a) {\n    var _this = this;\n\n    var makeTargetAnimatable = _a.makeTargetAnimatable;\n    /**\n     * A reference to the component's latest props. We could probably ditch this in\n     * favour to a reference to the `custom` prop now we don't send all props through\n     * to target resolvers.\n     */\n\n    this.props = {};\n    /**\n     * The component's variants, as provided by `variants`\n     */\n\n    this.variants = {};\n    /**\n     * A set of values that we animate back to when a value is cleared of all overrides.\n     */\n\n    this.baseTarget = {};\n    /**\n     * A series of target overrides that we can animate to/from when overrides are set/cleared.\n     */\n\n    this.overrides = [];\n    /**\n     * A series of target overrides as they were originally resolved.\n     */\n\n    this.resolvedOverrides = [];\n    /**\n     * A Set of currently active override indexes\n     */\n\n    this.activeOverrides = new Set();\n    /**\n     * A Set of value keys that are currently animating.\n     */\n\n    this.isAnimating = new Set();\n    /**\n     * Check if the associated `VisualElement` has a key with the provided string.\n     * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\n     */\n\n    this.hasValue = function (key) {\n      return !_this.visualElement.hasValue(key);\n    };\n\n    this.visualElement = visualElement;\n    this.makeTargetAnimatable = makeTargetAnimatable;\n    this.visualElement.forEachValue(function (value, key) {\n      return _this.baseTarget[key] = value.get();\n    });\n  }\n  /**\n   * Set the reference to the component's props.\n   * @param props -\n   */\n\n\n  VisualElementAnimationControls.prototype.setProps = function (props) {\n    this.props = props;\n  };\n  /**\n   * Set the reference to the component's variants\n   * @param variants -\n   */\n\n\n  VisualElementAnimationControls.prototype.setVariants = function (variants) {\n    if (variants) this.variants = variants;\n  };\n  /**\n   * Set the component's default transition\n   * @param transition -\n   */\n\n\n  VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n    if (transition) this.defaultTransition = transition;\n  };\n  /**\n   * Set motion values without animation.\n   *\n   * @param definition -\n   * @param isActive -\n   */\n\n\n  VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.isActive,\n        isActive = _c === void 0 ? new Set() : _c,\n        priority = _b.priority;\n\n    var _d = this.resolveVariant(definition),\n        target = _d.target,\n        transitionEnd = _d.transitionEnd;\n\n    target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n\n    for (var key in target) {\n      if (isActive.has(key)) return;\n      isActive.add(key);\n\n      if (target) {\n        var targetValue = resolveFinalValueInKeyframes(target[key]);\n\n        if (this.visualElement.hasValue(key)) {\n          var value = this.visualElement.getValue(key);\n          value && value.set(targetValue);\n        } else {\n          this.visualElement.addValue(key, motionValue(targetValue));\n        }\n\n        if (!priority) this.baseTarget[key] = targetValue;\n      }\n    }\n  };\n  /**\n   * Allows `transformValues` to be set by a component that allows us to\n   * transform the values in a given `Target`. This allows Framer Library\n   * to extend Framer Motion to animate `Color` variables etc. Currently we have\n   * to manually support these extended types here in Framer Motion.\n   *\n   * @param values -\n   */\n\n\n  VisualElementAnimationControls.prototype.transformValues = function (values) {\n    var transformValues = this.props.transformValues;\n    return transformValues ? transformValues(values) : values;\n  };\n  /**\n   * Check a `Target` for new values we haven't animated yet, and add them\n   * to the `MotionValueMap`.\n   *\n   * Currently there's functionality here that is DOM-specific, we should allow\n   * this functionality to be injected by the factory that creates DOM-specific\n   * components.\n   *\n   * @param target -\n   */\n\n\n  VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n    var newValueKeys = Object.keys(target).filter(this.hasValue);\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n\n    for (var i = 0; i < numNewValues; i++) {\n      var key = newValueKeys[i];\n      var targetValue = target[key];\n      var value = null; // If this is a keyframes value, we can attempt to use the first value in the\n      // array as that's going to be the first value of the animation anyway\n\n      if (Array.isArray(targetValue)) {\n        value = targetValue[0];\n      } // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n      // value from the DOM. It might be worth investigating whether to check props (for SVG)\n      // or props.style (for HTML) if the value exists there before attempting to read.\n\n\n      if (value === null) {\n        var readValue = this.visualElement.readNativeValue(key);\n        value = readValue !== undefined ? readValue : target[key];\n        invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n      }\n\n      if (typeof value === \"string\" && isNumericalString(value)) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(targetValue)) {\n        // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n        value = complex.getAnimatableNone(targetValue);\n      }\n\n      this.visualElement.addValue(key, motionValue(value));\n      this.baseTarget[key] = value;\n    }\n  };\n  /**\n   * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\n   * @param variant -\n   */\n\n\n  VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n    if (!variant) {\n      return {\n        target: undefined,\n        transition: undefined,\n        transitionEnd: undefined\n      };\n    }\n\n    if (isTargetResolver(variant)) {\n      // resolve current and velocity\n      variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n    }\n\n    var _a = variant.transition,\n        transition = _a === void 0 ? this.defaultTransition : _a,\n        transitionEnd = variant.transitionEnd,\n        target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n\n    return {\n      transition: transition,\n      transitionEnd: transitionEnd,\n      target: target\n    };\n  };\n  /**\n   * Get the highest active override priority index\n   */\n\n\n  VisualElementAnimationControls.prototype.getHighestPriority = function () {\n    if (!this.activeOverrides.size) return 0;\n    return Math.max.apply(Math, Array.from(this.activeOverrides));\n  };\n  /**\n   * Set an override. We add this layer of indirection so if, for instance, a tap gesture\n   * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\n   * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\n   * than the one that was resolved when the hover gesture animation started.\n   *\n   * @param definition -\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n    this.overrides[overrideIndex] = definition;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.setOverride(definition, overrideIndex);\n      });\n    }\n  };\n  /**\n   * Start an override animation.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n    var override = this.overrides[overrideIndex];\n\n    if (override) {\n      return this.start(override, {\n        priority: overrideIndex\n      });\n    }\n  };\n  /**\n   * Clear an override. We check every value we animated to in this override to see if\n   * its present on any lower-priority overrides. If not, we animate it back to its base target.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n    var _this = this;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.clearOverride(overrideIndex);\n      });\n    }\n\n    var override = this.overrides[overrideIndex];\n    if (!override) return;\n    this.activeOverrides.delete(overrideIndex);\n    var highest = this.getHighestPriority();\n    this.resetIsAnimating();\n\n    if (highest) {\n      var highestOverride = this.overrides[highest];\n      highestOverride && this.startOverride(highest);\n    } // Figure out which remaining values were affected by the override and animate those\n\n\n    var overrideTarget = this.resolvedOverrides[overrideIndex];\n    if (!overrideTarget) return;\n    var remainingValues = {};\n\n    for (var key in this.baseTarget) {\n      if (overrideTarget[key] !== undefined) {\n        remainingValues[key] = this.baseTarget[key];\n      }\n    }\n\n    this.onStart();\n    this.animate(remainingValues).then(function () {\n      return _this.onComplete();\n    });\n  };\n  /**\n   * Apply a target/variant without any animation\n   */\n\n\n  VisualElementAnimationControls.prototype.apply = function (definition) {\n    if (Array.isArray(definition)) {\n      return this.applyVariantLabels(definition);\n    } else if (typeof definition === \"string\") {\n      return this.applyVariantLabels([definition]);\n    } else {\n      this.setValues(definition);\n    }\n  };\n  /**\n   * Apply variant labels without animation\n   */\n\n\n  VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n    var _this = this;\n\n    var isActive = new Set();\n\n    var reversedList = __spreadArrays(variantLabelList).reverse();\n\n    reversedList.forEach(function (key) {\n      var _a = _this.resolveVariant(_this.variants[key]),\n          target = _a.target,\n          transitionEnd = _a.transitionEnd;\n\n      if (transitionEnd) {\n        _this.setValues(transitionEnd, {\n          isActive: isActive\n        });\n      }\n\n      if (target) {\n        _this.setValues(target, {\n          isActive: isActive\n        });\n      }\n\n      if (_this.children && _this.children.size) {\n        _this.children.forEach(function (child) {\n          return child.applyVariantLabels(variantLabelList);\n        });\n      }\n    });\n  };\n\n  VisualElementAnimationControls.prototype.start = function (definition, opts) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.priority) {\n      this.activeOverrides.add(opts.priority);\n    }\n\n    this.resetIsAnimating(opts.priority);\n    var animation;\n\n    if (isVariantLabels(definition)) {\n      animation = this.animateVariantLabels(definition, opts);\n    } else if (typeof definition === \"string\") {\n      animation = this.animateVariant(definition, opts);\n    } else {\n      animation = this.animate(definition, opts);\n    }\n\n    this.onStart();\n    return animation.then(function () {\n      return _this.onComplete();\n    });\n  };\n\n  VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.delay,\n        delay = _c === void 0 ? 0 : _c,\n        _d = _b.priority,\n        priority = _d === void 0 ? 0 : _d,\n        transitionOverride = _b.transitionOverride;\n\n    var _e = this.resolveVariant(animationDefinition),\n        target = _e.target,\n        transition = _e.transition,\n        transitionEnd = _e.transitionEnd;\n\n    if (transitionOverride) {\n      transition = transitionOverride;\n    }\n\n    if (!target) return Promise.resolve();\n    target = this.transformValues(target);\n\n    if (transitionEnd) {\n      transitionEnd = this.transformValues(transitionEnd);\n    }\n\n    this.checkForNewValues(target);\n    var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n\n    if (this.makeTargetAnimatable) {\n      var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n      target = animatable.target;\n      transitionEnd = animatable.transitionEnd;\n    }\n\n    if (priority) {\n      this.resolvedOverrides[priority] = target;\n    }\n\n    this.checkForNewValues(target);\n    var animations = [];\n\n    for (var key in target) {\n      var value = this.visualElement.getValue(key);\n      if (!value || !target || target[key] === undefined) continue;\n      var valueTarget = target[key];\n\n      if (!priority) {\n        this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n      }\n\n      if (this.isAnimating.has(key)) continue;\n      this.isAnimating.add(key);\n      animations.push(startAnimation(key, value, valueTarget, __assign({\n        delay: delay\n      }, transition)));\n    }\n\n    var allAnimations = Promise.all(animations);\n    return transitionEnd ? allAnimations.then(function () {\n      _this.setValues(transitionEnd, {\n        priority: priority\n      });\n    }) : allAnimations;\n  };\n\n  VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n    var _this = this;\n\n    var animations = __spreadArrays(variantLabels).reverse().map(function (label) {\n      return _this.animateVariant(label, opts);\n    });\n\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n    var _this = this;\n\n    var when = false;\n    var delayChildren = 0;\n    var staggerChildren = 0;\n    var staggerDirection = 1;\n    var priority = opts && opts.priority || 0;\n    var variant = this.variants[variantLabel];\n    var getAnimations = variant ? function () {\n      return _this.animate(variant, opts);\n    } : function () {\n      return Promise.resolve();\n    };\n    var getChildrenAnimations = this.children ? function () {\n      return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n    } : function () {\n      return Promise.resolve();\n    };\n\n    if (variant && this.children) {\n      var transition = this.resolveVariant(variant).transition;\n\n      if (transition) {\n        when = transition.when || when;\n        delayChildren = transition.delayChildren || delayChildren;\n        staggerChildren = transition.staggerChildren || staggerChildren;\n        staggerDirection = transition.staggerDirection || staggerDirection;\n      }\n    }\n\n    if (when) {\n      var _a = when === \"beforeChildren\" ? [getAnimations, getChildrenAnimations] : [getChildrenAnimations, getAnimations],\n          first = _a[0],\n          last = _a[1];\n\n      return first().then(last);\n    } else {\n      return Promise.all([getAnimations(), getChildrenAnimations()]);\n    }\n  };\n\n  VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n    if (delayChildren === void 0) {\n      delayChildren = 0;\n    }\n\n    if (staggerChildren === void 0) {\n      staggerChildren = 0;\n    }\n\n    if (staggerDirection === void 0) {\n      staggerDirection = 1;\n    }\n\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (!this.children) {\n      return Promise.resolve();\n    }\n\n    var animations = [];\n    var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n      return i * staggerChildren;\n    } : function (i) {\n      return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(this.children).forEach(function (childControls, i) {\n      var animation = childControls.animateVariant(variantLabel, {\n        priority: priority,\n        delay: delayChildren + generateStaggerDuration(i)\n      });\n      animations.push(animation);\n    });\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.onStart = function () {\n    var onAnimationStart = this.props.onAnimationStart;\n    onAnimationStart && onAnimationStart();\n  };\n\n  VisualElementAnimationControls.prototype.onComplete = function () {\n    var onAnimationComplete = this.props.onAnimationComplete;\n    onAnimationComplete && onAnimationComplete();\n  };\n\n  VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n    var numOverrides = this.overrides.length;\n\n    for (var i = priority + 1; i < numOverrides; i++) {\n      var resolvedOverride = this.resolvedOverrides[i];\n\n      if (resolvedOverride) {\n        for (var key in resolvedOverride) {\n          this.isAnimating.add(key);\n        }\n      }\n    }\n  };\n\n  VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.isAnimating.clear(); // If this isn't the highest priority gesture, block the animation\n    // of anything that's currently being animated\n\n    if (priority < this.getHighestPriority()) {\n      this.checkOverrideIsAnimating(priority);\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.resetIsAnimating(priority);\n      });\n    }\n  };\n\n  VisualElementAnimationControls.prototype.stop = function () {\n    this.visualElement.forEachValue(function (value) {\n      return value.stop();\n    });\n  };\n  /**\n   * Add the controls of a child component.\n   * @param controls -\n   */\n\n\n  VisualElementAnimationControls.prototype.addChild = function (controls) {\n    if (!this.children) {\n      this.children = new Set();\n    }\n\n    this.children.add(controls); // We set child overrides when `setOverride` is called, but also have to do it here\n    // as the first time `setOverride` is called all the children might not have been added yet.\n\n    this.overrides.forEach(function (override, i) {\n      override && controls.setOverride(override, i);\n    });\n  };\n\n  VisualElementAnimationControls.prototype.removeChild = function (controls) {\n    if (!this.children) {\n      return;\n    }\n\n    this.children.delete(controls);\n  };\n\n  VisualElementAnimationControls.prototype.resetChildren = function () {\n    if (this.children) this.children.clear();\n  };\n\n  return VisualElementAnimationControls;\n}();\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n/**\n * Creates an imperative set of controls to trigger animations.\n *\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\n *\n * @internal\n */\n\n\nfunction useVisualElementAnimation(visualElement, props, config) {\n  var subscribeToParentControls = checkShouldInheritVariant(props);\n  var variants = props.variants,\n      transition = props.transition;\n  var parentControls = useContext(MotionContext).controls;\n  var presenceContext = useContext(PresenceContext);\n  var controls = useConstant(function () {\n    return new VisualElementAnimationControls(visualElement, config);\n  }); // Reset and resubscribe children every render to ensure stagger order is correct\n\n  if (!presenceContext || presenceContext.isPresent) {\n    controls.resetChildren();\n    controls.setProps(props);\n    controls.setVariants(variants);\n    controls.setDefaultTransition(transition);\n  } // We have to subscribe to the parent controls within a useEffect rather than during render,\n  // as\n\n\n  useEffect(function () {\n    if (subscribeToParentControls && parentControls) {\n      parentControls.addChild(controls);\n    }\n  });\n  useEffect(function () {\n    return function () {\n      // Remove reference to onAnimationComplete from controls. All the MotionValues\n      // are unsubscribed from this component separately. We let animations run out\n      // as they might be animating other components.\n      var onAnimationComplete = props.onAnimationComplete,\n          unmountProps = __rest(props, [\"onAnimationComplete\"]);\n\n      controls.setProps(unmountProps);\n      parentControls && parentControls.removeChild(controls);\n    };\n  }, []);\n  return controls;\n}\n/**\n * @internal\n */\n\n\nvar MotionPluginContext = createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  features: []\n});\n/**\n * @remarks For now I think this should remain a private API for our own use\n * until we can figure out a nicer way of allowing people to add these\n *\n * @internal\n */\n\nfunction MotionPlugins(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  var pluginContext = useContext(MotionPluginContext);\n  var value = useRef(__assign({}, pluginContext)).current; // Mutative to prevent triggering rerenders in all listening\n  // components every time this component renders\n\n  for (var key in props) {\n    value[key] = props[key];\n  }\n\n  return createElement(MotionPluginContext.Provider, {\n    value: value\n  }, children);\n}\n\nvar AnimatePropType;\n\n(function (AnimatePropType) {\n  AnimatePropType[\"Target\"] = \"Target\";\n  AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n  AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nvar makeRenderlessComponent = function (hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nfunction shallowCompare(next, prev) {\n  if (prev === null) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n\nvar hasUpdated = function (prev, next) {\n  return next !== undefined && (Array.isArray(prev) && Array.isArray(next) ? !shallowCompare(next, prev) : prev !== next);\n};\n\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n  if (mergeTransitionEnd === void 0) {\n    mergeTransitionEnd = false;\n  }\n\n  var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n  return mergeTransitionEnd ? __assign(__assign({}, target), transitionEnd) : target;\n}\n/**\n * Handle the `animate` prop when its an object of values, ie:\n *\n * ```jsx\n * <motion.div animate={{ opacity: 1 }} />\n * ```\n *\n * @internalremarks\n * It might be worth consolidating this with `use-variants`\n *\n * ```jsx\n * <motion.div animate=\"visible\" />\n * ```\n *\n * @param target\n * @param controls\n * @param values\n * @param transition\n *\n * @internal\n */\n\n\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n  var isInitialRender = useRef(true);\n  var prevValues = useRef(null);\n\n  if (!prevValues.current) {\n    prevValues.current = targetWithoutTransition(targetAndTransition, true);\n  }\n\n  useEffect(function () {\n    var targetToAnimate = {}; // These are the values we're actually animating\n\n    var animatingTarget = targetWithoutTransition(targetAndTransition); // This is the target as it'll be once transitionEnd values are applied\n\n    var finalTarget = targetWithoutTransition(targetAndTransition, true); // Detect which values have changed between renders\n\n    for (var key in animatingTarget) {\n      // This value should animate on mount if this value doesn't already exist (wasn't\n      // defined in `style` or `initial`) or if it does exist and it's already changed.\n      var shouldAnimateOnMount = isInitialRender.current && (!visualElement.hasValue(key) || visualElement.getValue(key).get() !== finalTarget[key]); // If this value has updated between renders or it's we're animating this value on mount,\n      // add it to the animate target.\n\n      var isValidValue = finalTarget[key] !== null;\n      var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n\n      if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n        targetToAnimate[key] = animatingTarget[key];\n      }\n    }\n\n    isInitialRender.current = false;\n    prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n\n    if (Object.keys(targetToAnimate).length) {\n      controls.start(__assign(__assign({}, targetToAnimate), {\n        transition: targetAndTransition.transition || defaultTransition,\n        transitionEnd: targetAndTransition.transitionEnd\n      }));\n    }\n  }, [targetAndTransition]);\n}\n\nvar labelsToArray = function (label) {\n  if (!label) {\n    return [];\n  }\n\n  if (Array.isArray(label)) {\n    return label;\n  }\n\n  return [label];\n};\n\nvar resolveVariantLabels = function (variant) {\n  var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n  return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\n * When values in this array change, React re-runs the dependency. However if the array\n * contains a variable number of items, React throws an error.\n */\n\n\nvar asDependencyList = function (list) {\n  return [list.join(\",\")];\n};\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\n  return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\n * Handle variants and the `animate` prop when its set as variant labels.\n *\n * @param initial - Initial variant(s)\n * @param animate - Variant(s) to animate to\n * @param inherit - `true` is inheriting animations from parent\n * @param controls - Animation controls\n *\n * @internal\n */\n\n\nfunction useVariants(initial, animate, inherit, controls) {\n  var targetVariants = resolveVariantLabels(animate);\n  var context = useContext(MotionContext);\n  var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n  var hasMounted = useRef(false);\n  useEffect(function () {\n    var shouldAnimate = false;\n\n    if (inherit) {\n      // If we're inheriting variant changes and the parent has already\n      // mounted when this component loads, we need to manually trigger\n      // this animation.\n      shouldAnimate = !!parentAlreadyMounted;\n      targetVariants = resolveVariantLabels(context.animate);\n    } else {\n      shouldAnimate = hasMounted.current || hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n    }\n\n    shouldAnimate && controls.start(targetVariants);\n    hasMounted.current = true;\n  }, asDependencyList(targetVariants));\n}\n/**\n * `useAnimationGroupSubscription` allows a component to subscribe to an\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\n *\n * @param animation\n * @param controls\n *\n * @internal\n */\n\n\nfunction useAnimationGroupSubscription(animation, controls) {\n  var unsubscribe = useMemo(function () {\n    return animation.subscribe(controls);\n  }, [animation]);\n  useEffect(function () {\n    return function () {\n      unsubscribe && unsubscribe();\n    };\n  }, [unsubscribe]);\n}\n\nvar _a, _b;\n\nvar AnimatePropComponents = (_a = {}, _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls,\n      visualElement = _a.visualElement,\n      transition = _a.transition;\n  return useAnimateProp(animate, controls, visualElement, transition);\n}), _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b,\n      controls = _a.controls,\n      initial = _a.initial;\n  return useVariants(initial, animate, inherit, controls);\n}), _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls;\n  return useAnimationGroupSubscription(animate, controls);\n}), _a);\n\nvar isVariantLabel$1 = function (prop) {\n  return Array.isArray(prop) || typeof prop === \"string\";\n};\n\nvar isAnimationSubscription = function (_a) {\n  var animate = _a.animate;\n  return animate instanceof AnimationControls;\n};\n\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {}, _b[AnimatePropType.Target] = function (props) {\n  return props.animate !== undefined && !isVariantLabel$1(props.animate) && !isAnimationSubscription(props);\n}, _b[AnimatePropType.VariantLabel] = function (props) {\n  return props.variants !== undefined || animationProps.some(function (key) {\n    return typeof props[key] === \"string\";\n  });\n}, _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription, _b);\n\nvar getAnimationComponent = function (props) {\n  var animatePropType = undefined;\n\n  for (var key in AnimatePropType) {\n    if (animatePropTypeTests[key](props)) {\n      animatePropType = key;\n    }\n  }\n\n  return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n/**\n * Load features via renderless components based on the provided MotionProps\n */\n\n\nfunction useFeatures(defaultFeatures, isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n  var plugins = useContext(MotionPluginContext); // If this is a static component, or we're rendering on the server, we don't load\n  // any feature components\n\n  if (isStatic || typeof window === \"undefined\") return null;\n\n  var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n\n  var numFeatures = allFeatures.length;\n  var features = []; // TODO: Consolidate Animation feature loading strategy with other functionality components\n\n  var Animation = getAnimationComponent(props);\n\n  if (Animation) {\n    features.push(createElement(Animation, {\n      key: \"animation\",\n      initial: props.initial,\n      animate: props.animate,\n      variants: props.variants,\n      transition: props.transition,\n      controls: controls,\n      inherit: shouldInheritVariant,\n      visualElement: visualElement\n    }));\n  } // Decide which features we should render and add them to the returned array\n\n\n  for (var i = 0; i < numFeatures; i++) {\n    var _a = allFeatures[i],\n        shouldRender = _a.shouldRender,\n        key = _a.key,\n        Component = _a.Component;\n\n    if (shouldRender(props, parentContext)) {\n      features.push(createElement(Component, __assign({\n        key: key\n      }, props, {\n        localContext: context,\n        parentContext: parentContext,\n        visualElement: visualElement,\n        controls: controls\n      })));\n    }\n  }\n\n  return features;\n}\n\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n\nvar VisibilityAction;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n/**\n * Default handlers for batching VisualElements\n */\n\n\nvar defaultHandler = {\n  measureLayout: function (child) {\n    return child.measureLayout();\n  },\n  layoutReady: function (child) {\n    return child.layoutReady();\n  }\n};\n/**\n * Sort VisualElements by tree depth, so we process the highest elements first.\n */\n\nvar sortByDepth = function (a, b) {\n  return a.depth - b.depth;\n};\n/**\n * Create a batcher to process VisualElements\n */\n\n\nfunction createBatcher() {\n  var queue = new Set();\n\n  var add = function (child) {\n    return queue.add(child);\n  };\n\n  var flush = function (_a) {\n    var _b = _a === void 0 ? defaultHandler : _a,\n        measureLayout = _b.measureLayout,\n        layoutReady = _b.layoutReady;\n\n    var order = Array.from(queue).sort(sortByDepth);\n    /**\n     * Write: Reset any transforms on children elements so we can read their actual layout\n     */\n\n    order.forEach(function (child) {\n      return child.resetTransform();\n    });\n    /**\n     * Read: Measure the actual layout\n     */\n\n    order.forEach(measureLayout);\n    /**\n     * Write: Notify the VisualElements they're ready for further write operations.\n     */\n\n    order.forEach(layoutReady);\n    /**\n     * After all children have started animating, ensure any Entering components are set to Present.\n     * If we add deferred animations (set up all animations and then start them in two loops) this\n     * could be moved to the start loop. But it needs to happen after all the animations configs\n     * are generated in AnimateSharedLayout as this relies on presence data\n     */\n\n    order.forEach(function (child) {\n      if (child.isPresent) child.presence = Presence.Present;\n    });\n    queue.clear();\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n}\n\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n\nvar SharedLayoutContext = createContext(createBatcher());\n\nfunction useUnmountEffect(callback) {\n  return useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n\nfunction useSnapshotOnUnmount(visualElement) {\n  var syncLayout = useContext(SharedLayoutContext);\n  useUnmountEffect(function () {\n    if (isSharedLayout(syncLayout)) syncLayout.remove(visualElement);\n  });\n}\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\n\nfunction createMotionComponent(Component, _a) {\n  var defaultFeatures = _a.defaultFeatures,\n      useVisualElement = _a.useVisualElement,\n      render = _a.render,\n      animationControlsConfig = _a.animationControlsConfig;\n\n  function MotionComponent(props, externalRef) {\n    var parentContext = useContext(MotionContext);\n    var shouldInheritVariant = checkShouldInheritVariant(props);\n    /**\n     * If a component isStatic, we only visually update it as a\n     * result of a React re-render, rather than any interactions or animations.\n     * If this component or any ancestor isStatic, we disable hardware acceleration\n     * and don't load any additional functionality.\n     */\n\n    var isStatic = parentContext.static || props.static || false;\n    /**\n     * Create a VisualElement for this component. A VisualElement provides a common\n     * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n     * providing a way of rendering to these APIs outside of the React render loop\n     * for more performant animations and interactions\n     */\n\n    var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n    /**\n     * Scrape MotionValues from props and add/remove them to/from\n     * the VisualElement as necessary.\n     */\n\n    useMotionValues(visualElement, props);\n    /**\n     * Create animation controls for the VisualElement. It might be\n     * interesting to try and combine this with VisualElement itself in a further refactor.\n     */\n\n    var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n    /**\n     * Build the MotionContext to pass on to the next `motion` component.\n     */\n\n    var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n    /**\n     * Load features as renderless components unless the component isStatic\n     */\n\n    var features = useFeatures(defaultFeatures, isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n    var component = render(Component, props, visualElement);\n    /**\n     *\n     */\n\n    useSnapshotOnUnmount(visualElement); // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n    // all plugins and features has to execute.\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, component), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function () {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function () {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\n\nif (isBrowser) {\n  document.addEventListener(\"touchmove\", function (event) {\n    if (isViewportScrollBlocked) {\n      event.preventDefault();\n    }\n  }, {\n    passive: false\n  });\n}\n\nvar blockViewportScroll = function () {\n  return isViewportScrollBlocked = true;\n};\n\nvar unblockViewportScroll = function () {\n  return isViewportScrollBlocked = false;\n};\n\nfunction addDomEvent(target, eventName, handler, options) {\n  if (!handler) return;\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  if (!eventHandler) return undefined;\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\n\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\n\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  if (!handler) return;\n\n  var listener = function (event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\"; // We check for event support via functions in case they've been mocked by a testing suite.\n\nvar supportsPointerEvents = function () {\n  return isBrowser$1 && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function () {\n  return isBrowser$1 && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function () {\n  return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n/** @public */\n\n\nvar Point;\n\n(function (Point) {\n  /** @beta */\n  Point.subtract = function (a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  };\n  /** @beta */\n\n\n  Point.relativeTo = function (idOrElem) {\n    var elem;\n\n    var getElem = function () {\n      // Caching element here could be leaky because of React lifecycle\n      if (elem !== undefined) return elem;\n\n      if (typeof idOrElem === \"string\") {\n        elem = document.getElementById(idOrElem);\n      } else {\n        elem = idOrElem;\n      }\n\n      return elem;\n    };\n\n    return function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var localElem = getElem();\n      if (!localElem) return undefined;\n      var rect = localElem.getBoundingClientRect();\n      return {\n        x: x - rect.left - window.scrollX,\n        y: y - rect.top - window.scrollY\n      };\n    };\n  };\n})(Point || (Point = {}));\n/**\n * @internal\n */\n\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n    /**\n     * @internal\n     */\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) {\n      return _this.handlePointerMove(event, info);\n    });\n    var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return _this.handlePointerUp(event, info);\n    });\n\n    this.removeListeners = function () {\n      removeOnPointerMove && removeOnPointerMove();\n      removeOnPointerUp && removeOnPointerUp();\n    };\n  }\n\n  PanSession.prototype.handlePointerMove = function (event, info) {\n    this.lastMoveEvent = event;\n    this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.handlePointerUp(event, info);\n      return;\n    } // Throttle mouse move event to once per frame\n\n\n    sync.update(this.updatePoint, true);\n  };\n\n  PanSession.prototype.handlePointerUp = function (event, info) {\n    this.end();\n    var onEnd = this.handlers.onEnd;\n    if (!onEnd) return;\n    var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n    onEnd && onEnd(event, panInfo);\n  };\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n    unblockViewportScroll();\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: Point.subtract(point, lastDevicePoint(history)),\n    offset: Point.subtract(point, startDevicePoint(history)),\n    velocity: getVelocity$1(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity$1(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\n\n\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\n\n\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured axis.\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  var constraints = {};\n  var length = axis.max - axis.min;\n\n  if (min !== undefined) {\n    constraints.min = axis.min + min;\n  }\n\n  if (max !== undefined) {\n    constraints.max = Math.max(axis.min + max - length, axis.min + max);\n  }\n\n  return constraints;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = [max, min], min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\n\n\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n\nvar lastPointerEvent;\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n\n    this.constraints = false;\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n\n    this.props = {};\n    /**\n     * Track the initial position of the cursor relative to the dragging element\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\n     *\n     * @internal\n     */\n\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    }; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Instantiate a PanSession for the drag gesture\n   *\n   * @public\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.snapToCursor,\n        snapToCursor = _c === void 0 ? false : _c,\n        cursorProgress = _b.cursorProgress;\n    /**\n     * If this drag session has been manually triggered by the user, it might be from an event\n     * outside the draggable element. If snapToCursor is set to true, we need to measure the position\n     * of the element and snap it to the cursor.\n     */\n\n\n    snapToCursor && this.snapToCursor(originEvent);\n\n    var onSessionStart = function () {\n      // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n      // which has come out of the difficulty in us being able to do this once a scroll gesture\n      // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n      // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n      // trigger this once we've got a scroll direction determined. This approach sort-of worked\n      // but if the component was dragged too far in a single frame page scrolling would initiate.\n      blockViewportScroll(); // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n      _this.stopMotion();\n    };\n\n    var onStart = function (event, info) {\n      var _a, _b; // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n\n      var _c = _this.props,\n          drag = _c.drag,\n          dragPropagation = _c.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!_this.openGlobalLock) return;\n      }\n      /**\n       * Record the progress of the mouse within the draggable element on each axis.\n       * onPan, we're going to use this to calculate a new bounding box for the element to\n       * project into. This will ensure that even if the DOM element moves via a relayout, it'll\n       * stick to the correct place under the pointer.\n       */\n\n\n      _this.prepareBoundingBox();\n\n      _this.visualElement.lockTargetBox();\n      /**\n       * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\n       * relative to the element's layout, or a ref to another element. Both need converting to\n       * viewport coordinates.\n       */\n\n\n      _this.resolveDragConstraints();\n      /**\n       * When dragging starts, we want to find where the cursor is relative to the bounding box\n       * of the element. Every frame, we calculate a new bounding box using this relative position\n       * and let the visualElement renderer figure out how to reproject the element into this bounding\n       * box.\n       *\n       * By doing it this way, rather than applying an x/y transform directly to the element,\n       * we can ensure the component always visually sticks to the cursor as we'd expect, even\n       * if the DOM element itself changes layout as a result of React updates the user might\n       * make based on the drag position.\n       */\n\n\n      var point = getViewportPointFromEvent(event).point;\n      eachAxis(function (axis) {\n        var _a = _this.visualElement.targetBox[axis],\n            min = _a.min,\n            max = _a.max;\n        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);\n      }); // Set current drag status\n\n      _this.isDragging = true;\n      _this.currentDirection = null; // Fire onDragStart event\n\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n    };\n\n    var onMove = function (event, info) {\n      var _a, _b, _c, _d;\n\n      var _e = _this.props,\n          dragPropagation = _e.dragPropagation,\n          dragDirectionLock = _e.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      _this.updateAxis(\"x\", event);\n\n      _this.updateAxis(\"y\", event); // Fire onDrag event\n\n\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info); // Update the last pointer event\n\n      lastPointerEvent = event;\n    };\n\n    var onEnd = function (event, info) {\n      return _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onEnd: onEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n  /**\n   * Ensure the component's layout and target bounding boxes are up-to-date.\n   */\n\n\n  VisualElementDragControls.prototype.prepareBoundingBox = function () {\n    var element = this.visualElement.getInstance();\n    var transform = element.style.transform;\n    this.visualElement.resetTransform();\n    this.visualElement.measureLayout();\n    element.style.transform = transform;\n    this.visualElement.refreshTargetBox();\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var dragConstraints = this.props.dragConstraints;\n\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(this.visualElement.box, dragConstraints) : calcRelativeConstraints(this.visualElement.box, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n  };\n\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    unblockViewportScroll();\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a;\n\n    this.visualElement.unlockTargetBox();\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var _b = this.props,\n        dragMomentum = _b.dragMomentum,\n        dragElastic = _b.dragElastic,\n        onDragEnd = _b.onDragEnd;\n\n    if (dragMomentum || dragElastic) {\n      var velocity = info.velocity;\n      this.animateDragEnd(velocity);\n    }\n\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (event) {\n    this.prepareBoundingBox();\n    this.cursorProgress.x = 0.5;\n    this.cursorProgress.y = 0.5;\n    this.updateAxis(\"x\", event);\n    this.updateAxis(\"y\", event);\n  };\n  /**\n   * Update the specified axis with the latest pointer information.\n   */\n\n\n  VisualElementDragControls.prototype.updateAxis = function (axis, event) {\n    var _a;\n\n    var _b = this.props,\n        drag = _b.drag,\n        dragElastic = _b.dragElastic; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection)) return; // Get the actual layout bounding box of the element\n\n    var axisLayout = this.visualElement.box[axis]; // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n\n    var axisLength = axisLayout.max - axisLayout.min; // Get the initial progress that the pointer sat on this axis on gesture start.\n\n    var axisProgress = this.cursorProgress[axis];\n    var point = getViewportPointFromEvent(event).point; // Calculate a new min point based on the latest pointer position, constraints and elastic\n\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic); // Update the axis viewport target with this new min and the length\n\n    this.visualElement.setAxisTarget(axis, min, min + axisLength);\n  };\n\n  VisualElementDragControls.prototype.updateProps = function (_a) {\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? 0.35 : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = __assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition;\n    var momentumAnimations = eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = _this.constraints ? _this.constraints[axis] : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n\n      var inertia = __assign(__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition); // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n\n      return _this.visualElement.startLayoutAxisAnimation(axis, inertia);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    this.visualElement.stopLayoutAnimation();\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return; // Stop any current animations as there can be some visual glitching if we resize mid animation\n\n    this.stopMotion(); // Record the relative progress of the targetBox relative to the constraintsBox\n\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);\n    });\n    /**\n     * For each axis, calculate the current progress of the layout axis within the constraints.\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\n     * proportionally within the constraints.\n     */\n\n    this.prepareBoundingBox();\n    this.resolveDragConstraints();\n    eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, null)) return; // Calculate the position of the targetBox relative to the constraintsBox using the\n      // previously calculated progress\n\n      var _a = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]),\n          min = _a.min,\n          max = _a.max;\n\n      _this.visualElement.setAxisTarget(axis, min, max);\n    });\n  };\n\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n\n    var element = visualElement.getInstance();\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\n     * Ensure drag constraints are resolved correctly relative to the dragging element\n     * whenever its layout changes.\n     */\n\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) _this.resolveDragConstraints();\n    });\n    /**\n     * If the previous component with this same layoutId was dragging at the time\n     * it was unmounted, we want to continue the same gesture on this component.\n     */\n\n    var prevSnapshot = visualElement.prevSnapshot;\n    (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) && this.start(lastPointerEvent, {\n      cursorProgress: prevSnapshot.cursorProgress\n    });\n    /**\n     * Return a function that will teardown the drag gesture\n     */\n\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}();\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\n\n\nfunction useDrag(props, visualElement) {\n  var groupDragControls = props.dragControls;\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.updateProps(__assign(__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  })); // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n\n  useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]); // Mount the drag controls with the visualElement\n\n  useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n\nvar Drag = {\n  key: \"drag\",\n  shouldRender: function (props) {\n    return !!props.drag;\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    return useDrag(props, visualElement);\n  })\n};\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\n\nfunction usePanGesture(_a, ref) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = useRef(null);\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function (event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\n\n\nvar isNodeOrChild = function (parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\n\nvar getGesturePriority = function (gesture) {\n  return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\n * @param handlers -\n * @internal\n */\n\nfunction useTapGesture(_a, ref) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      controls = _a.controls;\n  var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isTapping = useRef(false);\n  var cancelPointerEventListener = useRef(null);\n\n  function removePointerUp() {\n    cancelPointerEventListener.current && cancelPointerEventListener.current();\n    cancelPointerEventListener.current = null;\n  }\n\n  if (whileTap && controls) {\n    controls.setOverride(whileTap, tapGesturePriority);\n  } // We load this event handler into a ref so we can later refer to\n  // onPointerUp.current which will always have reference to the latest props\n\n\n  var onPointerUp = useRef(null);\n\n  onPointerUp.current = function (event, info) {\n    var element = ref.current;\n    removePointerUp();\n    if (!isTapping.current || !element) return;\n    isTapping.current = false;\n\n    if (controls && whileTap) {\n      controls.clearOverride(tapGesturePriority);\n    } // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n\n\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return;\n    openGestureLock();\n\n    if (!isNodeOrChild(element, event.target)) {\n      onTapCancel && onTapCancel(event, info);\n    } else {\n      onTap && onTap(event, info);\n    }\n  };\n\n  function onPointerDown(event, info) {\n    removePointerUp();\n    cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return onPointerUp.current(event, info);\n    });\n    var element = ref.current;\n    if (!element || isTapping.current) return;\n    isTapping.current = true;\n    onTapStart && onTapStart(event, info);\n\n    if (controls && whileTap) {\n      controls.startOverride(tapGesturePriority);\n    }\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\n\nvar filterTouch = function (listener) {\n  return function (event, info) {\n    if (isMouseEvent(event)) listener(event, info);\n  };\n};\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\n\n\nfunction useHoverGesture(_a, ref) {\n  var whileHover = _a.whileHover,\n      onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      controls = _a.controls;\n\n  if (whileHover && controls) {\n    controls.setOverride(whileHover, hoverPriority);\n  }\n\n  usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n    if (onHoverStart) onHoverStart(event, info);\n\n    if (whileHover && controls) {\n      controls.startOverride(hoverPriority);\n    }\n  }));\n  usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n    if (onHoverEnd) onHoverEnd(event, info);\n\n    if (whileHover && controls) {\n      controls.clearOverride(hoverPriority);\n    }\n  }));\n}\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\n\n\nfunction useGestures(props, ref) {\n  usePanGesture(props, ref);\n  useTapGesture(props, ref);\n  useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileTap\", \"whileHover\", \"onHoverStart\", \"onHoverEnd\"];\nvar Gestures = {\n  key: \"gestures\",\n  shouldRender: function (props) {\n    return gestureProps.some(function (key) {\n      return props.hasOwnProperty(key);\n    });\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    useGestures(props, visualElement);\n  })\n};\nvar Exit = {\n  key: \"exit\",\n  shouldRender: function (props) {\n    return !!props.exit && !checkShouldInheritVariant(props);\n  },\n  Component: makeRenderlessComponent(function (props) {\n    var animate = props.animate,\n        controls = props.controls,\n        exit = props.exit;\n\n    var _a = usePresence(),\n        isPresent = _a[0],\n        onExitComplete = _a[1];\n\n    var presenceContext = useContext(PresenceContext);\n    var isPlayingExitAnimation = useRef(false);\n    var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== undefined ? presenceContext.custom : props.custom;\n    useEffect(function () {\n      if (!isPresent) {\n        if (!isPlayingExitAnimation.current && exit) {\n          controls.setProps(__assign(__assign({}, props), {\n            custom: custom\n          }));\n          controls.start(exit).then(onExitComplete);\n        }\n\n        isPlayingExitAnimation.current = true;\n      } else if (isPlayingExitAnimation.current && animate && typeof animate !== \"boolean\" && !(animate instanceof AnimationControls)) {\n        controls.start(animate);\n      }\n\n      if (isPresent) {\n        isPlayingExitAnimation.current = false;\n      }\n    }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n  })\n};\n\nfunction tweenAxis(target, prev, next, p) {\n  target.min = mix(prev.min, next.min, p);\n  target.max = mix(prev.max, next.max, p);\n}\n\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  __extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.isTargetBoxLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          // If we're meant to show/hide the visualElement, do so\n          visibilityAction === VisibilityAction.Hide ? visualElement.hide() : visualElement.show();\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], config);\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setAxisTarget(axis, target[axis].min, target[axis].max);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.render();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n\n      return Promise.all(animations).then(function () {\n        var _a, _b;\n\n        (_a = config.onLayoutAnimationComplete) === null || _a === void 0 ? void 0 : _a.call(config);\n\n        if (visualElement.isPresent) {\n          visualElement.presence = Presence.Present;\n        } else {\n          (_b = config.onLayoutAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(config);\n\n          _this.safeToRemove();\n        }\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var visualElement = this.props.visualElement;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the HTMLVisualElement.startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        crossfadeOpacity = _d.crossfadeOpacity;\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.axisProgress[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * If this is a crossfade animation, create a function that updates both the opacity of this component\n     * and the one being crossfaded out.\n     */\n\n    var crossfade = crossfadeOpacity && this.createCrossfadeAnimation(crossfadeOpacity);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max); // If this is a crossfade animation, update both elements.\n\n      crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    return animation;\n  };\n\n  Animate.prototype.createCrossfadeAnimation = function (crossfadeOpacity) {\n    var visualElement = this.props.visualElement;\n    var opacity = visualElement.getValue(\"opacity\", 0);\n    return function (p) {\n      opacity.set(easeCrossfadeIn(mix(0, 1, p)));\n      crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));\n    };\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(Component);\n\nvar AnimateLayout = {\n  key: \"animate-layout\",\n  shouldRender: function (props) {\n    return !!props.layout || !!props.layoutId;\n  },\n  Component: function (props) {\n    var _a = usePresence(),\n        safeToRemove = _a[1];\n\n    return createElement(Animate, __assign({}, props, {\n      safeToRemove: safeToRemove\n    }));\n  }\n};\n\nfunction hasMoved(a, b) {\n  return hasAxisMoved(a.x, b.x) || hasAxisMoved(a.y, b.y);\n}\n\nfunction hasAxisMoved(a, b) {\n  return a.min !== b.min || a.max !== b.max;\n}\n\nvar defaultTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear$1);\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\n\nvar Measure =\n/** @class */\nfunction (_super) {\n  __extends(Measure, _super);\n\n  function Measure(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * If this component isn't the child of a SyncContext, make it responsible for flushing\n     * the layout batcher\n     */\n\n\n    var syncLayout = props.syncLayout;\n\n    if (!isSharedLayout(syncLayout)) {\n      _this.componentDidUpdate = function () {\n        return syncLayout.flush();\n      };\n    }\n\n    return _this;\n  }\n  /**\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\n   */\n\n\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n  };\n  /**\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n   * handle the snapshotting.\n   *\n   * If it is stand-alone component, add it to the batcher.\n   */\n\n\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      visualElement.snapshotBoundingBox();\n      syncLayout.add(visualElement);\n    }\n\n    return null;\n  };\n\n  Measure.prototype.componentDidUpdate = function () {};\n\n  Measure.prototype.render = function () {\n    return null;\n  };\n\n  return Measure;\n}(React__default.Component);\n\nvar MeasureLayout = {\n  key: \"measure-layout\",\n  shouldRender: function (props) {\n    return !!props.drag || !!props.layout || !!props.layoutId;\n  },\n  Component: function (props) {\n    var syncLayout = useContext(SharedLayoutContext);\n    return React__default.createElement(Measure, __assign({}, props, {\n      syncLayout: syncLayout\n    }));\n  }\n};\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion.custom(Component)\n * ```\n *\n * @public\n */\n\nfunction createMotionProxy(defaultFeatures) {\n  var config = {\n    defaultFeatures: defaultFeatures,\n    useVisualElement: useDomVisualElement,\n    render: render,\n    animationControlsConfig: {\n      makeTargetAnimatable: parseDomVariant\n    }\n  };\n\n  function custom(Component) {\n    return createMotionComponent(Component, config);\n  }\n\n  var componentCache = new Map();\n\n  function get(target, key) {\n    if (key === \"custom\") return target.custom;\n\n    if (!componentCache.has(key)) {\n      componentCache.set(key, createMotionComponent(key, config));\n    }\n\n    return componentCache.get(key);\n  }\n\n  return new Proxy({\n    custom: custom\n  }, {\n    get: get\n  });\n}\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\n\n\nvar motion = /*@__PURE__*/createMotionProxy([MeasureLayout, Drag, Gestures, Exit, AnimateLayout]);\n/**\n * @public\n */\n\nvar m = /*@__PURE__*/createMotionProxy([]);\n\nfunction useForceUpdate() {\n  var _a = useState(0),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  return useCallback(function () {\n    return setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function (_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      onExitComplete = _a.onExitComplete,\n      custom = _a.custom;\n  var presenceChildren = useConstant(newChildrenMap);\n  var context = {\n    id: useConstant(getPresenceId),\n    initial: initial,\n    isPresent: isPresent,\n    custom: custom,\n    onExitComplete: function (childId) {\n      presenceChildren.set(childId, true);\n      var allComplete = true;\n      presenceChildren.forEach(function (isComplete) {\n        if (!isComplete) allComplete = false;\n      });\n      allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    },\n    register: function (childId) {\n      presenceChildren.set(childId, false);\n      return function () {\n        return presenceChildren.delete(childId);\n      };\n    }\n  };\n  useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  return createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return createElement(Fragment, null, filteredChildren.map(function (child) {\n      return createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = __spreadArrays(filteredChildren); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return createElement(Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nfunction createSwitchAnimation(child, stack) {\n  if (stack && child !== stack.lead) {\n    return {\n      visibilityAction: VisibilityAction.Hide\n    };\n  } else if (stack && child.presence !== Presence.Entering && child === stack.lead && stack.lead !== stack.prevLead) {\n    return {\n      visibilityAction: VisibilityAction.Show\n    };\n  }\n\n  var originBox;\n  var targetBox;\n\n  if (child.presence === Presence.Entering) {\n    originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();\n  } else if (child.presence === Presence.Exiting) {\n    targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();\n  }\n\n  return {\n    originBox: originBox,\n    targetBox: targetBox\n  };\n}\n\nfunction createCrossfadeAnimation(child, stack) {\n  var _a, _b, _c;\n\n  var config = {};\n  var stackLead = stack && stack.lead;\n  var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;\n\n  if (stack && child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.originBox = stack.getFollowOrigin();\n    } else if (child.presence === Presence.Exiting) {\n      config.targetBox = stack.getFollowTarget();\n    }\n  } else if (stack && child === stack.follow) {\n    config.transition = stack.getLeadTransition();\n\n    if (stackLeadPresence === Presence.Entering) {\n      config.targetBox = stack.getLeadTarget();\n    } else if (stackLeadPresence === Presence.Exiting) {\n      config.originBox = stack.getLeadOrigin();\n    }\n  } // If neither the lead or follow component is the root child of AnimatePresence,\n  // don't handle crossfade animations\n\n\n  if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {\n    return config;\n  }\n\n  if (!stack || child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue(\"opacity\", 0);\n    }\n  } else if (stack && child === stack.follow) {\n    if (!stackLead || stackLeadPresence === Presence.Entering) ;else if (stackLeadPresence === Presence.Exiting) {\n      config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue(\"opacity\", 1);\n    }\n  } else {\n    config.visibilityAction = VisibilityAction.Hide;\n  }\n\n  return config;\n}\n/**\n * For each layout animation, we want to identify two components\n * within a stack that will serve as the \"lead\" and \"follow\" components.\n *\n * In the switch animation, the lead component performs the entire animation.\n * It uses the follow bounding box to animate out from and back to. The follow\n * component is hidden.\n *\n * In the crossfade animation, both the lead and follow components perform\n * the entire animation, animating from the follow origin bounding box to the lead\n * target bounding box.\n *\n * Generalising a stack as First In Last Out, *searching from the end* we can\n * generally consider the lead component to be:\n *  - If the last child is present, the last child\n *  - If the last child is exiting, the last *encountered* exiting component\n */\n\n\nfunction findLeadAndFollow(stack, _a) {\n  var prevLead = _a[0],\n      prevFollow = _a[1];\n  var lead = undefined;\n  var leadIndex = 0;\n  var follow = undefined; // Find the lead child first\n\n  var numInStack = stack.length;\n  var lastIsPresent = false;\n\n  for (var i = numInStack - 1; i >= 0; i--) {\n    var child = stack[i];\n    var isLastInStack = i === numInStack - 1;\n    if (isLastInStack) lastIsPresent = child.isPresent;\n\n    if (lastIsPresent) {\n      lead = child;\n    } else {\n      // If the child before this will be present, make this the\n      // lead.\n      var prev = stack[i - 1];\n      if (prev && prev.isPresent) lead = child;\n    }\n\n    if (lead) {\n      leadIndex = i;\n      break;\n    }\n  }\n\n  if (!lead) lead = stack[0]; // Find the follow child\n\n  follow = stack[leadIndex - 1]; // If the lead component is exiting, find the closest follow\n  // present component\n\n  if (lead) {\n    for (var i = leadIndex - 1; i >= 0; i--) {\n      var child = stack[i];\n\n      if (child.isPresent) {\n        follow = child;\n        break;\n      }\n    }\n  } // If the lead has changed and the previous lead still exists in the\n  // stack, set it to the previous lead. This allows us to differentiate between\n  // a, b, c(exit) -> a, b(exit), c(exit)\n  // and\n  // a, b(exit), c -> a, b(exit), c(exit)\n\n\n  if (lead !== prevLead && !lastIsPresent && follow === prevFollow && stack.find(function (stackChild) {\n    return stackChild === prevLead;\n  })) {\n    lead = prevLead;\n  }\n\n  return [lead, follow];\n}\n\nvar LayoutStack =\n/** @class */\nfunction () {\n  function LayoutStack() {\n    this.order = []; // Track whether we've ever had a child\n\n    this.hasChildren = false;\n  }\n\n  LayoutStack.prototype.add = function (child) {\n    var _a;\n\n    var layoutOrder = child.config.layoutOrder;\n\n    if (layoutOrder === undefined) {\n      this.order.push(child);\n    } else {\n      var index = this.order.findIndex(function (stackChild) {\n        return layoutOrder <= (stackChild.config.layoutOrder || 0);\n      });\n\n      if (index === -1) {\n        child.presence = this.hasChildren ? Presence.Entering : Presence.Present;\n        index = this.order.length;\n      }\n\n      this.order.splice(index, 0, child);\n    }\n    /**\n     *\n     */\n    // Load previous values from snapshot into this child\n    // TODO Neaten up\n    // TODO Double check when reimplementing move\n    // TODO Add isDragging status and\n\n\n    if (this.snapshot) {\n      child.prevSnapshot = this.snapshot; // TODO Remove in favour of above\n\n      child.prevViewportBox = this.snapshot.boundingBox;\n      var latest = this.snapshot.latestMotionValues;\n\n      for (var key in latest) {\n        if (!child.hasValue(key)) {\n          child.addValue(key, motionValue(latest[key]));\n        } else {\n          (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);\n        }\n      }\n    }\n\n    this.hasChildren = true;\n  };\n\n  LayoutStack.prototype.remove = function (child) {\n    var index = this.order.findIndex(function (stackChild) {\n      return child === stackChild;\n    });\n    if (index !== -1) this.order.splice(index, 1);\n  };\n\n  LayoutStack.prototype.updateLeadAndFollow = function () {\n    this.prevLead = this.lead;\n    this.prevFollow = this.follow;\n\n    var _a = findLeadAndFollow(this.order, [this.lead, this.follow]),\n        lead = _a[0],\n        follow = _a[1];\n\n    this.lead = lead;\n    this.follow = follow;\n  };\n\n  LayoutStack.prototype.updateSnapshot = function () {\n    if (!this.lead) return;\n    var snapshot = {\n      boundingBox: this.lead.prevViewportBox,\n      latestMotionValues: {}\n    };\n    this.lead.forEachValue(function (value, key) {\n      var latest = value.get();\n\n      if (!isTransformProp(latest)) {\n        snapshot.latestMotionValues[key] = latest;\n      }\n    });\n    var dragControls = elementDragControls.get(this.lead);\n\n    if (dragControls && dragControls.isDragging) {\n      snapshot.isDragging = true;\n      snapshot.cursorProgress = dragControls.cursorProgress;\n    }\n\n    this.snapshot = snapshot;\n  };\n\n  LayoutStack.prototype.isLeadPresent = function () {\n    var _a;\n\n    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n  };\n\n  LayoutStack.prototype.shouldStackAnimate = function () {\n    return true; // return this.lead && this.lead?.isPresent\n    //     ? this.lead?.props?._shouldAnimate === true\n    //     : this.follow && this.follow?.props._shouldAnimate === true\n  };\n\n  LayoutStack.prototype.getFollowOrigin = function () {\n    var _a; // This shouldAnimate check is quite specifically a fix for the optimisation made in Framer\n    // where components are kept in the tree ready to be re-used\n\n\n    return this.follow // && this.follow.shouldAnimate\n    ? this.follow.prevViewportBox : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;\n  };\n\n  LayoutStack.prototype.getFollowTarget = function () {\n    var _a;\n\n    return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadOrigin = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;\n  };\n\n  LayoutStack.prototype.getLeadTarget = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadTransition = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;\n  };\n\n  return LayoutStack;\n}();\n/**\n * @public\n */\n\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    this.updateStacks();\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    /**\n     * In every layoutId stack, nominate a component to lead the animation and another\n     * to follow\n     */\n\n    this.updateStacks();\n    /**\n     * Decide which animation to use between shared layoutId components\n     */\n\n    var createAnimation = type === \"crossfade\" ? createCrossfadeAnimation : createSwitchAnimation;\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      measureLayout: function (child) {\n        return child.measureLayout();\n      },\n      layoutReady: function (child) {\n        var layoutId = child.layoutId;\n        child.layoutReady(createAnimation(child, _this.getStack(layoutId)));\n      }\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.snapshot = undefined;\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Snapshot children\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotBoundingBox();\n    });\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (id) {\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  return AnimateSharedLayout;\n}(Component);\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\n\n\nfunction useMotionValue(initial) {\n  return useConstant(function () {\n    return motionValue(initial);\n  });\n}\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\nvar isCustomValueType = function (v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function (v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = interpolate(inputRange, outputRange, __assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function (v) {\n  return typeof v === \"function\";\n};\n\nfunction useTransform(parent, customTransform, to, options) {\n  var comparitor = isTransformer(customTransform) ? [parent] : [parent, customTransform.join(\",\"), to === null || to === void 0 ? void 0 : to.join(\",\")];\n  var transformer = useMemo(function () {\n    return isTransformer(customTransform) ? customTransform : transform(customTransform, to, options);\n  }, comparitor);\n  var initialValue = transformer(parent.get());\n  var value = useMotionValue(initialValue); // Handle subscription to parent\n\n  var unsubscribe = useRef();\n  useMemo(function () {\n    unsubscribe.current && unsubscribe.current();\n    unsubscribe.current = parent.onChange(function (v) {\n      return value.set(transformer(v));\n    }); // Manually set with the latest parent value in case we've re-parented\n\n    value.set(initialValue);\n  }, [parent, value, transformer]);\n  useUnmountEffect(function () {\n    return unsubscribe.current && unsubscribe.current();\n  });\n  return value;\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function (scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useContext(MotionContext).visualElement;\n  invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nfunction useOnChange(value, callback) {\n  useEffect(function () {\n    return isMotionValue(value) ? value.onChange(callback) : undefined;\n  }, [value]);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var activeSpringAnimation = useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  useMemo(function () {\n    return value.attach(function (v, set) {\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = spring(__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config)).start(set);\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function () {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function (element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useViewportScroll() {\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\n\n\nfunction useAnimation() {\n  var animationControls = useConstant(function () {\n    return new AnimationControls();\n  });\n  useEffect(function () {\n    animationControls.mount();\n    return function () {\n      return animationControls.unmount();\n    };\n  }, []);\n  return animationControls;\n}\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  } // TODO: After Framer X beta, remove this warning\n\n\n  warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n  var index = useRef(0);\n\n  var _a = useState(items[index.current]),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion = motionValue(null);\n\nif (typeof window !== \"undefined\") {\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function () {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n  return typeof isReducedMotion === \"boolean\" ? isReducedMotion : Boolean(prefersReduced);\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\n\n\nfunction useReducedMotion() {\n  var isReducedMotion = useContext(MotionContext).isReducedMotion;\n\n  var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useEffect(function () {\n    return prefersReducedMotion.onChange(function (v) {\n      setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n    });\n  }, [setShouldReduceMotion, isReducedMotion]);\n  return shouldReduceMotion;\n}\n/**\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\n * or disable device detection.\n *\n * @internal\n */\n\n\nfunction ReducedMotion(_a) {\n  var children = _a.children,\n      enabled = _a.enabled;\n  var context = useContext(MotionContext);\n  context = useMemo(function () {\n    return __assign(__assign({}, context), {\n      isReducedMotion: enabled\n    });\n  }, [enabled]);\n  return createElement(MotionContext.Provider, {\n    value: context\n  }, children);\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - A mouse/touch/pointer event.\n   * @param options - Options\n   *\n   * @public\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function () {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n/**\n * Uses the ref that is passed in, or creates a new one\n * @param external - External ref\n * @internal\n */\n\n\nfunction useExternalRef(externalRef) {\n  // We're conditionally calling `useRef` here which is sort of naughty as hooks\n  // shouldn't be called conditionally. However, Framer Motion will break if this\n  // condition changes anyway. It might be possible to use an invariant here to\n  // make it explicit, but I expect changing `ref` is not normal behaviour.\n  var ref = !externalRef || typeof externalRef === \"function\" ? useRef(null) : externalRef; // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n  // but `ref` types changing between renders would break Motion anyway. If we receive\n  // bug reports about this, we should track the provided ref and throw an invariant\n  // rather than move the conditional to inside the useEffect as this will be fired\n  // for every Frame component within Framer.\n\n  if (externalRef && typeof externalRef === \"function\") {\n    useEffect(function () {\n      externalRef(ref.current);\n      return function () {\n        return externalRef(null);\n      };\n    }, []);\n  }\n\n  return ref;\n}\n/**\n * This is just a very basic VisualElement, more of a hack to keep supporting useAnimatedState with\n * the latest APIs.\n */\n\n\nvar StateVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(StateVisualElement, _super);\n\n  function StateVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.initialState = {};\n    return _this;\n  }\n\n  StateVisualElement.prototype.updateLayoutDelta = function () {};\n\n  StateVisualElement.prototype.build = function () {};\n\n  StateVisualElement.prototype.clean = function () {};\n\n  StateVisualElement.prototype.getBoundingBox = function () {\n    return {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n  };\n\n  StateVisualElement.prototype.readNativeValue = function (key) {\n    return this.initialState[key] || 0;\n  };\n\n  StateVisualElement.prototype.render = function () {\n    this.build();\n  };\n\n  return StateVisualElement;\n}(VisualElement);\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\n\n\nfunction useAnimatedState(initialState) {\n  var _a = useState(initialState),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualElement = useConstant(function () {\n    return new StateVisualElement();\n  });\n  visualElement.updateConfig({\n    onUpdate: function (v) {\n      return setAnimationState(__assign({}, v));\n    }\n  });\n  visualElement.initialState = initialState;\n  var controls = useVisualElementAnimation(visualElement, {}, {});\n  useEffect(function () {\n    visualElement.mount({});\n    return function () {\n      return visualElement.unmount();\n    };\n  }, []);\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return controls.start(animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, VisualElementAnimationControls, addScaleCorrection, animationControls, createMotionComponent, isValidMotionProp, m, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };","map":{"version":3,"sources":["C:/Users/RaJpuT/Downloads/Compressed/firegram-final-files/firegram-final-files/node_modules/framer-motion/dist/framer-motion.es.js"],"names":["__assign","__spreadArrays","__rest","__extends","sync","getFrameData","cancelSync","velocityPerSecond","mix","clamp","distance","progress","linear","linear$1","circOut","interpolate","wrap","invariant","warning","number","color","complex","px","percent","degrees","vw","vh","scale","alpha","progressPercentage","action","delay","tween","spring","keyframes","keyframes$1","inertia","easingLookup","cubicBezier","React__default","useRef","createContext","useContext","useEffect","createElement","useMemo","forwardRef","Fragment","Component","useCallback","useState","cloneElement","Children","isValidElement","useLayoutEffect","isRefObject","ref","hasOwnProperty","isFloat","value","isNaN","parseFloat","MotionValue","init","_this","timeDelta","lastUpdated","canTrackVelocity","updateAndNotify","v","render","prev","current","updateSubscribers","forEach","notifySubscriber","renderSubscribers","_a","delta","timestamp","postRender","scheduleVelocityCheck","subscriber","velocityCheck","set","prototype","subscribeTo","subscriptions","subscription","updateSubscriber","add","delete","onChange","Set","clearListeners","clear","onRenderRequest","attach","passiveEffect","get","getPrevious","getVelocity","start","animation","stop","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","VisualElement","parent","children","latest","values","Map","valueSubscriptions","config","update","onUpdate","triggerRender","scheduleRender","element","mount","unmount","externalRef","rootParent","treePath","depth","subscribe","child","hasValue","key","has","addValue","removeValue","subscribeToValue","unsubscribe","getValue","defaultValue","undefined","forEachValue","callback","getInstance","updateConfig","setSingleStaticValue","setStaticValues","scheduleUpdateLayoutDelta","updateLayoutDelta","unsubscribeOnChange","unsubscribeOnRender","removeFromParent","_","noop","any","convertBoundingBoxToAxisBox","top","left","right","bottom","x","min","max","y","convertAxisBoxToBoundingBox","transformBoundingBox","transformPoint","topLeft","bottomRight","axisBox","copyAxisBox","box","zeroDelta","translate","origin","originPoint","auto","test","parse","int","transform","Math","round","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","translateX","translateY","translateZ","z","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","dimensionValueTypes","testValueType","type","findDimensionValueType","find","valueTypes","findValueType","getDefaultValueType","getValueAsType","axes","order","transformProps","operationKey","axesKey","push","sortTransformProps","a","b","indexOf","transformPropSet","isTransformProp","transformOriginProps","isTransformOriginProp","translateAlias","buildTransform","transformKeys","transformTemplate","transformIsDefault","enableHardwareAcceleration","allowTransformNone","transformString","transformHasZ","sort","numTransformKeys","length","i","trim","isCSSVariable","startsWith","pixelsToPercent","pixels","axis","correctBorderRadius","viewportBox","correctBoxShadow","_viewportBox","treeScale","shadow","template","createTransformer","xScale","yScale","averageScale","borderCorrectionDefinition","process","valueScaleCorrection","applyTo","boxShadow","addScaleCorrection","correctors","createDeltaTransform","buildHTMLStyles","style","vars","transformOrigin","isLayoutProjectionEnabled","deltaFinal","targetBox","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","bucket","corrected","num","resetAxis","originAxis","resetBox","originBox","scalePoint","point","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","final","transforms","scaleKey","originKey","xKeys","yKeys","applyBoxTransforms","finalBox","removePointDelta","removeAxisDelta","removeAxisTransforms","removeBoxTransforms","applyTreeDeltas","treeLength","clampProgress","isNear","target","maxDistance","calcTranslate","source","sourcePoint","targetPoint","calcOrigin","sourceLength","targetLength","updateAxisDelta","updateBoxDelta","updateTreeScale","parentTreeScale","parentDelta","eachAxis","handler","isKeyframesTarget","Array","isArray","underDampedSpring","stiffness","damping","restDelta","restSpeed","overDampedSpring","to","linearTween","ease","duration","defaultTransitions","getDefaultTransition","valueKey","transitionFactory","just","complete","easingDefinitionToFunction","definition","x1","y1","x2","y2","isEasingArray","isDurationAnimation","isAnimatable","secondsToMilliseconds","seconds","transitions","transitionOptionParser","opts","from","velocity","easings","map","isTransitionDefined","when","delayChildren","staggerChildren","staggerDirection","transition","Object","keys","getTransitionDefinition","transitionDefinition","valueTransitionDefinition","preprocessOptions","getAnimation","isOriginAnimatable","isTargetAnimatable","_b","actionFactory","repeatDelay","startAnimation","delay$1","activeAnimation","animationFactory","valueDelay","options","animate","getBoundingBox","transformPagePoint","getBoundingClientRect","HTMLVisualElement","_super","apply","arguments","defaultConfig","reactStyle","layoutUpdateListeners","hasViewportBoxUpdated","targetBoxFinal","stopLayoutAxisAnimation","isTargetBoxLocked","axisProgress","updateDeltas","fireUpdateLayoutDelta","call","clean","read","getComputedStyle","readNativeValue","defaultValueType","enableLayoutProjection","hide","isVisible","show","onLayoutUpdate","layoutReady","listener","prevViewportBox","getBoundingBoxWithoutTransforms","bbox","window","snapshotBoundingBox","measureLayout","boxCorrected","refreshTargetBox","lockTargetBox","unlockTargetBox","stopLayoutAnimation","resetTransform","setAxisTarget","targetAxis","startLayoutAxisAnimation","onViewportBoxUpdate","deltaTransform","build","visibility","assign","setProperty","useConstant","calcOrigin$1","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","progressToPixels","dashKeys","array","camelKeys","buildSVGPath","attrs","totalLength","spacing","useDashCase","pathLength","pathSpacing","unmeasured","buildSVGAttrs","totalPathLength","attrX","attrY","_c","pathOffset","camelCaseAttributes","CAMEL_CASE_PATTERN","REPLACE_TEMPLATE","camelToDash","str","replace","toLowerCase","SVGVisualElement","measure","getBBox","e","isPath","getTotalLength","getAttribute","setAttribute","tagName","svgElements","svgTagNames","isSVGComponent","PresenceContext","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","safeToRemove","useIsPresent","counter","incrementId","useDomVisualElement","props","isStatic","visualElement","DOMVisualElement","layoutId","validMotionProps","isValidMotionProp","isPropValid","emotionIsPropValid_1","require","filterProps","domProps","buildHTMLProps","drag","htmlProps","userSelect","draggable","buildSVGProps","forwardedProps","visualProps","isCSSVariable$1","cssVariableRegex","parseCSSVariable","match","exec","token","fallback","maxDepth","getVariableValue","resolved","getPropertyValue","resolveCSSVariables","transitionEnd","HTMLElement","positionalKeys","isPositionalKey","hasPositionalKey","some","setAndResetVelocity","isNumOrPxType","BoundingBoxDimension","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","convertedTarget","unitConversion","parseDomVariant","useInitialOrEveryRender","isInitialOnly","isInitialRender","AnimationControls","hasMounted","pendingAnimations","componentControls","setVariants","variants","controls","setDefaultTransition","defaultTransition","transitionOverride","animations_1","all","animationControls","MotionContext","static","isVariantLabel","isAnimationControls","useMotionContext","parentContext","initial","whileTap","whileHover","presenceContext","presenceId","isPresenceRoot","initialState","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","isReducedMotion","initialToApply","checkShouldInheritVariant","inherit","isMotionValue","useMotionValues","empty","isTransform","existsAsProp","existsAsStyle","propIsMotionValue","styleIsMotionValue","transformRemoved","motionValueRemoved","addMotionValues","transformValues","isStyle","foundMotionValue","reservedNames","motion","isCustomValue","Boolean","toValue","resolveFinalValueInKeyframes","isNumericalString","getCurrent","isTargetResolver","p","isVariantLabels","VisualElementAnimationControls","makeTargetAnimatable","baseTarget","overrides","resolvedOverrides","activeOverrides","setProps","setValues","isActive","priority","_d","resolveVariant","targetValue","checkForNewValues","newValueKeys","numNewValues","readValue","getAnimatableNone","variant","custom","getHighestPriority","setOverride","overrideIndex","startOverride","override","clearOverride","highest","resetIsAnimating","highestOverride","overrideTarget","remainingValues","onStart","onComplete","applyVariantLabels","variantLabelList","reversedList","reverse","animateVariantLabels","animateVariant","animationDefinition","_e","getOrigin","animatable","animations","valueTarget","allAnimations","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","first","last","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","addChild","removeChild","resetChildren","getOriginFromTransition","valueTransition","useVisualElementAnimation","subscribeToParentControls","parentControls","unmountProps","MotionPluginContext","features","MotionPlugins","pluginContext","Provider","AnimatePropType","makeRenderlessComponent","hook","shallowCompare","next","prevLength","hasUpdated","targetWithoutTransition","mergeTransitionEnd","useAnimateProp","targetAndTransition","prevValues","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","labelsToArray","resolveVariantLabels","unresolvedVariant","asDependencyList","list","join","hasVariantChanged","oldVariant","newVariant","useVariants","targetVariants","parentAlreadyMounted","shouldAnimate","useAnimationGroupSubscription","AnimatePropComponents","Target","VariantLabel","AnimationSubscription","isVariantLabel$1","prop","isAnimationSubscription","animationProps","animatePropTypeTests","getAnimationComponent","animatePropType","useFeatures","defaultFeatures","shouldInheritVariant","plugins","allFeatures","numFeatures","Animation","shouldRender","localContext","Presence","VisibilityAction","defaultHandler","sortByDepth","createBatcher","queue","flush","presence","Present","isSharedLayout","forceUpdate","SharedLayoutContext","useUnmountEffect","useSnapshotOnUnmount","syncLayout","remove","createMotionComponent","useVisualElement","animationControlsConfig","MotionComponent","component","createLock","name","lock","openLock","globalHorizontalLock","globalVerticalLock","getGlobalLock","openHorizontal_1","openVertical_1","isViewportScrollBlocked","isBrowser","document","addEventListener","event","preventDefault","passive","blockViewportScroll","unblockViewportScroll","addDomEvent","eventName","removeEventListener","useDomEvent","isMouseEvent","PointerEvent","pointerType","MouseEvent","isTouchEvent","hasTouches","touches","filterPrimaryPointer","eventHandler","isPrimaryPointer","button","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","primaryTouch","changedTouches","pointFromMouse","extractEventInfo","getViewportPointFromEvent","wrapHandler","shouldFilterPrimaryPointer","isBrowser$1","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","addPointerEvent","usePointerEvent","Point","subtract","relativeTo","idOrElem","elem","getElem","getElementById","localElem","rect","scrollX","scrollY","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","onMove","initialInfo","onSessionStart","removeOnPointerMove","handlePointerMove","removeOnPointerUp","handlePointerUp","removeListeners","buttons","end","onEnd","panInfo","updateHandlers","lastDevicePoint","startDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","currentVelocity","Infinity","applyConstraints","elastic","calcConstrainedMinPoint","constraints","calcRelativeAxisConstraints","calcRelativeConstraints","layoutBox","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcPositionFromProgress","axisLength","elementDragControls","WeakMap","lastPointerEvent","VisualElementDragControls","isDragging","currentDirection","cursorProgress","openGlobalLock","panSession","originEvent","snapToCursor","stopMotion","dragPropagation","prepareBoundingBox","resolveDragConstraints","onDragStart","dragDirectionLock","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","onMeasureDragConstraints","constraintsElement","measuredConstraints","userConstraints","cancelDrag","dragMomentum","dragElastic","onDragEnd","animateDragEnd","shouldDrag","axisLayout","updateProps","_f","_g","remainingProps","dragTransition","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","onDragTransitionEnd","boxProgress","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","prevSnapshot","direction","lockThreshold","abs","useDrag","groupDragControls","dragControls","Drag","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","onPointerDown","isNodeOrChild","parentElement","order$1","getGesturePriority","gesture","tapGesturePriority","useTapGesture","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","onPointerUp","openGestureLock","hoverPriority","filterTouch","useHoverGesture","onHoverStart","onHoverEnd","useGestures","gestureProps","Gestures","Exit","exit","isPlayingExitAnimation","tweenAxis","progressTarget","Animate","frameTarget","stopAxisAnimation","visibilityAction","layout","boxHasMoved","hasMoved","Hide","animateAxis","onLayoutAnimationComplete","componentDidMount","unsubLayoutReady","componentWillUnmount","crossfadeOpacity","layoutProgress","crossfade","createCrossfadeAnimation","frame","unsubscribeProgress","easeCrossfadeIn","easeCrossfadeOut","AnimateLayout","hasAxisMoved","compress","easing","Measure","componentDidUpdate","getSnapshotBeforeUpdate","syncUpdate","MeasureLayout","createMotionProxy","componentCache","Proxy","m","useForceUpdate","forcedRenderCount","setForcedRenderCount","getPresenceId","PresenceChild","presenceChildren","newChildrenMap","childId","allComplete","isComplete","getChildKey","updateChildLookup","allChildren","seenChildren","env","NODE_ENV","console","warn","onlyElements","filtered","AnimatePresence","exitBeforeEnter","forceRender","layoutContext","filteredChildren","presentChildren","exiting","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","onExit","removeIndex","findIndex","presentChild","splice","createSwitchAnimation","stack","lead","Entering","prevLead","Show","getFollowOrigin","Exiting","getFollowTarget","stackLead","stackLeadPresence","follow","getLeadTransition","getLeadTarget","getLeadOrigin","findLeadAndFollow","prevFollow","leadIndex","numInStack","lastIsPresent","isLastInStack","stackChild","LayoutStack","hasChildren","layoutOrder","index","snapshot","boundingBox","latestMotionValues","updateLeadAndFollow","updateSnapshot","isLeadPresent","shouldStackAnimate","AnimateSharedLayout","stacks","updateScheduled","renderScheduled","syncContext","force","scheduleUpdate","updateStacks","startLayoutAnimation","shouldComponentUpdate","createAnimation","getStack","addToStack","removeFromStack","useMotionValue","resolveMotionValue","unwrappedValue","isCustomValueType","getMixer","args","_i","useImmediate","argOffset","inputValue","inputRange","outputRange","interpolator","mixer","isTransformer","useTransform","customTransform","comparitor","transformer","initialValue","maxScale","invertScale","useInvertedScale","parentScaleX","parentScaleY","useOnChange","useSpring","activeSpringAnimation","createScrollMotionValues","scrollXProgress","scrollYProgress","setProgress","maxOffset","createScrollUpdater","getOffsets","xOffset","yOffset","xMaxOffset","yMaxOffset","isBrowser$2","useIsomorphicLayoutEffect","getElementScrollOffsets","scrollLeft","scrollTop","scrollWidth","offsetWidth","scrollHeight","offsetHeight","useElementScroll","updateScrollValues","scrollListener","resizeListener","viewportScrollValues","getViewportScrollOffsets","pageXOffset","pageYOffset","body","clientWidth","innerWidth","clientHeight","innerHeight","hasListeners","addEventListeners","useViewportScroll","useAnimation","useCycle","items","item","setItem","prefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","determineShouldReduceMotion","prefersReduced","useReducedMotion","shouldReduceMotion","setShouldReduceMotion","ReducedMotion","enabled","DragControls","nativeEvent","createDragControls","useDragControls","useExternalRef","StateVisualElement","useAnimatedState","animationState","setAnimationState"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,cAAnB,EAAmCC,MAAnC,EAA2CC,SAA3C,QAA4D,OAA5D;AACA,OAAOC,IAAP,IAAeC,YAAf,EAA6BC,UAA7B,QAA+C,WAA/C;AACA,SAASC,iBAAT,EAA4BC,GAA5B,EAAiCC,KAAjC,EAAwCC,QAAxC,EAAkDC,QAAlD,EAA4DC,MAAM,IAAIC,QAAtE,EAAgFC,OAAhF,EAAyFC,WAAzF,EAAsGC,IAAtG,QAAkH,oBAAlH;AACA,SAASC,SAAT,EAAoBC,OAApB,QAAmC,YAAnC;AACA,SAASC,MAAT,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiCC,EAAjC,EAAqCC,OAArC,EAA8CC,OAA9C,EAAuDC,EAAvD,EAA2DC,EAA3D,EAA+DC,KAA/D,EAAsEC,KAAtE,EAA6EC,kBAA7E,QAAuG,mBAAvG;AACA,SAASC,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuCC,SAAS,IAAIC,WAApD,EAAiEC,OAAjE,QAAgF,WAAhF;AACA,OAAO,KAAKC,YAAZ,MAA8B,mBAA9B;AACA,SAASC,WAAT,EAAsB1B,MAAtB,QAAoC,mBAApC;AACA,OAAO2B,cAAP,IAAyBC,MAAzB,EAAiCC,aAAjC,EAAgDC,UAAhD,EAA4DC,SAA5D,EAAuEC,aAAvE,EAAsFC,OAAtF,EAA+FC,UAA/F,EAA2GC,QAA3G,EAAqHC,SAArH,EAAgIC,WAAhI,EAA6IC,QAA7I,EAAuJC,YAAvJ,EAAqKC,QAArK,EAA+KC,cAA/K,EAA+LC,eAA/L,QAAsN,OAAtN;;AAEA,IAAIC,WAAW,GAAG,UAAUC,GAAV,EAAe;AAC7B,SAAO,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,CAACC,cAAJ,CAAmB,SAAnB,CAAlC;AACH,CAFD;;AAIA,IAAIC,OAAO,GAAG,UAAUC,KAAV,EAAiB;AAC3B,SAAO,CAACC,KAAK,CAACC,UAAU,CAACF,KAAD,CAAX,CAAb;AACH,CAFD;AAGA;;;;;;;AAKA,IAAIG,WAAW;AAAG;AAAe,YAAY;AACzC;;;;;;;;AAQA,WAASA,WAAT,CAAqBC,IAArB,EAA2B;AACvB,QAAIC,KAAK,GAAG,IAAZ;AACA;;;;;;;AAKA,SAAKC,SAAL,GAAiB,CAAjB;AACA;;;;;;AAKA,SAAKC,WAAL,GAAmB,CAAnB;AACA;;;;;;;;AAOA,SAAKC,gBAAL,GAAwB,KAAxB;;AACA,SAAKC,eAAL,GAAuB,UAAUC,CAAV,EAAaC,MAAb,EAAqB;AACxC,UAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,QAAAA,MAAM,GAAG,IAAT;AAAgB;;AACzCN,MAAAA,KAAK,CAACO,IAAN,GAAaP,KAAK,CAACQ,OAAnB;AACAR,MAAAA,KAAK,CAACQ,OAAN,GAAgBH,CAAhB;;AACA,UAAIL,KAAK,CAACS,iBAAN,IAA2BT,KAAK,CAACO,IAAN,KAAeP,KAAK,CAACQ,OAApD,EAA6D;AACzDR,QAAAA,KAAK,CAACS,iBAAN,CAAwBC,OAAxB,CAAgCV,KAAK,CAACW,gBAAtC;AACH;;AACD,UAAIL,MAAM,IAAIN,KAAK,CAACY,iBAApB,EAAuC;AACnCZ,QAAAA,KAAK,CAACY,iBAAN,CAAwBF,OAAxB,CAAgCV,KAAK,CAACW,gBAAtC;AACH,OATuC,CAUxC;;;AACA,UAAIE,EAAE,GAAGxE,YAAY,EAArB;AAAA,UAAyByE,KAAK,GAAGD,EAAE,CAACC,KAApC;AAAA,UAA2CC,SAAS,GAAGF,EAAE,CAACE,SAA1D;;AACA,UAAIf,KAAK,CAACE,WAAN,KAAsBa,SAA1B,EAAqC;AACjCf,QAAAA,KAAK,CAACC,SAAN,GAAkBa,KAAlB;AACAd,QAAAA,KAAK,CAACE,WAAN,GAAoBa,SAApB;AACA3E,QAAAA,IAAI,CAAC4E,UAAL,CAAgBhB,KAAK,CAACiB,qBAAtB;AACH;AACJ,KAjBD;AAkBA;;;;;;;;;;;;AAUA,SAAKN,gBAAL,GAAwB,UAAUO,UAAV,EAAsB;AAC1CA,MAAAA,UAAU,CAAClB,KAAK,CAACQ,OAAP,CAAV;AACH,KAFD;AAGA;;;;;;;;;;AAQA,SAAKS,qBAAL,GAA6B,YAAY;AAAE,aAAO7E,IAAI,CAAC4E,UAAL,CAAgBhB,KAAK,CAACmB,aAAtB,CAAP;AAA8C,KAAzF;AACA;;;;;;;;;;;AASA,SAAKA,aAAL,GAAqB,UAAUN,EAAV,EAAc;AAC/B,UAAIE,SAAS,GAAGF,EAAE,CAACE,SAAnB;;AACA,UAAIA,SAAS,KAAKf,KAAK,CAACE,WAAxB,EAAqC;AACjCF,QAAAA,KAAK,CAACO,IAAN,GAAaP,KAAK,CAACQ,OAAnB;AACH;AACJ,KALD;;AAMA,SAAKY,GAAL,CAASrB,IAAT,EAAe,KAAf;AACA,SAAKI,gBAAL,GAAwBT,OAAO,CAAC,KAAKc,OAAN,CAA/B;AACH;AACD;;;;;;;;AAMAV,EAAAA,WAAW,CAACuB,SAAZ,CAAsBC,WAAtB,GAAoC,UAAUC,aAAV,EAAyBC,YAAzB,EAAuC;AACvE,QAAIxB,KAAK,GAAG,IAAZ;;AACA,QAAIyB,gBAAgB,GAAG,YAAY;AAAE,aAAOD,YAAY,CAACxB,KAAK,CAACQ,OAAP,CAAnB;AAAqC,KAA1E;;AACAe,IAAAA,aAAa,CAACG,GAAd,CAAkBD,gBAAlB;AACA,WAAO,YAAY;AAAE,aAAOF,aAAa,CAACI,MAAd,CAAqBF,gBAArB,CAAP;AAAgD,KAArE;AACH,GALD;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8EA3B,EAAAA,WAAW,CAACuB,SAAZ,CAAsBO,QAAtB,GAAiC,UAAUJ,YAAV,EAAwB;AACrD,QAAI,CAAC,KAAKf,iBAAV,EACI,KAAKA,iBAAL,GAAyB,IAAIoB,GAAJ,EAAzB;AACJ,WAAO,KAAKP,WAAL,CAAiB,KAAKb,iBAAtB,EAAyCe,YAAzC,CAAP;AACH,GAJD;;AAKA1B,EAAAA,WAAW,CAACuB,SAAZ,CAAsBS,cAAtB,GAAuC,YAAY;AAC/C,QAAIjB,EAAJ;;AACA,KAACA,EAAE,GAAG,KAAKJ,iBAAX,MAAkC,IAAlC,IAA0CI,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAACkB,KAAH,EAAnE;AACH,GAHD;AAIA;;;;;;;;;;AAQAjC,EAAAA,WAAW,CAACuB,SAAZ,CAAsBW,eAAtB,GAAwC,UAAUR,YAAV,EAAwB;AAC5D,QAAI,CAAC,KAAKZ,iBAAV,EACI,KAAKA,iBAAL,GAAyB,IAAIiB,GAAJ,EAAzB,CAFwD,CAG5D;;AACA,SAAKlB,gBAAL,CAAsBa,YAAtB;AACA,WAAO,KAAKF,WAAL,CAAiB,KAAKV,iBAAtB,EAAyCY,YAAzC,CAAP;AACH,GAND;AAOA;;;;;;;AAKA1B,EAAAA,WAAW,CAACuB,SAAZ,CAAsBY,MAAtB,GAA+B,UAAUC,aAAV,EAAyB;AACpD,SAAKA,aAAL,GAAqBA,aAArB;AACH,GAFD;AAGA;;;;;;;;;;;;;;;;;AAeApC,EAAAA,WAAW,CAACuB,SAAZ,CAAsBD,GAAtB,GAA4B,UAAUf,CAAV,EAAaC,MAAb,EAAqB;AAC7C,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,IAAT;AAAgB;;AACzC,QAAI,CAACA,MAAD,IAAW,CAAC,KAAK4B,aAArB,EAAoC;AAChC,WAAK9B,eAAL,CAAqBC,CAArB,EAAwBC,MAAxB;AACH,KAFD,MAGK;AACD,WAAK4B,aAAL,CAAmB7B,CAAnB,EAAsB,KAAKD,eAA3B;AACH;AACJ,GARD;AASA;;;;;;;;;AAOAN,EAAAA,WAAW,CAACuB,SAAZ,CAAsBc,GAAtB,GAA4B,YAAY;AACpC,WAAO,KAAK3B,OAAZ;AACH,GAFD;AAGA;;;;;AAGAV,EAAAA,WAAW,CAACuB,SAAZ,CAAsBe,WAAtB,GAAoC,YAAY;AAC5C,WAAO,KAAK7B,IAAZ;AACH,GAFD;AAGA;;;;;;;;;AAOAT,EAAAA,WAAW,CAACuB,SAAZ,CAAsBgB,WAAtB,GAAoC,YAAY;AAC5C;AACA,WAAO,KAAKlC,gBAAL,GACD;AACE5D,IAAAA,iBAAiB,CAACsD,UAAU,CAAC,KAAKW,OAAN,CAAV,GACdX,UAAU,CAAC,KAAKU,IAAN,CADG,EACU,KAAKN,SADf,CAFlB,GAID,CAJN;AAKH,GAPD;AAQA;;;;;;;;;;;;;;AAYAH,EAAAA,WAAW,CAACuB,SAAZ,CAAsBiB,KAAtB,GAA8B,UAAUC,SAAV,EAAqB;AAC/C,QAAIvC,KAAK,GAAG,IAAZ;;AACA,SAAKwC,IAAL;AACA,WAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AAClC1C,MAAAA,KAAK,CAAC2C,aAAN,GAAsBJ,SAAS,CAACG,OAAD,CAA/B;AACH,KAFM,EAEJE,IAFI,CAEC,YAAY;AAAE,aAAO5C,KAAK,CAAC6C,cAAN,EAAP;AAAgC,KAF/C,CAAP;AAGH,GAND;AAOA;;;;;;;AAKA/C,EAAAA,WAAW,CAACuB,SAAZ,CAAsBmB,IAAtB,GAA6B,YAAY;AACrC,QAAI,KAAKG,aAAT,EACI,KAAKA,aAAL;AACJ,SAAKE,cAAL;AACH,GAJD;AAKA;;;;;;;AAKA/C,EAAAA,WAAW,CAACuB,SAAZ,CAAsByB,WAAtB,GAAoC,YAAY;AAC5C,WAAO,CAAC,CAAC,KAAKH,aAAd;AACH,GAFD;;AAGA7C,EAAAA,WAAW,CAACuB,SAAZ,CAAsBwB,cAAtB,GAAuC,YAAY;AAC/C,SAAKF,aAAL,GAAqB,IAArB;AACH,GAFD;AAGA;;;;;;;;;;;AASA7C,EAAAA,WAAW,CAACuB,SAAZ,CAAsB0B,OAAtB,GAAgC,YAAY;AACxC,SAAKtC,iBAAL,IAA0B,KAAKA,iBAAL,CAAuBsB,KAAvB,EAA1B;AACA,SAAKnB,iBAAL,IAA0B,KAAKA,iBAAL,CAAuBmB,KAAvB,EAA1B;AACA,SAAKS,IAAL;AACH,GAJD;;AAKA,SAAO1C,WAAP;AACH,CAjUgC,EAAjC;AAkUA;;;;;AAGA,SAASkD,WAAT,CAAqBjD,IAArB,EAA2B;AACvB,SAAO,IAAID,WAAJ,CAAgBC,IAAhB,CAAP;AACH;AAED;;;;;;;;;;AAQA,IAAIkD,aAAa;AAAG;AAAe,YAAY;AAC3C,WAASA,aAAT,CAAuBC,MAAvB,EAA+B1D,GAA/B,EAAoC;AAChC,QAAIQ,KAAK,GAAG,IAAZ,CADgC,CAEhC;;;AACA,SAAKmD,QAAL,GAAgB,IAAItB,GAAJ,EAAhB,CAHgC,CAIhC;;AACA,SAAKuB,MAAL,GAAc,EAAd,CALgC,CAMhC;;AACA,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd,CAPgC,CAQhC;;AACA,SAAKC,kBAAL,GAA0B,IAAID,GAAJ,EAA1B,CATgC,CAUhC;;AACA,SAAKE,MAAL,GAAc,EAAd,CAXgC,CAYhC;AACA;;AACA,SAAKC,MAAL,GAAc,YAAY;AAAE,aAAOzD,KAAK,CAACwD,MAAN,CAAaE,QAAb,CAAsB1D,KAAK,CAACoD,MAA5B,CAAP;AAA6C,KAAzE,CAdgC,CAehC;;;AACA,SAAKO,aAAL,GAAqB,YAAY;AAAE,aAAO3D,KAAK,CAACM,MAAN,EAAP;AAAwB,KAA3D;;AACA,SAAKsD,cAAL,GAAsB,YAAY;AAAE,aAAOxH,IAAI,CAACkE,MAAL,CAAYN,KAAK,CAAC2D,aAAlB,EAAiC,KAAjC,EAAwC,IAAxC,CAAP;AAAuD,KAA3F,CAjBgC,CAkBhC;AACA;;;AACA,SAAKnE,GAAL,GAAW,UAAUqE,OAAV,EAAmB;AAC1BA,MAAAA,OAAO,GAAG7D,KAAK,CAAC8D,KAAN,CAAYD,OAAZ,CAAH,GAA0B7D,KAAK,CAAC+D,OAAN,EAAjC;AACA,UAAI,CAAC/D,KAAK,CAACgE,WAAX,EACI;;AACJ,UAAI,OAAOhE,KAAK,CAACgE,WAAb,KAA6B,UAAjC,EAA6C;AACzChE,QAAAA,KAAK,CAACgE,WAAN,CAAkBH,OAAlB;AACH,OAFD,MAGK,IAAItE,WAAW,CAACS,KAAK,CAACgE,WAAP,CAAf,EAAoC;AACrChE,QAAAA,KAAK,CAACgE,WAAN,CAAkBxD,OAAlB,GAA4BqD,OAA5B;AACH;AACJ,KAVD,CApBgC,CA+BhC;;;AACA,SAAKX,MAAL,GAAcA,MAAd;AACA,SAAKe,UAAL,GAAkBf,MAAM,GAAGA,MAAM,CAACe,UAAV,GAAuB,IAA/C;AACA,SAAKC,QAAL,GAAgBhB,MAAM,GAAGjH,cAAc,CAACiH,MAAM,CAACgB,QAAR,EAAkB,CAAChB,MAAD,CAAlB,CAAjB,GAA+C,EAArE,CAlCgC,CAmChC;;AACA,SAAKiB,KAAL,GAAajB,MAAM,GAAGA,MAAM,CAACiB,KAAP,GAAe,CAAlB,GAAsB,CAAzC,CApCgC,CAqChC;AACA;;AACA,SAAKH,WAAL,GAAmBxE,GAAnB;AACH;;AACDyD,EAAAA,aAAa,CAAC5B,SAAd,CAAwB+C,SAAxB,GAAoC,UAAUC,KAAV,EAAiB;AACjD,QAAIrE,KAAK,GAAG,IAAZ;;AACA,SAAKmD,QAAL,CAAczB,GAAd,CAAkB2C,KAAlB;AACA,WAAO,YAAY;AAAE,aAAOrE,KAAK,CAACmD,QAAN,CAAexB,MAAf,CAAsB0C,KAAtB,CAAP;AAAsC,KAA3D;AACH,GAJD,CA1C2C,CA+C3C;;;AACApB,EAAAA,aAAa,CAAC5B,SAAd,CAAwBiD,QAAxB,GAAmC,UAAUC,GAAV,EAAe;AAC9C,WAAO,KAAKlB,MAAL,CAAYmB,GAAZ,CAAgBD,GAAhB,CAAP;AACH,GAFD,CAhD2C,CAmD3C;;;AACAtB,EAAAA,aAAa,CAAC5B,SAAd,CAAwBoD,QAAxB,GAAmC,UAAUF,GAAV,EAAe5E,KAAf,EAAsB;AACrD,QAAI,KAAK2E,QAAL,CAAcC,GAAd,CAAJ,EACI,KAAKG,WAAL,CAAiBH,GAAjB;AACJ,SAAKlB,MAAL,CAAYjC,GAAZ,CAAgBmD,GAAhB,EAAqB5E,KAArB;AACA,SAAKyD,MAAL,CAAYmB,GAAZ,IAAmB5E,KAAK,CAACwC,GAAN,EAAnB;AACA,QAAI,KAAK0B,OAAT,EACI,KAAKc,gBAAL,CAAsBJ,GAAtB,EAA2B5E,KAA3B;AACP,GAPD,CApD2C,CA4D3C;;;AACAsD,EAAAA,aAAa,CAAC5B,SAAd,CAAwBqD,WAAxB,GAAsC,UAAUH,GAAV,EAAe;AACjD,QAAIK,WAAW,GAAG,KAAKrB,kBAAL,CAAwBpB,GAAxB,CAA4BoC,GAA5B,CAAlB;AACAK,IAAAA,WAAW,IAAIA,WAAW,EAA1B;AACA,SAAKvB,MAAL,CAAY1B,MAAZ,CAAmB4C,GAAnB;AACA,WAAO,KAAKnB,MAAL,CAAYmB,GAAZ,CAAP;AACA,SAAKhB,kBAAL,CAAwB5B,MAAxB,CAA+B4C,GAA/B;AACH,GAND;;AAOAtB,EAAAA,aAAa,CAAC5B,SAAd,CAAwBwD,QAAxB,GAAmC,UAAUN,GAAV,EAAeO,YAAf,EAA6B;AAC5D,QAAInF,KAAK,GAAG,KAAK0D,MAAL,CAAYlB,GAAZ,CAAgBoC,GAAhB,CAAZ;;AACA,QAAI5E,KAAK,KAAKoF,SAAV,IAAuBD,YAAY,KAAKC,SAA5C,EAAuD;AACnDpF,MAAAA,KAAK,GAAG,IAAIG,WAAJ,CAAgBgF,YAAhB,CAAR;AACA,WAAKL,QAAL,CAAcF,GAAd,EAAmB5E,KAAnB;AACH;;AACD,WAAOA,KAAP;AACH,GAPD,CApE2C,CA4E3C;;;AACAsD,EAAAA,aAAa,CAAC5B,SAAd,CAAwB2D,YAAxB,GAAuC,UAAUC,QAAV,EAAoB;AACvD,SAAK5B,MAAL,CAAY3C,OAAZ,CAAoBuE,QAApB;AACH,GAFD,CA7E2C,CAgF3C;AACA;;;AACAhC,EAAAA,aAAa,CAAC5B,SAAd,CAAwB6D,WAAxB,GAAsC,YAAY;AAC9C,WAAO,KAAKrB,OAAZ;AACH,GAFD;;AAGAZ,EAAAA,aAAa,CAAC5B,SAAd,CAAwB8D,YAAxB,GAAuC,UAAU3B,MAAV,EAAkB;AACrD,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,SAAKA,MAAL,GAAcxH,QAAQ,CAAC,EAAD,EAAKwH,MAAL,CAAtB;AACH,GAHD,CArF2C,CAyF3C;;;AACAP,EAAAA,aAAa,CAAC5B,SAAd,CAAwB+D,oBAAxB,GAA+C,UAAUb,GAAV,EAAe5E,KAAf,EAAsB;AACjE,SAAKyD,MAAL,CAAYmB,GAAZ,IAAmB5E,KAAnB;AACH,GAFD,CA1F2C,CA6F3C;;;AACAsD,EAAAA,aAAa,CAAC5B,SAAd,CAAwBgE,eAAxB,GAA0C,UAAUhC,MAAV,EAAkB1D,KAAlB,EAAyB;AAC/D,QAAI,OAAO0D,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,WAAK+B,oBAAL,CAA0B/B,MAA1B,EAAkC1D,KAAlC;AACH,KAFD,MAGK;AACD,WAAK,IAAI4E,GAAT,IAAgBlB,MAAhB,EAAwB;AACpB,aAAK+B,oBAAL,CAA0Bb,GAA1B,EAA+BlB,MAAM,CAACkB,GAAD,CAArC;AACH;AACJ;AACJ,GATD;;AAUAtB,EAAAA,aAAa,CAAC5B,SAAd,CAAwBiE,yBAAxB,GAAoD,YAAY;AAC5DlJ,IAAAA,IAAI,CAACqH,MAAL,CAAY,KAAKQ,UAAL,CAAgBsB,iBAA5B,EAA+C,KAA/C,EAAsD,IAAtD;AACH,GAFD,CAxG2C,CA2G3C;;;AACAtC,EAAAA,aAAa,CAAC5B,SAAd,CAAwBsD,gBAAxB,GAA2C,UAAUJ,GAAV,EAAe5E,KAAf,EAAsB;AAC7D,QAAIK,KAAK,GAAG,IAAZ;;AACA,QAAI4B,QAAQ,GAAG,UAAUwB,MAAV,EAAkB;AAC7BpD,MAAAA,KAAK,CAACoF,oBAAN,CAA2Bb,GAA3B,EAAgCnB,MAAhC;;AACApD,MAAAA,KAAK,CAACoD,MAAN,CAAamB,GAAb,IAAoBnB,MAApB;AACApD,MAAAA,KAAK,CAACwD,MAAN,CAAaE,QAAb,IAAyBtH,IAAI,CAACqH,MAAL,CAAYzD,KAAK,CAACyD,MAAlB,EAA0B,KAA1B,EAAiC,IAAjC,CAAzB;AACH,KAJD;;AAKA,QAAI+B,mBAAmB,GAAG7F,KAAK,CAACiC,QAAN,CAAeA,QAAf,CAA1B;AACA,QAAI6D,mBAAmB,GAAG9F,KAAK,CAACqC,eAAN,CAAsB,KAAK4B,cAA3B,CAA1B;AACA,SAAKL,kBAAL,CAAwBnC,GAAxB,CAA4BmD,GAA5B,EAAiC,YAAY;AACzCiB,MAAAA,mBAAmB;AACnBC,MAAAA,mBAAmB;AACtB,KAHD;AAIH,GAbD,CA5G2C,CA0H3C;;;AACAxC,EAAAA,aAAa,CAAC5B,SAAd,CAAwByC,KAAxB,GAAgC,UAAUD,OAAV,EAAmB;AAC/C,QAAI7D,KAAK,GAAG,IAAZ;;AACA/C,IAAAA,SAAS,CAAC,CAAC,CAAC4G,OAAH,EAAY,gGAAZ,CAAT;;AACA,QAAI,KAAKX,MAAT,EAAiB;AACb,WAAKwC,gBAAL,GAAwB,KAAKxC,MAAL,CAAYkB,SAAZ,CAAsB,IAAtB,CAAxB;AACH;AACD;;;;;;AAIA,SAAKP,OAAL,GAAe,KAAKrD,OAAL,GAAeqD,OAA9B,CAV+C,CAW/C;;AACA,SAAKmB,YAAL,CAAkB,UAAUrF,KAAV,EAAiB4E,GAAjB,EAAsB;AAAE,aAAOvE,KAAK,CAAC2E,gBAAN,CAAuBJ,GAAvB,EAA4B5E,KAA5B,CAAP;AAA4C,KAAtF;AACH,GAbD,CA3H2C,CAyI3C;;;AACAsD,EAAAA,aAAa,CAAC5B,SAAd,CAAwB0C,OAAxB,GAAkC,YAAY;AAC1C,QAAI/D,KAAK,GAAG,IAAZ;;AACA,SAAKgF,YAAL,CAAkB,UAAUW,CAAV,EAAapB,GAAb,EAAkB;AAAE,aAAOvE,KAAK,CAAC0E,WAAN,CAAkBH,GAAlB,CAAP;AAAgC,KAAtE;AACAjI,IAAAA,UAAU,CAACmH,MAAX,CAAkB,KAAKA,MAAvB;AACAnH,IAAAA,UAAU,CAACgE,MAAX,CAAkB,KAAKA,MAAvB;AACA,SAAKoF,gBAAL,IAAyB,KAAKA,gBAAL,EAAzB;AACH,GAND;;AAOA,SAAOzC,aAAP;AACH,CAlJkC,EAAnC;;AAoJA,SAAS2C,IAAT,CAAcC,GAAd,EAAmB;AACf,SAAOA,GAAP;AACH;AAED;;;;;;;AAKA,SAASC,2BAAT,CAAqCjF,EAArC,EAAyC;AACrC,MAAIkF,GAAG,GAAGlF,EAAE,CAACkF,GAAb;AAAA,MAAkBC,IAAI,GAAGnF,EAAE,CAACmF,IAA5B;AAAA,MAAkCC,KAAK,GAAGpF,EAAE,CAACoF,KAA7C;AAAA,MAAoDC,MAAM,GAAGrF,EAAE,CAACqF,MAAhE;AACA,SAAO;AACHC,IAAAA,CAAC,EAAE;AAAEC,MAAAA,GAAG,EAAEJ,IAAP;AAAaK,MAAAA,GAAG,EAAEJ;AAAlB,KADA;AAEHK,IAAAA,CAAC,EAAE;AAAEF,MAAAA,GAAG,EAAEL,GAAP;AAAYM,MAAAA,GAAG,EAAEH;AAAjB;AAFA,GAAP;AAIH;;AACD,SAASK,2BAAT,CAAqC1F,EAArC,EAAyC;AACrC,MAAIsF,CAAC,GAAGtF,EAAE,CAACsF,CAAX;AAAA,MAAcG,CAAC,GAAGzF,EAAE,CAACyF,CAArB;AACA,SAAO;AACHP,IAAAA,GAAG,EAAEO,CAAC,CAACF,GADJ;AAEHF,IAAAA,MAAM,EAAEI,CAAC,CAACD,GAFP;AAGHL,IAAAA,IAAI,EAAEG,CAAC,CAACC,GAHL;AAIHH,IAAAA,KAAK,EAAEE,CAAC,CAACE;AAJN,GAAP;AAMH;AACD;;;;;;;AAKA,SAASG,oBAAT,CAA8B3F,EAA9B,EAAkC4F,cAAlC,EAAkD;AAC9C,MAAIV,GAAG,GAAGlF,EAAE,CAACkF,GAAb;AAAA,MAAkBC,IAAI,GAAGnF,EAAE,CAACmF,IAA5B;AAAA,MAAkCE,MAAM,GAAGrF,EAAE,CAACqF,MAA9C;AAAA,MAAsDD,KAAK,GAAGpF,EAAE,CAACoF,KAAjE;;AACA,MAAIQ,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAAEA,IAAAA,cAAc,GAAGb,IAAjB;AAAwB;;AACzD,MAAIc,OAAO,GAAGD,cAAc,CAAC;AAAEN,IAAAA,CAAC,EAAEH,IAAL;AAAWM,IAAAA,CAAC,EAAEP;AAAd,GAAD,CAA5B;AACA,MAAIY,WAAW,GAAGF,cAAc,CAAC;AAAEN,IAAAA,CAAC,EAAEF,KAAL;AAAYK,IAAAA,CAAC,EAAEJ;AAAf,GAAD,CAAhC;AACA,SAAO;AACHH,IAAAA,GAAG,EAAEW,OAAO,CAACJ,CADV;AAEHN,IAAAA,IAAI,EAAEU,OAAO,CAACP,CAFX;AAGHD,IAAAA,MAAM,EAAES,WAAW,CAACL,CAHjB;AAIHL,IAAAA,KAAK,EAAEU,WAAW,CAACR;AAJhB,GAAP;AAMH;AACD;;;;;AAGA,SAASS,OAAT,GAAmB;AACf,SAAO;AAAET,IAAAA,CAAC,EAAE;AAAEC,MAAAA,GAAG,EAAE,CAAP;AAAUC,MAAAA,GAAG,EAAE;AAAf,KAAL;AAAyBC,IAAAA,CAAC,EAAE;AAAEF,MAAAA,GAAG,EAAE,CAAP;AAAUC,MAAAA,GAAG,EAAE;AAAf;AAA5B,GAAP;AACH;;AACD,SAASQ,WAAT,CAAqBC,GAArB,EAA0B;AACtB,SAAO;AACHX,IAAAA,CAAC,EAAEnK,QAAQ,CAAC,EAAD,EAAK8K,GAAG,CAACX,CAAT,CADR;AAEHG,IAAAA,CAAC,EAAEtK,QAAQ,CAAC,EAAD,EAAK8K,GAAG,CAACR,CAAT;AAFR,GAAP;AAIH;AACD;;;;;AAGA,IAAIS,SAAS,GAAG;AACZC,EAAAA,SAAS,EAAE,CADC;AAEZrJ,EAAAA,KAAK,EAAE,CAFK;AAGZsJ,EAAAA,MAAM,EAAE,CAHI;AAIZC,EAAAA,WAAW,EAAE;AAJD,CAAhB;;AAMA,SAASpG,KAAT,GAAiB;AACb,SAAO;AACHqF,IAAAA,CAAC,EAAEnK,QAAQ,CAAC,EAAD,EAAK+K,SAAL,CADR;AAEHT,IAAAA,CAAC,EAAEtK,QAAQ,CAAC,EAAD,EAAK+K,SAAL;AAFR,GAAP;AAIH;AAED;;;;;AAGA,IAAII,IAAI,GAAG;AACPC,EAAAA,IAAI,EAAE,UAAU/G,CAAV,EAAa;AAAE,WAAOA,CAAC,KAAK,MAAb;AAAsB,GADpC;AAEPgH,EAAAA,KAAK,EAAE,UAAUhH,CAAV,EAAa;AAAE,WAAOA,CAAP;AAAW;AAF1B,CAAX;AAIA;;;;AAGA,IAAIiH,GAAG,GAAGtL,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKmB,MAAL,CAAT,EAAuB;AAAEoK,EAAAA,SAAS,EAAEC,IAAI,CAACC;AAAlB,CAAvB,CAAlB;AACA;;;;;AAGA,IAAIC,iBAAiB,GAAG;AACpB;AACAtK,EAAAA,KAAK,EAAEA,KAFa;AAGpBuK,EAAAA,eAAe,EAAEvK,KAHG;AAIpBwK,EAAAA,YAAY,EAAExK,KAJM;AAKpByK,EAAAA,IAAI,EAAEzK,KALc;AAMpB0K,EAAAA,MAAM,EAAE1K,KANY;AAOpB;AACA2K,EAAAA,WAAW,EAAE3K,KARO;AASpB4K,EAAAA,cAAc,EAAE5K,KATI;AAUpB6K,EAAAA,gBAAgB,EAAE7K,KAVE;AAWpB8K,EAAAA,iBAAiB,EAAE9K,KAXC;AAYpB+K,EAAAA,eAAe,EAAE/K,KAZG;AAapBgL,EAAAA,WAAW,EAAE9K,EAbO;AAcpB+K,EAAAA,cAAc,EAAE/K,EAdI;AAepBgL,EAAAA,gBAAgB,EAAEhL,EAfE;AAgBpBiL,EAAAA,iBAAiB,EAAEjL,EAhBC;AAiBpBkL,EAAAA,eAAe,EAAElL,EAjBG;AAkBpBmL,EAAAA,YAAY,EAAEnL,EAlBM;AAmBpBoL,EAAAA,MAAM,EAAEpL,EAnBY;AAoBpBqL,EAAAA,mBAAmB,EAAErL,EApBD;AAqBpBsL,EAAAA,oBAAoB,EAAEtL,EArBF;AAsBpBuL,EAAAA,uBAAuB,EAAEvL,EAtBL;AAuBpBwL,EAAAA,sBAAsB,EAAExL,EAvBJ;AAwBpB;AACAyL,EAAAA,KAAK,EAAEzL,EAzBa;AA0BpB0L,EAAAA,QAAQ,EAAE1L,EA1BU;AA2BpB2L,EAAAA,MAAM,EAAE3L,EA3BY;AA4BpB4L,EAAAA,SAAS,EAAE5L,EA5BS;AA6BpB6L,EAAAA,IAAI,EAAE7L,EA7Bc;AA8BpByI,EAAAA,GAAG,EAAEzI,EA9Be;AA+BpB2I,EAAAA,KAAK,EAAE3I,EA/Ba;AAgCpB4I,EAAAA,MAAM,EAAE5I,EAhCY;AAiCpB0I,EAAAA,IAAI,EAAE1I,EAjCc;AAkCpB;AACA8L,EAAAA,OAAO,EAAE9L,EAnCW;AAoCpB+L,EAAAA,UAAU,EAAE/L,EApCQ;AAqCpBgM,EAAAA,YAAY,EAAEhM,EArCM;AAsCpBiM,EAAAA,aAAa,EAAEjM,EAtCK;AAuCpBkM,EAAAA,WAAW,EAAElM,EAvCO;AAwCpBmM,EAAAA,MAAM,EAAEnM,EAxCY;AAyCpBoM,EAAAA,SAAS,EAAEpM,EAzCS;AA0CpBqM,EAAAA,WAAW,EAAErM,EA1CO;AA2CpBsM,EAAAA,YAAY,EAAEtM,EA3CM;AA4CpBuM,EAAAA,UAAU,EAAEvM,EA5CQ;AA6CpB;AACAwM,EAAAA,MAAM,EAAEtM,OA9CY;AA+CpBuM,EAAAA,OAAO,EAAEvM,OA/CW;AAgDpBwM,EAAAA,OAAO,EAAExM,OAhDW;AAiDpByM,EAAAA,OAAO,EAAEzM,OAjDW;AAkDpBG,EAAAA,KAAK,EAAEA,KAlDa;AAmDpBuM,EAAAA,MAAM,EAAEvM,KAnDY;AAoDpBwM,EAAAA,MAAM,EAAExM,KApDY;AAqDpByM,EAAAA,MAAM,EAAEzM,KArDY;AAsDpB0M,EAAAA,IAAI,EAAE7M,OAtDc;AAuDpB8M,EAAAA,KAAK,EAAE9M,OAvDa;AAwDpB+M,EAAAA,KAAK,EAAE/M,OAxDa;AAyDpBd,EAAAA,QAAQ,EAAEY,EAzDU;AA0DpBkN,EAAAA,UAAU,EAAElN,EA1DQ;AA2DpBmN,EAAAA,UAAU,EAAEnN,EA3DQ;AA4DpBoN,EAAAA,UAAU,EAAEpN,EA5DQ;AA6DpB6I,EAAAA,CAAC,EAAE7I,EA7DiB;AA8DpBgJ,EAAAA,CAAC,EAAEhJ,EA9DiB;AA+DpBqN,EAAAA,CAAC,EAAErN,EA/DiB;AAgEpBsN,EAAAA,WAAW,EAAEtN,EAhEO;AAiEpBuN,EAAAA,OAAO,EAAEjN,KAjEW;AAkEpBkN,EAAAA,OAAO,EAAEjN,kBAlEW;AAmEpBkN,EAAAA,OAAO,EAAElN,kBAnEW;AAoEpBmN,EAAAA,OAAO,EAAE1N,EApEW;AAqEpB;AACA2N,EAAAA,MAAM,EAAE3D,GAtEY;AAuEpB;AACA4D,EAAAA,WAAW,EAAEtN,KAxEO;AAyEpBuN,EAAAA,aAAa,EAAEvN,KAzEK;AA0EpBwN,EAAAA,UAAU,EAAE9D;AA1EQ,CAAxB;AA4EA;;;;AAGA,IAAI+D,mBAAmB,GAAG,CAAClO,MAAD,EAASG,EAAT,EAAaC,OAAb,EAAsBC,OAAtB,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAuCyJ,IAAvC,CAA1B;AACA;;;;AAGA,IAAImE,aAAa,GAAG,UAAUjL,CAAV,EAAa;AAAE,SAAO,UAAUkL,IAAV,EAAgB;AAAE,WAAOA,IAAI,CAACnE,IAAL,CAAU/G,CAAV,CAAP;AAAsB,GAA/C;AAAkD,CAArF;AACA;;;;;AAGA,IAAImL,sBAAsB,GAAG,UAAUnL,CAAV,EAAa;AACtC,SAAOgL,mBAAmB,CAACI,IAApB,CAAyBH,aAAa,CAACjL,CAAD,CAAtC,CAAP;AACH,CAFD;AAGA;;;;;AAGA,IAAIqL,UAAU,GAAGzP,cAAc,CAACoP,mBAAD,EAAsB,CAACjO,KAAD,EAAQC,OAAR,CAAtB,CAA/B;AACA;;;;;AAGA,IAAIsO,aAAa,GAAG,UAAUtL,CAAV,EAAa;AAAE,SAAOqL,UAAU,CAACD,IAAX,CAAgBH,aAAa,CAACjL,CAAD,CAA7B,CAAP;AAA2C,CAA9E;AACA;;;;;AAGA,IAAIuL,mBAAmB,GAAG,UAAUrH,GAAV,EAAe;AAAE,SAAOmD,iBAAiB,CAACnD,GAAD,CAAxB;AAAgC,CAA3E;AACA;;;;;AAGA,IAAIsH,cAAc,GAAG,UAAUlM,KAAV,EAAiB4L,IAAjB,EAAuB;AACxC,SAAOA,IAAI,IAAI,OAAO5L,KAAP,KAAiB,QAAzB,GACD4L,IAAI,CAAChE,SAAL,CAAe5H,KAAf,CADC,GAEDA,KAFN;AAGH,CAJD;AAMA;;;;;;AAIA,IAAImM,IAAI,GAAG,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,GAAf,CAAX;AACA;;;;;AAIA,IAAIC,KAAK,GAAG,CAAC,WAAD,EAAc,OAAd,EAAuB,QAAvB,EAAiC,MAAjC,EAAyC,sBAAzC,CAAZ;AACA;;;;AAGA,IAAIC,cAAc,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAArB;AACAD,KAAK,CAACrL,OAAN,CAAc,UAAUuL,YAAV,EAAwB;AAClCH,EAAAA,IAAI,CAACpL,OAAL,CAAa,UAAUwL,OAAV,EAAmB;AAAE,WAAOF,cAAc,CAACG,IAAf,CAAoBF,YAAY,GAAGC,OAAnC,CAAP;AAAqD,GAAvF;AACH,CAFD;AAGA;;;;AAGA,SAASE,kBAAT,CAA4BC,CAA5B,EAA+BC,CAA/B,EAAkC;AAC9B,SAAON,cAAc,CAACO,OAAf,CAAuBF,CAAvB,IAA4BL,cAAc,CAACO,OAAf,CAAuBD,CAAvB,CAAnC;AACH;AACD;;;;;AAGA,IAAIE,gBAAgB,GAAG,IAAI3K,GAAJ,CAAQmK,cAAR,CAAvB;;AACA,SAASS,eAAT,CAAyBlI,GAAzB,EAA8B;AAC1B,SAAOiI,gBAAgB,CAAChI,GAAjB,CAAqBD,GAArB,CAAP;AACH;AACD;;;;;AAGA,IAAImI,oBAAoB,GAAG,IAAI7K,GAAJ,CAAQ,CAAC,SAAD,EAAY,SAAZ,EAAuB,SAAvB,CAAR,CAA3B;;AACA,SAAS8K,qBAAT,CAA+BpI,GAA/B,EAAoC;AAChC,SAAOmI,oBAAoB,CAAClI,GAArB,CAAyBD,GAAzB,CAAP;AACH;;AAED,IAAIqI,cAAc,GAAG;AACjBzG,EAAAA,CAAC,EAAE,YADc;AAEjBG,EAAAA,CAAC,EAAE,YAFc;AAGjBqE,EAAAA,CAAC,EAAE;AAHc,CAArB;AAKA;;;;;;;AAMA,SAASkC,cAAT,CAAwBtF,SAAxB,EAAmCuF,aAAnC,EAAkDC,iBAAlD,EAAqEC,kBAArE,EAAyFC,0BAAzF,EAAqHC,kBAArH,EAAyI;AACrI,MAAID,0BAA0B,KAAK,KAAK,CAAxC,EAA2C;AAAEA,IAAAA,0BAA0B,GAAG,IAA7B;AAAoC;;AACjF,MAAIC,kBAAkB,KAAK,KAAK,CAAhC,EAAmC;AAAEA,IAAAA,kBAAkB,GAAG,IAArB;AAA4B,GAFoE,CAGrI;;;AACA,MAAIC,eAAe,GAAG,EAAtB,CAJqI,CAKrI;AACA;;AACA,MAAIC,aAAa,GAAG,KAApB,CAPqI,CAQrI;;AACAN,EAAAA,aAAa,CAACO,IAAd,CAAmBjB,kBAAnB,EATqI,CAUrI;;AACA,MAAIkB,gBAAgB,GAAGR,aAAa,CAACS,MAArC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,gBAApB,EAAsCE,CAAC,EAAvC,EAA2C;AACvC,QAAIjJ,GAAG,GAAGuI,aAAa,CAACU,CAAD,CAAvB;AACAL,IAAAA,eAAe,IAAI,CAACP,cAAc,CAACrI,GAAD,CAAd,IAAuBA,GAAxB,IAA+B,GAA/B,GAAqCgD,SAAS,CAAChD,GAAD,CAA9C,GAAsD,IAAzE;AACA,QAAIA,GAAG,KAAK,GAAZ,EACI6I,aAAa,GAAG,IAAhB;AACP;;AACD,MAAI,CAACA,aAAD,IAAkBH,0BAAtB,EAAkD;AAC9CE,IAAAA,eAAe,IAAI,eAAnB;AACH,GAFD,MAGK;AACDA,IAAAA,eAAe,GAAGA,eAAe,CAACM,IAAhB,EAAlB;AACH,GAvBoI,CAwBrI;AACA;;;AACA,MAAIV,iBAAJ,EAAuB;AACnBI,IAAAA,eAAe,GAAGJ,iBAAiB,CAACxF,SAAD,EAAYyF,kBAAkB,GAAG,EAAH,GAAQG,eAAtC,CAAnC;AACH,GAFD,MAGK,IAAID,kBAAkB,IAAIF,kBAA1B,EAA8C;AAC/CG,IAAAA,eAAe,GAAG,MAAlB;AACH;;AACD,SAAOA,eAAP;AACH;AAED;;;;;AAGA,SAASO,aAAT,CAAuBnJ,GAAvB,EAA4B;AACxB,SAAOA,GAAG,CAACoJ,UAAJ,CAAe,IAAf,CAAP;AACH;;AAED,SAASC,eAAT,CAAyBC,MAAzB,EAAiCC,IAAjC,EAAuC;AACnC,SAAQD,MAAM,IAAIC,IAAI,CAACzH,GAAL,GAAWyH,IAAI,CAAC1H,GAApB,CAAP,GAAmC,GAA1C;AACH;AACD;;;;;;;;;AAOA,SAAS2H,mBAAT,CAA6B3K,MAA7B,EAAqC4K,WAArC,EAAkD;AAC9C;;;;AAIA,MAAI,OAAO5K,MAAP,KAAkB,QAAtB,EACI,OAAOA,MAAP;AACJ;;;;;AAIA,MAAI+C,CAAC,GAAGyH,eAAe,CAACxK,MAAD,EAAS4K,WAAW,CAAC7H,CAArB,CAAvB;AACA,MAAIG,CAAC,GAAGsH,eAAe,CAACxK,MAAD,EAAS4K,WAAW,CAAC1H,CAArB,CAAvB;AACA,SAAOH,CAAC,GAAG,IAAJ,GAAWG,CAAX,GAAe,GAAtB;AACH;;AACD,SAAS2H,gBAAT,CAA0B7K,MAA1B,EAAkC8K,YAAlC,EAAgDpN,KAAhD,EAAuDqN,SAAvD,EAAkE;AAC9D;AACA,MAAIC,MAAM,GAAG/Q,OAAO,CAACgK,KAAR,CAAcjE,MAAd,CAAb;AACA,MAAIiL,QAAQ,GAAGhR,OAAO,CAACiR,iBAAR,CAA0BlL,MAA1B,CAAf,CAH8D,CAI9D;;AACA,MAAImL,MAAM,GAAGzN,KAAK,CAACqF,CAAN,CAAQxI,KAAR,GAAgBwQ,SAAS,CAAChI,CAAvC;AACA,MAAIqI,MAAM,GAAG1N,KAAK,CAACwF,CAAN,CAAQ3I,KAAR,GAAgBwQ,SAAS,CAAC7H,CAAvC,CAN8D,CAO9D;;AACA8H,EAAAA,MAAM,CAAC,CAAD,CAAN,IAAaG,MAAb;AACAH,EAAAA,MAAM,CAAC,CAAD,CAAN,IAAaI,MAAb;AACA;;;;;;;AAMA,MAAIC,YAAY,GAAGjS,GAAG,CAAC+R,MAAD,EAASC,MAAT,EAAiB,GAAjB,CAAtB,CAhB8D,CAiB9D;;AACA,MAAI,OAAOJ,MAAM,CAAC,CAAD,CAAb,KAAqB,QAAzB,EACIA,MAAM,CAAC,CAAD,CAAN,IAAaK,YAAb,CAnB0D,CAoB9D;;AACA,MAAI,OAAOL,MAAM,CAAC,CAAD,CAAb,KAAqB,QAAzB,EACIA,MAAM,CAAC,CAAD,CAAN,IAAaK,YAAb;AACJ,SAAOJ,QAAQ,CAACD,MAAD,CAAf;AACH;;AACD,IAAIM,0BAA0B,GAAG;AAC7BC,EAAAA,OAAO,EAAEZ;AADoB,CAAjC;AAGA,IAAIa,oBAAoB,GAAG;AACvBnG,EAAAA,YAAY,EAAEzM,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK0S,0BAAL,CAAT,EAA2C;AAAEG,IAAAA,OAAO,EAAE,CACpE,qBADoE,EAEpE,sBAFoE,EAGpE,wBAHoE,EAIpE,yBAJoE;AAAX,GAA3C,CADC;AAOvBlG,EAAAA,mBAAmB,EAAE+F,0BAPE;AAQvB9F,EAAAA,oBAAoB,EAAE8F,0BARC;AASvB5F,EAAAA,sBAAsB,EAAE4F,0BATD;AAUvB7F,EAAAA,uBAAuB,EAAE6F,0BAVF;AAWvBI,EAAAA,SAAS,EAAE;AACPH,IAAAA,OAAO,EAAEV;AADF;AAXY,CAA3B;AAeA;;;;AAGA,SAASc,kBAAT,CAA4BC,UAA5B,EAAwC;AACpC,OAAK,IAAIzK,GAAT,IAAgByK,UAAhB,EAA4B;AACxBJ,IAAAA,oBAAoB,CAACrK,GAAD,CAApB,GAA4ByK,UAAU,CAACzK,GAAD,CAAtC;AACH;AACJ;;AAED,SAAS0K,oBAAT,CAA8BnO,KAA9B,EAAqCqN,SAArC,EAAgD;AAC5C,MAAIhI,CAAC,GAAGrF,KAAK,CAACqF,CAAN,CAAQa,SAAR,GAAoBmH,SAAS,CAAChI,CAAtC;AACA,MAAIG,CAAC,GAAGxF,KAAK,CAACwF,CAAN,CAAQU,SAAR,GAAoBmH,SAAS,CAAC7H,CAAtC;AACA,MAAI4D,MAAM,GAAGpJ,KAAK,CAACqF,CAAN,CAAQxI,KAArB;AACA,MAAIwM,MAAM,GAAGrJ,KAAK,CAACwF,CAAN,CAAQ3I,KAArB;AACA,SAAO,iBAAiBwI,CAAjB,GAAqB,MAArB,GAA8BG,CAA9B,GAAkC,eAAlC,GAAoD4D,MAApD,GAA6D,IAA7D,GAAoEC,MAApE,GAA6E,GAApF;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAAS+E,eAAT,CAAyB9L,MAAzB,EAAiC+L,KAAjC,EAAwCC,IAAxC,EAA8C7H,SAA9C,EAAyD8H,eAAzD,EAA0EvC,aAA1E,EAAyFjM,EAAzF,EAA6FyO,yBAA7F,EAAwHxO,KAAxH,EAA+HyO,UAA/H,EAA2IpB,SAA3I,EAAsJqB,SAAtJ,EAAiK;AAC7J,MAAIvC,0BAA0B,GAAGpM,EAAE,CAACoM,0BAApC;AAAA,MAAgEF,iBAAiB,GAAGlM,EAAE,CAACkM,iBAAvF;AAAA,MAA0GG,kBAAkB,GAAGrM,EAAE,CAACqM,kBAAlI,CAD6J,CAE7J;AACA;AACA;;AACAJ,EAAAA,aAAa,CAACS,MAAd,GAAuB,CAAvB,CAL6J,CAM7J;;AACA,MAAIkC,YAAY,GAAG,CAAC,CAACH,yBAArB;AACA,MAAII,kBAAkB,GAAG,CAAC,CAACJ,yBAA3B,CAR6J,CAS7J;;AACA,MAAIK,eAAe,GAAG,IAAtB;AACA;;;;;;AAKA,OAAK,IAAIpL,GAAT,IAAgBnB,MAAhB,EAAwB;AACpB,QAAIzD,KAAK,GAAGyD,MAAM,CAACmB,GAAD,CAAlB,CADoB,CAEpB;;AACA,QAAIqL,SAAS,GAAGhE,mBAAmB,CAACrH,GAAD,CAAnC;AACA,QAAIsL,WAAW,GAAGhE,cAAc,CAAClM,KAAD,EAAQiQ,SAAR,CAAhC;;AACA,QAAInD,eAAe,CAAClI,GAAD,CAAnB,EAA0B;AACtB;AACAkL,MAAAA,YAAY,GAAG,IAAf;AACAlI,MAAAA,SAAS,CAAChD,GAAD,CAAT,GAAiBsL,WAAjB;AACA/C,MAAAA,aAAa,CAACX,IAAd,CAAmB5H,GAAnB;AACA,UAAI,CAACoL,eAAL,EACI,SANkB,CAOtB;AACA;;AACA,UAAI7K,YAAY,GAAG8K,SAAS,CAACE,OAAV,KAAsB/K,SAAtB,GAAkC6K,SAAS,CAACE,OAA5C,GAAsD,CAAzE;AACA,UAAInQ,KAAK,KAAKmF,YAAd,EACI6K,eAAe,GAAG,KAAlB;AACP,KAZD,MAaK,IAAIhD,qBAAqB,CAACpI,GAAD,CAAzB,EAAgC;AACjC;AACA8K,MAAAA,eAAe,CAAC9K,GAAD,CAAf,GAAuBsL,WAAvB;AACAH,MAAAA,kBAAkB,GAAG,IAArB;AACH,KAJI,MAKA,IAAInL,GAAG,KAAK,WAAR,IAAuB,OAAO5E,KAAP,KAAiB,UAA5C,EAAwD;AACzD;AACA;AACA,UAAIoQ,MAAM,GAAGrC,aAAa,CAACnJ,GAAD,CAAb,GAAqB6K,IAArB,GAA4BD,KAAzC,CAHyD,CAIzD;AACA;;AACA,UAAIG,yBAAyB,IAAIV,oBAAoB,CAACrK,GAAD,CAArD,EAA4D;AACxD,YAAIyL,SAAS,GAAGpB,oBAAoB,CAACrK,GAAD,CAApB,CAA0BoK,OAA1B,CAAkChP,KAAlC,EAAyC6P,SAAzC,EAAoD1O,KAApD,EAA2DqN,SAA3D,CAAhB;AACA;;;;;AAIA,YAAIU,OAAO,GAAGD,oBAAoB,CAACrK,GAAD,CAApB,CAA0BsK,OAAxC;;AACA,YAAIA,OAAJ,EAAa;AACT,cAAIoB,GAAG,GAAGpB,OAAO,CAACtB,MAAlB;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,GAApB,EAAyBzC,CAAC,EAA1B,EAA8B;AAC1BuC,YAAAA,MAAM,CAAClB,OAAO,CAACrB,CAAD,CAAR,CAAN,GAAqBwC,SAArB;AACH;AACJ,SALD,MAMK;AACDD,UAAAA,MAAM,CAACxL,GAAD,CAAN,GAAcyL,SAAd;AACH;AACJ,OAhBD,MAiBK;AACDD,QAAAA,MAAM,CAACxL,GAAD,CAAN,GAAcsL,WAAd;AACH;AACJ;AACJ,GAlE4J,CAmE7J;;;AACA,MAAIJ,YAAY,IAAI1C,iBAApB,EAAuC;AACnC,QAAI,CAACuC,yBAAL,EAAgC;AAC5BH,MAAAA,KAAK,CAAC5H,SAAN,GAAkBsF,cAAc,CAACtF,SAAD,EAAYuF,aAAZ,EAA2BC,iBAA3B,EAA8C4C,eAA9C,EAA+D1C,0BAA/D,EAA2FC,kBAA3F,CAAhC;AACH,KAFD,MAGK;AACDiC,MAAAA,KAAK,CAAC5H,SAAN,GAAkB0H,oBAAoB,CAACM,UAAD,EAAapB,SAAb,CAAtC;AACA,UAAIpB,iBAAJ,EACIoC,KAAK,CAAC5H,SAAN,GAAkBwF,iBAAiB,CAACxF,SAAD,EAAY4H,KAAK,CAAC5H,SAAlB,CAAnC;AACP;AACJ,GA7E4J,CA8E7J;;;AACA,MAAImI,kBAAJ,EAAwB;AACpB,QAAI5E,OAAO,GAAGwE,yBAAyB,GACjCC,UAAU,CAACpJ,CAAX,CAAac,MAAb,GAAsB,GAAtB,GAA4B,GADK,GAEjCoI,eAAe,CAACvE,OAAhB,IAA2B,KAFjC;AAGA,QAAIC,OAAO,GAAGuE,yBAAyB,GACjCC,UAAU,CAACjJ,CAAX,CAAaW,MAAb,GAAsB,GAAtB,GAA4B,GADK,GAEjCoI,eAAe,CAACtE,OAAhB,IAA2B,KAFjC;AAGA,QAAIC,OAAO,GAAGqE,eAAe,CAACrE,OAAhB,IAA2B,GAAzC;AACAmE,IAAAA,KAAK,CAACE,eAAN,GAAwBvE,OAAO,GAAG,GAAV,GAAgBC,OAAhB,GAA0B,GAA1B,GAAgCC,OAAxD;AACH;AACJ;AAED;;;;;;;AAKA,SAASkF,SAAT,CAAmBpC,IAAnB,EAAyBqC,UAAzB,EAAqC;AACjCrC,EAAAA,IAAI,CAAC1H,GAAL,GAAW+J,UAAU,CAAC/J,GAAtB;AACA0H,EAAAA,IAAI,CAACzH,GAAL,GAAW8J,UAAU,CAAC9J,GAAtB;AACH;AACD;;;;;;;AAKA,SAAS+J,QAAT,CAAkBtJ,GAAlB,EAAuBuJ,SAAvB,EAAkC;AAC9BH,EAAAA,SAAS,CAACpJ,GAAG,CAACX,CAAL,EAAQkK,SAAS,CAAClK,CAAlB,CAAT;AACA+J,EAAAA,SAAS,CAACpJ,GAAG,CAACR,CAAL,EAAQ+J,SAAS,CAAC/J,CAAlB,CAAT;AACH;AACD;;;;;AAGA,SAASgK,UAAT,CAAoBC,KAApB,EAA2B5S,KAA3B,EAAkCuJ,WAAlC,EAA+C;AAC3C,MAAIsJ,kBAAkB,GAAGD,KAAK,GAAGrJ,WAAjC;AACA,MAAIuJ,MAAM,GAAG9S,KAAK,GAAG6S,kBAArB;AACA,SAAOtJ,WAAW,GAAGuJ,MAArB;AACH;AACD;;;;;AAGA,SAASC,eAAT,CAAyBH,KAAzB,EAAgCvJ,SAAhC,EAA2CrJ,KAA3C,EAAkDuJ,WAAlD,EAA+DyJ,QAA/D,EAAyE;AACrE,MAAIA,QAAQ,KAAK5L,SAAjB,EAA4B;AACxBwL,IAAAA,KAAK,GAAGD,UAAU,CAACC,KAAD,EAAQI,QAAR,EAAkBzJ,WAAlB,CAAlB;AACH;;AACD,SAAOoJ,UAAU,CAACC,KAAD,EAAQ5S,KAAR,EAAeuJ,WAAf,CAAV,GAAwCF,SAA/C;AACH;AACD;;;;;AAGA,SAAS4J,cAAT,CAAwB9C,IAAxB,EAA8B9G,SAA9B,EAAyCrJ,KAAzC,EAAgDuJ,WAAhD,EAA6DyJ,QAA7D,EAAuE;AACnE,MAAI3J,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAG,CAAZ;AAAgB;;AAC5C,MAAIrJ,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,IAAAA,KAAK,GAAG,CAAR;AAAY;;AACpCmQ,EAAAA,IAAI,CAAC1H,GAAL,GAAWsK,eAAe,CAAC5C,IAAI,CAAC1H,GAAN,EAAWY,SAAX,EAAsBrJ,KAAtB,EAA6BuJ,WAA7B,EAA0CyJ,QAA1C,CAA1B;AACA7C,EAAAA,IAAI,CAACzH,GAAL,GAAWqK,eAAe,CAAC5C,IAAI,CAACzH,GAAN,EAAWW,SAAX,EAAsBrJ,KAAtB,EAA6BuJ,WAA7B,EAA0CyJ,QAA1C,CAA1B;AACH;AACD;;;;;AAGA,SAASE,aAAT,CAAuB/J,GAAvB,EAA4BjG,EAA5B,EAAgC;AAC5B,MAAIsF,CAAC,GAAGtF,EAAE,CAACsF,CAAX;AAAA,MAAcG,CAAC,GAAGzF,EAAE,CAACyF,CAArB;AACAsK,EAAAA,cAAc,CAAC9J,GAAG,CAACX,CAAL,EAAQA,CAAC,CAACa,SAAV,EAAqBb,CAAC,CAACxI,KAAvB,EAA8BwI,CAAC,CAACe,WAAhC,CAAd;AACA0J,EAAAA,cAAc,CAAC9J,GAAG,CAACR,CAAL,EAAQA,CAAC,CAACU,SAAV,EAAqBV,CAAC,CAAC3I,KAAvB,EAA8B2I,CAAC,CAACY,WAAhC,CAAd;AACH;AACD;;;;;;;AAKA,SAAS4J,mBAAT,CAA6BC,KAA7B,EAAoCjD,IAApC,EAA0CkD,UAA1C,EAAsDnQ,EAAtD,EAA0D;AACtD,MAAI0D,GAAG,GAAG1D,EAAE,CAAC,CAAD,CAAZ;AAAA,MAAiBoQ,QAAQ,GAAGpQ,EAAE,CAAC,CAAD,CAA9B;AAAA,MAAmCqQ,SAAS,GAAGrQ,EAAE,CAAC,CAAD,CAAjD,CADsD,CAEtD;;AACAkQ,EAAAA,KAAK,CAAC3K,GAAN,GAAY0H,IAAI,CAAC1H,GAAjB;AACA2K,EAAAA,KAAK,CAAC1K,GAAN,GAAYyH,IAAI,CAACzH,GAAjB;AACA,MAAIa,WAAW,GAAG1K,GAAG,CAACsR,IAAI,CAAC1H,GAAN,EAAW0H,IAAI,CAACzH,GAAhB,EAAqB2K,UAAU,CAACE,SAAD,CAAV,IAAyB,GAA9C,CAArB,CALsD,CAMtD;;AACAN,EAAAA,cAAc,CAACG,KAAD,EAAQC,UAAU,CAACzM,GAAD,CAAlB,EAAyByM,UAAU,CAACC,QAAD,CAAnC,EAA+C/J,WAA/C,EAA4D8J,UAAU,CAACrT,KAAvE,CAAd;AACH;AACD;;;;;AAGA,IAAIwT,KAAK,GAAG,CAAC,GAAD,EAAM,QAAN,EAAgB,SAAhB,CAAZ;AACA,IAAIC,KAAK,GAAG,CAAC,GAAD,EAAM,QAAN,EAAgB,SAAhB,CAAZ;AACA;;;;AAGA,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCxK,GAAtC,EAA2CkK,UAA3C,EAAuD;AACnDF,EAAAA,mBAAmB,CAACQ,QAAQ,CAACnL,CAAV,EAAaW,GAAG,CAACX,CAAjB,EAAoB6K,UAApB,EAAgCG,KAAhC,CAAnB;AACAL,EAAAA,mBAAmB,CAACQ,QAAQ,CAAChL,CAAV,EAAaQ,GAAG,CAACR,CAAjB,EAAoB0K,UAApB,EAAgCI,KAAhC,CAAnB;AACH;AACD;;;;;AAGA,SAASG,gBAAT,CAA0BhB,KAA1B,EAAiCvJ,SAAjC,EAA4CrJ,KAA5C,EAAmDuJ,WAAnD,EAAgEyJ,QAAhE,EAA0E;AACtEJ,EAAAA,KAAK,IAAIvJ,SAAT;AACAuJ,EAAAA,KAAK,GAAGD,UAAU,CAACC,KAAD,EAAQ,IAAI5S,KAAZ,EAAmBuJ,WAAnB,CAAlB;;AACA,MAAIyJ,QAAQ,KAAK5L,SAAjB,EAA4B;AACxBwL,IAAAA,KAAK,GAAGD,UAAU,CAACC,KAAD,EAAQ,IAAII,QAAZ,EAAsBzJ,WAAtB,CAAlB;AACH;;AACD,SAAOqJ,KAAP;AACH;AACD;;;;;AAGA,SAASiB,eAAT,CAAyB1D,IAAzB,EAA+B9G,SAA/B,EAA0CrJ,KAA1C,EAAiDsJ,MAAjD,EAAyD0J,QAAzD,EAAmE;AAC/D,MAAI3J,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAG,CAAZ;AAAgB;;AAC5C,MAAIrJ,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,IAAAA,KAAK,GAAG,CAAR;AAAY;;AACpC,MAAIsJ,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,GAAT;AAAe;;AACxC,MAAIC,WAAW,GAAG1K,GAAG,CAACsR,IAAI,CAAC1H,GAAN,EAAW0H,IAAI,CAACzH,GAAhB,EAAqBY,MAArB,CAAH,GAAkCD,SAApD;AACA8G,EAAAA,IAAI,CAAC1H,GAAL,GAAWmL,gBAAgB,CAACzD,IAAI,CAAC1H,GAAN,EAAWY,SAAX,EAAsBrJ,KAAtB,EAA6BuJ,WAA7B,EAA0CyJ,QAA1C,CAA3B;AACA7C,EAAAA,IAAI,CAACzH,GAAL,GAAWkL,gBAAgB,CAACzD,IAAI,CAACzH,GAAN,EAAWW,SAAX,EAAsBrJ,KAAtB,EAA6BuJ,WAA7B,EAA0CyJ,QAA1C,CAA3B;AACH;AACD;;;;;;AAIA,SAASc,oBAAT,CAA8B3D,IAA9B,EAAoCkD,UAApC,EAAgDnQ,EAAhD,EAAoD;AAChD,MAAI0D,GAAG,GAAG1D,EAAE,CAAC,CAAD,CAAZ;AAAA,MAAiBoQ,QAAQ,GAAGpQ,EAAE,CAAC,CAAD,CAA9B;AAAA,MAAmCqQ,SAAS,GAAGrQ,EAAE,CAAC,CAAD,CAAjD;AACA2Q,EAAAA,eAAe,CAAC1D,IAAD,EAAOkD,UAAU,CAACzM,GAAD,CAAjB,EAAwByM,UAAU,CAACC,QAAD,CAAlC,EAA8CD,UAAU,CAACE,SAAD,CAAxD,EAAqEF,UAAU,CAACrT,KAAhF,CAAf;AACH;AACD;;;;;;AAIA,SAAS+T,mBAAT,CAA6B5K,GAA7B,EAAkCkK,UAAlC,EAA8C;AAC1CS,EAAAA,oBAAoB,CAAC3K,GAAG,CAACX,CAAL,EAAQ6K,UAAR,EAAoBG,KAApB,CAApB;AACAM,EAAAA,oBAAoB,CAAC3K,GAAG,CAACR,CAAL,EAAQ0K,UAAR,EAAoBI,KAApB,CAApB;AACH;AACD;;;;;;;;AAMA,SAASO,eAAT,CAAyB7K,GAAzB,EAA8B5C,QAA9B,EAAwC;AACpC,MAAI0N,UAAU,GAAG1N,QAAQ,CAACqJ,MAA1B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoE,UAApB,EAAgCpE,CAAC,EAAjC,EAAqC;AACjCqD,IAAAA,aAAa,CAAC/J,GAAD,EAAM5C,QAAQ,CAACsJ,CAAD,CAAR,CAAY1M,KAAlB,CAAb;AACH;AACJ;;AAED,IAAI+Q,aAAa,GAAGpV,KAAK,CAAC,CAAD,EAAI,CAAJ,CAAzB;AACA;;;;AAGA,SAASqV,MAAT,CAAgBnS,KAAhB,EAAuBoS,MAAvB,EAA+BC,WAA/B,EAA4C;AACxC,MAAID,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,CAAT;AAAa;;AACtC,MAAIC,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,IAAAA,WAAW,GAAG,IAAd;AAAqB;;AACnD,SAAOtV,QAAQ,CAACiD,KAAD,EAAQoS,MAAR,CAAR,GAA0BC,WAAjC;AACH;AACD;;;;;AAGA,SAASC,aAAT,CAAuBC,MAAvB,EAA+BH,MAA/B,EAAuC9K,MAAvC,EAA+C;AAC3C,MAAIkL,WAAW,GAAG3V,GAAG,CAAC0V,MAAM,CAAC9L,GAAR,EAAa8L,MAAM,CAAC7L,GAApB,EAAyBY,MAAzB,CAArB;AACA,MAAImL,WAAW,GAAG5V,GAAG,CAACuV,MAAM,CAAC3L,GAAR,EAAa2L,MAAM,CAAC1L,GAApB,EAAyBY,MAAzB,CAArB;AACA,SAAOmL,WAAW,GAAGD,WAArB;AACH;AACD;;;;;;AAIA,SAASE,UAAT,CAAoBH,MAApB,EAA4BH,MAA5B,EAAoC;AAChC,MAAI9K,MAAM,GAAG,GAAb;AACA,MAAIqL,YAAY,GAAGJ,MAAM,CAAC7L,GAAP,GAAa6L,MAAM,CAAC9L,GAAvC;AACA,MAAImM,YAAY,GAAGR,MAAM,CAAC1L,GAAP,GAAa0L,MAAM,CAAC3L,GAAvC;;AACA,MAAImM,YAAY,GAAGD,YAAnB,EAAiC;AAC7BrL,IAAAA,MAAM,GAAGtK,QAAQ,CAACoV,MAAM,CAAC3L,GAAR,EAAa2L,MAAM,CAAC1L,GAAP,GAAaiM,YAA1B,EAAwCJ,MAAM,CAAC9L,GAA/C,CAAjB;AACH,GAFD,MAGK,IAAIkM,YAAY,GAAGC,YAAnB,EAAiC;AAClCtL,IAAAA,MAAM,GAAGtK,QAAQ,CAACuV,MAAM,CAAC9L,GAAR,EAAa8L,MAAM,CAAC7L,GAAP,GAAakM,YAA1B,EAAwCR,MAAM,CAAC3L,GAA/C,CAAjB;AACH;;AACD,SAAOyL,aAAa,CAAC5K,MAAD,CAApB;AACH;AACD;;;;;;;;AAMA,SAASuL,eAAT,CAAyB1R,KAAzB,EAAgCoR,MAAhC,EAAwCH,MAAxC,EAAgD9K,MAAhD,EAAwD;AACpD,MAAIqL,YAAY,GAAGJ,MAAM,CAAC7L,GAAP,GAAa6L,MAAM,CAAC9L,GAAvC;AACA,MAAImM,YAAY,GAAGR,MAAM,CAAC1L,GAAP,GAAa0L,MAAM,CAAC3L,GAAvC;AACAtF,EAAAA,KAAK,CAACmG,MAAN,GAAeA,MAAM,KAAKlC,SAAX,GAAuBsN,UAAU,CAACH,MAAD,EAASH,MAAT,CAAjC,GAAoD9K,MAAnE;AACAnG,EAAAA,KAAK,CAACoG,WAAN,GAAoB1K,GAAG,CAAC0V,MAAM,CAAC9L,GAAR,EAAa8L,MAAM,CAAC7L,GAApB,EAAyBvF,KAAK,CAACmG,MAA/B,CAAvB;AACAnG,EAAAA,KAAK,CAACnD,KAAN,GAAc4U,YAAY,GAAGD,YAA7B;AACA,MAAIR,MAAM,CAAChR,KAAK,CAACnD,KAAP,EAAc,CAAd,EAAiB,MAAjB,CAAV,EACImD,KAAK,CAACnD,KAAN,GAAc,CAAd;AACJmD,EAAAA,KAAK,CAACkG,SAAN,GAAkBiL,aAAa,CAACC,MAAD,EAASH,MAAT,EAAiBjR,KAAK,CAACmG,MAAvB,CAA/B;AACA,MAAI6K,MAAM,CAAChR,KAAK,CAACkG,SAAP,CAAV,EACIlG,KAAK,CAACkG,SAAN,GAAkB,CAAlB;AACP;AACD;;;;;;;;AAMA,SAASyL,cAAT,CAAwB3R,KAAxB,EAA+BoR,MAA/B,EAAuCH,MAAvC,EAA+C9K,MAA/C,EAAuD;AACnDuL,EAAAA,eAAe,CAAC1R,KAAK,CAACqF,CAAP,EAAU+L,MAAM,CAAC/L,CAAjB,EAAoB4L,MAAM,CAAC5L,CAA3B,EAA8Bc,MAA9B,CAAf;AACAuL,EAAAA,eAAe,CAAC1R,KAAK,CAACwF,CAAP,EAAU4L,MAAM,CAAC5L,CAAjB,EAAoByL,MAAM,CAACzL,CAA3B,EAA8BW,MAA9B,CAAf;AACH;AACD;;;;;AAGA,SAASyL,eAAT,CAAyBvE,SAAzB,EAAoCwE,eAApC,EAAqDC,WAArD,EAAkE;AAC9DzE,EAAAA,SAAS,CAAChI,CAAV,GAAcwM,eAAe,CAACxM,CAAhB,GAAoByM,WAAW,CAACzM,CAAZ,CAAcxI,KAAhD;AACAwQ,EAAAA,SAAS,CAAC7H,CAAV,GAAcqM,eAAe,CAACrM,CAAhB,GAAoBsM,WAAW,CAACtM,CAAZ,CAAc3I,KAAhD;AACH,C,CAED;;;AACA,SAASkV,QAAT,CAAkBC,OAAlB,EAA2B;AACvB,SAAO,CAACA,OAAO,CAAC,GAAD,CAAR,EAAeA,OAAO,CAAC,GAAD,CAAtB,CAAP;AACH;;AAED,IAAIC,iBAAiB,GAAG,UAAU1S,CAAV,EAAa;AACjC,SAAO2S,KAAK,CAACC,OAAN,CAAc5S,CAAd,CAAP;AACH,CAFD;;AAIA,IAAI6S,iBAAiB,GAAG,YAAY;AAAE,SAAQ;AAC1C3H,IAAAA,IAAI,EAAE,QADoC;AAE1C4H,IAAAA,SAAS,EAAE,GAF+B;AAG1CC,IAAAA,OAAO,EAAE,EAHiC;AAI1CC,IAAAA,SAAS,EAAE,GAJ+B;AAK1CC,IAAAA,SAAS,EAAE;AAL+B,GAAR;AAMjC,CANL;;AAOA,IAAIC,gBAAgB,GAAG,UAAUC,EAAV,EAAc;AAAE,SAAQ;AAC3CjI,IAAAA,IAAI,EAAE,QADqC;AAE3C4H,IAAAA,SAAS,EAAE,GAFgC;AAG3CC,IAAAA,OAAO,EAAEI,EAAE,KAAK,CAAP,GAAW,GAAX,GAAiB;AAHiB,GAAR;AAIlC,CAJL;;AAKA,IAAIC,WAAW,GAAG,YAAY;AAAE,SAAQ;AACpCC,IAAAA,IAAI,EAAE,QAD8B;AAEpCC,IAAAA,QAAQ,EAAE;AAF0B,GAAR;AAG3B,CAHL;;AAIA,IAAIzV,SAAS,GAAG,UAAUmF,MAAV,EAAkB;AAAE,SAAQ;AACxCkI,IAAAA,IAAI,EAAE,WADkC;AAExCoI,IAAAA,QAAQ,EAAE,GAF8B;AAGxCtQ,IAAAA,MAAM,EAAEA;AAHgC,GAAR;AAI/B,CAJL;;AAKA,IAAIuQ,kBAAkB,GAAG;AACrBzN,EAAAA,CAAC,EAAE+M,iBADkB;AAErB5M,EAAAA,CAAC,EAAE4M,iBAFkB;AAGrBvI,EAAAA,CAAC,EAAEuI,iBAHkB;AAIrBpJ,EAAAA,MAAM,EAAEoJ,iBAJa;AAKrBnJ,EAAAA,OAAO,EAAEmJ,iBALY;AAMrBlJ,EAAAA,OAAO,EAAEkJ,iBANY;AAOrBjJ,EAAAA,OAAO,EAAEiJ,iBAPY;AAQrBhJ,EAAAA,MAAM,EAAEqJ,gBARa;AASrBpJ,EAAAA,MAAM,EAAEoJ,gBATa;AAUrB5V,EAAAA,KAAK,EAAE4V,gBAVc;AAWrB1I,EAAAA,OAAO,EAAE4I,WAXY;AAYrB9L,EAAAA,eAAe,EAAE8L,WAZI;AAarBrW,EAAAA,KAAK,EAAEqW,WAbc;AAcrB3D,EAAAA,OAAO,EAAEyD;AAdY,CAAzB;;AAgBA,IAAIM,oBAAoB,GAAG,UAAUC,QAAV,EAAoBN,EAApB,EAAwB;AAC/C,MAAIO,iBAAJ;;AACA,MAAIhB,iBAAiB,CAACS,EAAD,CAArB,EAA2B;AACvBO,IAAAA,iBAAiB,GAAG7V,SAApB;AACH,GAFD,MAGK;AACD6V,IAAAA,iBAAiB,GACbH,kBAAkB,CAACE,QAAD,CAAlB,IAAgCF,kBAAkB,CAAC9D,OADvD;AAEH;;AACD,SAAO9T,QAAQ,CAAC;AAAEwX,IAAAA,EAAE,EAAEA;AAAN,GAAD,EAAaO,iBAAiB,CAACP,EAAD,CAA9B,CAAf;AACH,CAVD;AAYA;;;;;;;;;;;;;;;;;;;AAiBA,IAAIQ,IAAI,GAAG,UAAUnT,EAAV,EAAc;AACrB,MAAI2S,EAAE,GAAG3S,EAAE,CAAC2S,EAAZ;AAAA,MAAgBG,QAAQ,GAAG9S,EAAE,CAAC8S,QAA9B;AACA,SAAO7V,MAAM,CAAC,UAAU+C,EAAV,EAAc;AACxB,QAAI4C,MAAM,GAAG5C,EAAE,CAAC4C,MAAhB;AAAA,QAAwBwQ,QAAQ,GAAGpT,EAAE,CAACoT,QAAtC;AACAxQ,IAAAA,MAAM,CAAC+P,EAAD,CAAN;AACAG,IAAAA,QAAQ,GAAG5V,KAAK,CAAC4V,QAAD,CAAL,CAAgBrR,KAAhB,CAAsB;AAAE2R,MAAAA,QAAQ,EAAEA;AAAZ,KAAtB,CAAH,GAAmDA,QAAQ,EAAnE;AACH,GAJY,CAAb;AAKH,CAPD;;AASA,IAAIC,0BAA0B,GAAG,UAAUC,UAAV,EAAsB;AACnD,MAAInB,KAAK,CAACC,OAAN,CAAckB,UAAd,CAAJ,EAA+B;AAC3B;AACAlX,IAAAA,SAAS,CAACkX,UAAU,CAAC5G,MAAX,KAAsB,CAAvB,EAA0B,yDAA1B,CAAT;AACA,QAAI6G,EAAE,GAAGD,UAAU,CAAC,CAAD,CAAnB;AAAA,QAAwBE,EAAE,GAAGF,UAAU,CAAC,CAAD,CAAvC;AAAA,QAA4CG,EAAE,GAAGH,UAAU,CAAC,CAAD,CAA3D;AAAA,QAAgEI,EAAE,GAAGJ,UAAU,CAAC,CAAD,CAA/E;AACA,WAAO7V,WAAW,CAAC8V,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CAAlB;AACH,GALD,MAMK,IAAI,OAAOJ,UAAP,KAAsB,QAA1B,EAAoC;AACrC;AACAlX,IAAAA,SAAS,CAACoB,YAAY,CAAC8V,UAAD,CAAZ,KAA6BpP,SAA9B,EAAyC,0BAA0BoP,UAA1B,GAAuC,GAAhF,CAAT;AACA,WAAO9V,YAAY,CAAC8V,UAAD,CAAnB;AACH;;AACD,SAAOA,UAAP;AACH,CAbD;;AAcA,IAAIK,aAAa,GAAG,UAAUd,IAAV,EAAgB;AAChC,SAAOV,KAAK,CAACC,OAAN,CAAcS,IAAd,KAAuB,OAAOA,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAjD;AACH,CAFD;;AAIA,IAAIe,mBAAmB,GAAG,UAAUpU,CAAV,EAAa;AACnC,SAAOA,CAAC,CAACZ,cAAF,CAAiB,UAAjB,KAAgCY,CAAC,CAACZ,cAAF,CAAiB,aAAjB,CAAvC;AACH,CAFD;AAIA;;;;;;;;;;;AASA,IAAIiV,YAAY,GAAG,UAAUnQ,GAAV,EAAe5E,KAAf,EAAsB;AACrC;AACA,MAAI4E,GAAG,KAAK,QAAZ,EACI,OAAO,KAAP,CAHiC,CAIrC;AACA;AACA;;AACA,MAAI,OAAO5E,KAAP,KAAiB,QAAjB,IAA6BqT,KAAK,CAACC,OAAN,CAActT,KAAd,CAAjC,EACI,OAAO,IAAP;;AACJ,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B;AAC7BtC,EAAAA,OAAO,CAAC+J,IAAR,CAAazH,KAAb,CADA,IACuB;AACvB,GAACA,KAAK,CAACgO,UAAN,CAAiB,MAAjB,CAFL,CAE8B;AAF9B,IAGE;AACE,aAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH,CAhBD;AAkBA;;;;;;;;AAMA,IAAIgH,qBAAqB,GAAG,UAAUC,OAAV,EAAmB;AAAE,SAAOA,OAAO,GAAG,IAAjB;AAAwB,CAAzE;;AAEA,IAAIC,WAAW,GAAG;AAAE7W,EAAAA,KAAK,EAAEA,KAAT;AAAgBC,EAAAA,MAAM,EAAEA,MAAxB;AAAgCC,EAAAA,SAAS,EAAEC,WAA3C;AAAwDC,EAAAA,OAAO,EAAEA,OAAjE;AAA0E4V,EAAAA,IAAI,EAAEA;AAAhF,CAAlB;AACA,IAAIc,sBAAsB,GAAG;AACzB9W,EAAAA,KAAK,EAAE,UAAU+W,IAAV,EAAgB;AACnB,QAAIA,IAAI,CAACrB,IAAT,EAAe;AACX,UAAIA,IAAI,GAAGc,aAAa,CAACO,IAAI,CAACrB,IAAN,CAAb,GAA2BqB,IAAI,CAACrB,IAAL,CAAU,CAAV,CAA3B,GAA0CqB,IAAI,CAACrB,IAA1D;AACAqB,MAAAA,IAAI,CAACrB,IAAL,GAAYQ,0BAA0B,CAACR,IAAD,CAAtC;AACH;;AACD,WAAOqB,IAAP;AACH,GAPwB;AAQzB7W,EAAAA,SAAS,EAAE,UAAU2C,EAAV,EAAc;AACrB,QAAImU,IAAI,GAAGnU,EAAE,CAACmU,IAAd;AAAA,QAAoBxB,EAAE,GAAG3S,EAAE,CAAC2S,EAA5B;AAAA,QAAgCyB,QAAQ,GAAGpU,EAAE,CAACoU,QAA9C;AAAA,QAAwDF,IAAI,GAAG7Y,MAAM,CAAC2E,EAAD,EAAK,CAAC,MAAD,EAAS,IAAT,EAAe,UAAf,CAAL,CAArE;;AACA,QAAIkU,IAAI,CAAC1R,MAAL,IAAe0R,IAAI,CAAC1R,MAAL,CAAY,CAAZ,MAAmB,IAAtC,EAA4C;AACxC,UAAIA,MAAM,GAAGpH,cAAc,CAAC8Y,IAAI,CAAC1R,MAAN,CAA3B;;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY2R,IAAZ;AACAD,MAAAA,IAAI,CAAC1R,MAAL,GAAcA,MAAd;AACH;;AACD,QAAI0R,IAAI,CAACrB,IAAT,EAAe;AACXqB,MAAAA,IAAI,CAACG,OAAL,GAAeV,aAAa,CAACO,IAAI,CAACrB,IAAN,CAAb,GACTqB,IAAI,CAACrB,IAAL,CAAUyB,GAAV,CAAcjB,0BAAd,CADS,GAETA,0BAA0B,CAACa,IAAI,CAACrB,IAAN,CAFhC;AAGH;;AACDqB,IAAAA,IAAI,CAACrB,IAAL,GAAY9W,MAAZ;AACA,WAAOmY,IAAP;AACH;AAtBwB,CAA7B;;AAwBA,IAAIK,mBAAmB,GAAG,UAAUvU,EAAV,EAAc;AACpC,MAAIwU,IAAI,GAAGxU,EAAE,CAACwU,IAAd;AAAA,MAAoBtX,KAAK,GAAG8C,EAAE,CAAC9C,KAA/B;AAAA,MAAsCuX,aAAa,GAAGzU,EAAE,CAACyU,aAAzD;AAAA,MAAwEC,eAAe,GAAG1U,EAAE,CAAC0U,eAA7F;AAAA,MAA8GC,gBAAgB,GAAG3U,EAAE,CAAC2U,gBAApI;AAAA,MAAsJC,UAAU,GAAGvZ,MAAM,CAAC2E,EAAD,EAAK,CAAC,MAAD,EAAS,OAAT,EAAkB,eAAlB,EAAmC,iBAAnC,EAAsD,kBAAtD,CAAL,CAAzK;;AACA,SAAO6U,MAAM,CAACC,IAAP,CAAYF,UAAZ,EAAwBlI,MAA/B;AACH,CAHD;;AAIA,IAAIqI,uBAAuB,GAAG,UAAUrR,GAAV,EAAeiP,EAAf,EAAmBqC,oBAAnB,EAAyC;AACnE,MAAI9X,KAAK,GAAG8X,oBAAoB,GAAGA,oBAAoB,CAAC9X,KAAxB,GAAgC,CAAhE,CADmE,CAEnE;AACA;AACA;;AACA,MAAI8X,oBAAoB,KAAK9Q,SAAzB,IACA,CAACqQ,mBAAmB,CAACS,oBAAD,CADxB,EACgD;AAC5C,WAAO7Z,QAAQ,CAAC;AAAE+B,MAAAA,KAAK,EAAEA;AAAT,KAAD,EAAmB8V,oBAAoB,CAACtP,GAAD,EAAMiP,EAAN,CAAvC,CAAf;AACH;;AACD,MAAIsC,yBAAyB,GAAGD,oBAAoB,CAACtR,GAAD,CAApB,IAC5BsR,oBAAoB,CAAC/F,OADO,IAE5B+F,oBAFJ;;AAGA,MAAIC,yBAAyB,CAACvK,IAA1B,KAAmC,KAAvC,EAA8C;AAC1C,WAAO;AACHxN,MAAAA,KAAK,EAAE+X,yBAAyB,CAACrW,cAA1B,CAAyC,OAAzC,IACDqW,yBAAyB,CAAC/X,KADzB,GAEDA,KAHH;AAIHyV,MAAAA,EAAE,EAAET,iBAAiB,CAACS,EAAD,CAAjB,GACEA,EAAE,CAACA,EAAE,CAACjG,MAAH,GAAY,CAAb,CADJ,GAEEiG,EANH;AAOHjI,MAAAA,IAAI,EAAE;AAPH,KAAP;AASH,GAVD,MAWK,IAAIwH,iBAAiB,CAACS,EAAD,CAArB,EAA2B;AAC5B,WAAOxX,QAAQ,CAACA,QAAQ,CAAC;AAAEqH,MAAAA,MAAM,EAAEmQ,EAAV;AAAcG,MAAAA,QAAQ,EAAE,GAAxB;AAA6B5V,MAAAA,KAAK,EAAEA,KAApC;AAA2C2V,MAAAA,IAAI,EAAE;AAAjD,KAAD,EAA8DoC,yBAA9D,CAAT,EAAmG;AAC9G;AACAvK,MAAAA,IAAI,EAAE;AAFwG,KAAnG,CAAf;AAGH,GAJI,MAKA;AACD,WAAOvP,QAAQ,CAAC;AAAEuP,MAAAA,IAAI,EAAE,OAAR;AAAiBiI,MAAAA,EAAE,EAAEA,EAArB;AACZzV,MAAAA,KAAK,EAAEA;AADK,KAAD,EACK+X,yBADL,CAAf;AAEH;AACJ,CAhCD;;AAiCA,IAAIC,iBAAiB,GAAG,UAAUxK,IAAV,EAAgBwJ,IAAhB,EAAsB;AAC1C,SAAOD,sBAAsB,CAACvJ,IAAD,CAAtB,GACDuJ,sBAAsB,CAACvJ,IAAD,CAAtB,CAA6BwJ,IAA7B,CADC,GAEDA,IAFN;AAGH,CAJD;;AAKA,IAAIiB,YAAY,GAAG,UAAUzR,GAAV,EAAe5E,KAAf,EAAsBoS,MAAtB,EAA8B0D,UAA9B,EAA0C;AACzD,MAAIxO,MAAM,GAAGtH,KAAK,CAACwC,GAAN,EAAb;AACA,MAAI8T,kBAAkB,GAAGvB,YAAY,CAACnQ,GAAD,EAAM0C,MAAN,CAArC;AACA,MAAIiP,kBAAkB,GAAGxB,YAAY,CAACnQ,GAAD,EAAMwN,MAAN,CAArC,CAHyD,CAIzD;AACA;;AACA7U,EAAAA,OAAO,CAAC+Y,kBAAkB,KAAKC,kBAAxB,EAA4C,+BAA+B3R,GAA/B,GAAqC,UAArC,GAAkD0C,MAAlD,GAA2D,UAA3D,GAAwE8K,MAAxE,GAAiF,MAAjF,GAA0F9K,MAA1F,GAAmG,6DAAnG,GAAmKA,MAAnK,GAA4K,4BAA5K,GAA2M8K,MAA3M,GAAoN,4BAAhQ,CAAP,CANyD,CAOzD;;AACA,MAAIlR,EAAE,GAAG+U,uBAAuB,CAACrR,GAAD,EAAMwN,MAAN,EAAc0D,UAAd,CAAhC;AAAA,MAA2DU,EAAE,GAAGtV,EAAE,CAAC0K,IAAnE;AAAA,MAAyEA,IAAI,GAAG4K,EAAE,KAAK,KAAK,CAAZ,GAAgB,OAAhB,GAA0BA,EAA1G;AAAA,MAA8GN,oBAAoB,GAAG3Z,MAAM,CAAC2E,EAAD,EAAK,CAAC,MAAD,CAAL,CAA3I,CARyD,CASzD;;;AACA,MAAIuV,aAAa,GAAGH,kBAAkB,IAAIC,kBAAtB,GACdrB,WAAW,CAACtJ,IAAD,CADG,GAEdyI,IAFN;AAGA,MAAIe,IAAI,GAAGgB,iBAAiB,CAACxK,IAAD,EAAOvP,QAAQ,CAAC;AAAEgZ,IAAAA,IAAI,EAAE/N,MAAR;AAAgBgO,IAAAA,QAAQ,EAAEtV,KAAK,CAAC0C,WAAN;AAA1B,GAAD,EAAkDwT,oBAAlD,CAAf,CAA5B,CAbyD,CAczD;;AACA,MAAIpB,mBAAmB,CAACM,IAAD,CAAvB,EAA+B;AAC3B,QAAIA,IAAI,CAACpB,QAAT,EAAmB;AACfoB,MAAAA,IAAI,CAACpB,QAAL,GAAgBgB,qBAAqB,CAACI,IAAI,CAACpB,QAAN,CAArC;AACH;;AACD,QAAIoB,IAAI,CAACsB,WAAT,EAAsB;AAClBtB,MAAAA,IAAI,CAACsB,WAAL,GAAmB1B,qBAAqB,CAACI,IAAI,CAACsB,WAAN,CAAxC;AACH;AACJ;;AACD,SAAO,CAACD,aAAD,EAAgBrB,IAAhB,CAAP;AACH,CAxBD;AAyBA;;;;;;;AAKA,SAASuB,cAAT,CAAwB/R,GAAxB,EAA6B5E,KAA7B,EAAoCoS,MAApC,EAA4ClR,EAA5C,EAAgD;AAC5C,MAAIA,EAAE,KAAK,KAAK,CAAhB,EAAmB;AAAEA,IAAAA,EAAE,GAAG,EAAL;AAAU;;AAC/B,MAAIsV,EAAE,GAAGtV,EAAE,CAAC9C,KAAZ;AAAA,MAAmBwY,OAAO,GAAGJ,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAAjD;AAAA,MAAqDV,UAAU,GAAGvZ,MAAM,CAAC2E,EAAD,EAAK,CAAC,OAAD,CAAL,CAAxE;;AACA,SAAOlB,KAAK,CAAC2C,KAAN,CAAY,UAAU2R,QAAV,EAAoB;AACnC,QAAIuC,eAAJ;;AACA,QAAI3V,EAAE,GAAGmV,YAAY,CAACzR,GAAD,EAAM5E,KAAN,EAAaoS,MAAb,EAAqB0D,UAArB,CAArB;AAAA,QAAuDgB,gBAAgB,GAAG5V,EAAE,CAAC,CAAD,CAA5E;AAAA,QAAiFsV,EAAE,GAAGtV,EAAE,CAAC,CAAD,CAAxF;AAAA,QAA6F6V,UAAU,GAAGP,EAAE,CAACpY,KAA7G;AAAA,QAAoH4Y,OAAO,GAAGza,MAAM,CAACia,EAAD,EAAK,CAAC,OAAD,CAAL,CAApI;;AACA,QAAIO,UAAU,KAAK3R,SAAnB,EAA8B;AAC1BwR,MAAAA,OAAO,GAAGG,UAAV;AACH;;AACD,QAAIE,OAAO,GAAG,YAAY;AACtB,UAAIrU,SAAS,GAAGkU,gBAAgB,CAACE,OAAD,CAAhC,CADsB,CAEtB;;AACAH,MAAAA,eAAe,GAAGjU,SAAS,CAACD,KAAV,CAAgB;AAC9BmB,QAAAA,MAAM,EAAE,UAAUpD,CAAV,EAAa;AAAE,iBAAOV,KAAK,CAACyB,GAAN,CAAUf,CAAV,CAAP;AAAsB,SADf;AAE9B4T,QAAAA,QAAQ,EAAEA;AAFoB,OAAhB,CAAlB;AAIH,KAPD,CANmC,CAcnC;AACA;;;AACA,QAAIsC,OAAJ,EAAa;AACTC,MAAAA,eAAe,GAAGzY,KAAK,CAAC4W,qBAAqB,CAAC4B,OAAD,CAAtB,CAAL,CAAsCjU,KAAtC,CAA4C;AAC1D2R,QAAAA,QAAQ,EAAE2C;AADgD,OAA5C,CAAlB;AAGH,KAJD,MAKK;AACDA,MAAAA,OAAO;AACV;;AACD,WAAO,YAAY;AACf,UAAIJ,eAAJ,EACIA,eAAe,CAAChU,IAAhB;AACP,KAHD;AAIH,GA5BM,CAAP;AA6BH;AAED;;;;;;;;;;;AASA,SAASqU,cAAT,CAAwBhT,OAAxB,EAAiCiT,kBAAjC,EAAqD;AACjD,MAAIhQ,GAAG,GAAGjD,OAAO,CAACkT,qBAAR,EAAV;AACA,SAAOjR,2BAA2B,CAACU,oBAAoB,CAACM,GAAD,EAAMgQ,kBAAN,CAArB,CAAlC;AACH;AAED;;;;;AAGA,IAAIE,iBAAiB;AAAG;AAAe,UAAUC,MAAV,EAAkB;AACrD9a,EAAAA,SAAS,CAAC6a,iBAAD,EAAoBC,MAApB,CAAT;;AACA,WAASD,iBAAT,GAA6B;AACzB,QAAIhX,KAAK,GAAGiX,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACC,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;AACA;;;;;AAGAnX,IAAAA,KAAK,CAACoX,aAAN,GAAsB;AAClBnK,MAAAA,0BAA0B,EAAE,IADV;AAElBC,MAAAA,kBAAkB,EAAE;AAFF,KAAtB;AAIA;;;;;AAIAlN,IAAAA,KAAK,CAACmP,KAAN,GAAc,EAAd;AACA;;;;;;AAKAnP,IAAAA,KAAK,CAACqX,UAAN,GAAmB,EAAnB;AACA;;;;;AAIArX,IAAAA,KAAK,CAACoP,IAAN,GAAa,EAAb;AACA;;;;;AAIApP,IAAAA,KAAK,CAACuH,SAAN,GAAkB,EAAlB;AACA;;;;;AAIAvH,IAAAA,KAAK,CAACqP,eAAN,GAAwB,EAAxB;AACA;;;;;AAIArP,IAAAA,KAAK,CAAC8M,aAAN,GAAsB,EAAtB;AACA9M,IAAAA,KAAK,CAACwD,MAAN,GAAexD,KAAK,CAACoX,aAArB;AACA;;;;;;AAKApX,IAAAA,KAAK,CAACsP,yBAAN,GAAkC,KAAlC;AACA;;;;;AAIAtP,IAAAA,KAAK,CAACsX,qBAAN,GAA8B,IAAIzV,GAAJ,EAA9B;AACA;;;;;AAIA7B,IAAAA,KAAK,CAACuX,qBAAN,GAA8B,KAA9B;AACA;;;;;;;AAMAvX,IAAAA,KAAK,CAACwX,cAAN,GAAuB5Q,OAAO,EAA9B;AACA;;;;;;;;AAOA5G,IAAAA,KAAK,CAACmO,SAAN,GAAkB;AAAEhI,MAAAA,CAAC,EAAE,CAAL;AAAQG,MAAAA,CAAC,EAAE;AAAX,KAAlB;AACA;;;;;;;;;AAQAtG,IAAAA,KAAK,CAACc,KAAN,GAAcA,KAAK,EAAnB;AACA;;;;;;;;AAOAd,IAAAA,KAAK,CAACuP,UAAN,GAAmBzO,KAAK,EAAxB;AACA;;;;AAGAd,IAAAA,KAAK,CAACyX,uBAAN,GAAgC;AAC5BtR,MAAAA,CAAC,EAAE,YAAY,CAAG,CADU;AAE5BG,MAAAA,CAAC,EAAE,YAAY,CAAG;AAFU,KAAhC;AAIAtG,IAAAA,KAAK,CAAC0X,iBAAN,GAA0B,KAA1B;AACA;;;;AAGA1X,IAAAA,KAAK,CAAC2X,YAAN,GAAqB;AACjBxR,MAAAA,CAAC,EAAEnD,WAAW,CAAC,CAAD,CADG;AAEjBsD,MAAAA,CAAC,EAAEtD,WAAW,CAAC,CAAD;AAFG,KAArB;;AAIAhD,IAAAA,KAAK,CAACuF,iBAAN,GAA0B,YAAY;AAClCvF,MAAAA,KAAK,CAACsP,yBAAN,IAAmCtP,KAAK,CAAC8G,GAAzC,IAAgD9G,KAAK,CAAC4X,YAAN,EAAhD;AACA;;;;;;;AAMA5X,MAAAA,KAAK,CAACmD,QAAN,CAAezC,OAAf,CAAuBmX,qBAAvB;AACH,KATD;;AAUA,WAAO7X,KAAP;AACH;AACD;;;;;AAGAgX,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BqD,WAA5B,GAA0C,UAAUH,GAAV,EAAe;AACrD0S,IAAAA,MAAM,CAAC5V,SAAP,CAAiBqD,WAAjB,CAA6BoT,IAA7B,CAAkC,IAAlC,EAAwCvT,GAAxC;;AACA,WAAO,KAAK6K,IAAL,CAAU7K,GAAV,CAAP;AACA,WAAO,KAAK4K,KAAL,CAAW5K,GAAX,CAAP;AACH,GAJD;AAKA;;;;;;;AAKAyS,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B0W,KAA5B,GAAoC,YAAY;AAC5C,SAAK5I,KAAL,GAAa,EAAb;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAK7H,SAAL,GAAiB,EAAjB;AACH,GAJD;;AAKAyP,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B8D,YAA5B,GAA2C,UAAU3B,MAAV,EAAkB;AACzD,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,SAAKA,MAAL,GAAcxH,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK,KAAKob,aAAV,CAAT,EAAmC5T,MAAnC,CAAtB;AACH,GAHD;AAIA;;;;;AAGAwT,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B2W,IAA5B,GAAmC,UAAUzT,GAAV,EAAe;AAC9C,WAAO,KAAK0T,gBAAL,GAAwB1T,GAAxB,KAAgC,CAAvC;AACH,GAFD;AAGA;;;;;;;AAKAyS,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B6W,eAA5B,GAA8C,UAAU3T,GAAV,EAAe;AACzD,QAAIkI,eAAe,CAAClI,GAAD,CAAnB,EAA0B;AACtB,UAAI4T,gBAAgB,GAAGvM,mBAAmB,CAACrH,GAAD,CAA1C;AACA,aAAO4T,gBAAgB,GAAGA,gBAAgB,CAACrI,OAAjB,IAA4B,CAA/B,GAAmC,CAA1D;AACH,KAHD,MAIK;AACD,aAAO,KAAKkI,IAAL,CAAUzT,GAAV,CAAP;AACH;AACJ,GARD;;AASAyS,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B+W,sBAA5B,GAAqD,YAAY;AAC7D,SAAK9I,yBAAL,GAAiC,IAAjC;AACH,GAFD;;AAGA0H,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BgX,IAA5B,GAAmC,YAAY;AAC3C,QAAI,KAAKC,SAAL,KAAmB,KAAvB,EACI;AACJ,SAAKA,SAAL,GAAiB,KAAjB;AACA,SAAK1U,cAAL;AACH,GALD;;AAMAoT,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BkX,IAA5B,GAAmC,YAAY;AAC3C,QAAI,KAAKD,SAAL,KAAmB,IAAvB,EACI;AACJ,SAAKA,SAAL,GAAiB,IAAjB;AACA,SAAK1U,cAAL;AACH,GALD;AAMA;;;;;;AAIAoT,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BmX,cAA5B,GAA6C,UAAUvT,QAAV,EAAoB;AAC7D,QAAIjF,KAAK,GAAG,IAAZ;;AACA,SAAKsX,qBAAL,CAA2B5V,GAA3B,CAA+BuD,QAA/B;AACA,WAAO,YAAY;AAAE,aAAOjF,KAAK,CAACsX,qBAAN,CAA4B3V,MAA5B,CAAmCsD,QAAnC,CAAP;AAAsD,KAA3E;AACH,GAJD;AAKA;;;;;;AAIA+R,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BoX,WAA5B,GAA0C,UAAUjV,MAAV,EAAkB;AACxD,QAAIxD,KAAK,GAAG,IAAZ;;AACA,SAAKsX,qBAAL,CAA2B5W,OAA3B,CAAmC,UAAUgY,QAAV,EAAoB;AACnDA,MAAAA,QAAQ,CAAC1Y,KAAK,CAAC8G,GAAP,EAAY9G,KAAK,CAAC2Y,eAAN,IAAyB3Y,KAAK,CAAC8G,GAA3C,EAAgDtD,MAAhD,CAAR;AACH,KAFD;AAGH,GALD;AAMA;;;;;;AAIAwT,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BwV,cAA5B,GAA6C,YAAY;AACrD,QAAIC,kBAAkB,GAAG,KAAKtT,MAAL,CAAYsT,kBAArC;AACA,WAAOD,cAAc,CAAC,KAAKhT,OAAN,EAAeiT,kBAAf,CAArB;AACH,GAHD;;AAIAE,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BuX,+BAA5B,GAA8D,YAAY;AACtE,QAAIC,IAAI,GAAG,KAAKhC,cAAL,EAAX;AACAnF,IAAAA,mBAAmB,CAACmH,IAAD,EAAO,KAAKzV,MAAZ,CAAnB;AACA,WAAOyV,IAAP;AACH,GAJD;AAKA;;;;;AAGA7B,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B4W,gBAA5B,GAA+C,YAAY;AACvD,WAAOa,MAAM,CAACb,gBAAP,CAAwB,KAAKpU,OAA7B,CAAP;AACH,GAFD;AAGA;;;;;AAGAmT,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B0X,mBAA5B,GAAkD,YAAY;AAC1D,SAAKJ,eAAL,GAAuB,KAAKC,+BAAL,EAAvB;AACA;;;;;AAIA,QAAI/X,EAAE,GAAG,KAAK8W,YAAd;AAAA,QAA4BxR,CAAC,GAAGtF,EAAE,CAACsF,CAAnC;AAAA,QAAsCG,CAAC,GAAGzF,EAAE,CAACyF,CAA7C;;AACA,QAAI,CAAC,KAAKoR,iBAAN,IAA2B,CAACvR,CAAC,CAACrD,WAAF,EAA5B,IAA+C,CAACwD,CAAC,CAACxD,WAAF,EAApD,EAAqE;AACjE,WAAK0M,SAAL,GAAiB3I,WAAW,CAAC,KAAK8R,eAAN,CAA5B;AACH;AACJ,GAVD;;AAWA3B,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B2X,aAA5B,GAA4C,YAAY;AACpD,SAAKlS,GAAL,GAAW,KAAK+P,cAAL,EAAX;AACA,SAAKoC,YAAL,GAAoBpS,WAAW,CAAC,KAAKC,GAAN,CAA/B;AACA,QAAI,CAAC,KAAK0I,SAAV,EACI,KAAKA,SAAL,GAAiB3I,WAAW,CAAC,KAAKC,GAAN,CAA5B;AACP,GALD;AAMA;;;;;AAGAkQ,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B6X,gBAA5B,GAA+C,YAAY;AACvD,SAAK1J,SAAL,GAAiB,KAAKoJ,+BAAL,EAAjB;AACH,GAFD;;AAGA5B,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B8X,aAA5B,GAA4C,YAAY;AACpD,SAAKzB,iBAAL,GAAyB,IAAzB;AACH,GAFD;;AAGAV,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4B+X,eAA5B,GAA8C,YAAY;AACtD,SAAKC,mBAAL;AACA,SAAK3B,iBAAL,GAAyB,KAAzB;AACH,GAHD;AAIA;;;;;;;;;AAOAV,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BiY,cAA5B,GAA6C,YAAY;AACrD,QAAIvM,iBAAiB,GAAG,KAAKvJ,MAAL,CAAYuJ,iBAApC;AACA,SAAKlJ,OAAL,CAAasL,KAAb,CAAmB5H,SAAnB,GAA+BwF,iBAAiB,GAC1CA,iBAAiB,CAAC,EAAD,EAAK,EAAL,CADyB,GAE1C,MAFN,CAFqD,CAKrD;;AACA,SAAKnJ,cAAL;AACH,GAPD;AAQA;;;;;AAGAoT,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BkY,aAA5B,GAA4C,UAAUzL,IAAV,EAAgB1H,GAAhB,EAAqBC,GAArB,EAA0B;AAClE,QAAImT,UAAU,GAAG,KAAKhK,SAAL,CAAe1B,IAAf,CAAjB;AACA0L,IAAAA,UAAU,CAACpT,GAAX,GAAiBA,GAAjB;AACAoT,IAAAA,UAAU,CAACnT,GAAX,GAAiBA,GAAjB,CAHkE,CAIlE;;AACA,SAAKkR,qBAAL,GAA6B,IAA7B;AACA,SAAKtT,UAAL,CAAgBqB,yBAAhB;AACH,GAPD;AAQA;;;;;AAGA0R,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BoY,wBAA5B,GAAuD,UAAU3L,IAAV,EAAgB2H,UAAhB,EAA4B;AAC/E,QAAIzV,KAAK,GAAG,IAAZ;;AACA,QAAIrD,QAAQ,GAAG,KAAKgb,YAAL,CAAkB7J,IAAlB,CAAf;AACA,QAAIjN,EAAE,GAAG,KAAK2O,SAAL,CAAe1B,IAAf,CAAT;AAAA,QAA+B1H,GAAG,GAAGvF,EAAE,CAACuF,GAAxC;AAAA,QAA6CC,GAAG,GAAGxF,EAAE,CAACwF,GAAtD;AACA,QAAIkH,MAAM,GAAGlH,GAAG,GAAGD,GAAnB;AACAzJ,IAAAA,QAAQ,CAACmF,cAAT;AACAnF,IAAAA,QAAQ,CAACyE,GAAT,CAAagF,GAAb;AACAzJ,IAAAA,QAAQ,CAACyE,GAAT,CAAagF,GAAb,EAP+E,CAO5D;;AACnBzJ,IAAAA,QAAQ,CAACiF,QAAT,CAAkB,UAAUvB,CAAV,EAAa;AAAE,aAAOL,KAAK,CAACuZ,aAAN,CAAoBzL,IAApB,EAA0BzN,CAA1B,EAA6BA,CAAC,GAAGkN,MAAjC,CAAP;AAAkD,KAAnF;AACA,WAAO+I,cAAc,CAACxI,IAAD,EAAOnR,QAAP,EAAiB,CAAjB,EAAoB8Y,UAApB,CAArB;AACH,GAVD;;AAWAuB,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BgY,mBAA5B,GAAkD,YAAY;AAC1D,QAAIrZ,KAAK,GAAG,IAAZ;;AACA6S,IAAAA,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AAAE,aAAO9N,KAAK,CAAC2X,YAAN,CAAmB7J,IAAnB,EAAyBtL,IAAzB,EAAP;AAAyC,KAA5D,CAAR;AACH,GAHD;AAIA;;;;;;AAIAwU,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BuW,YAA5B,GAA2C,YAAY;AACnD,QAAI/W,EAAJ,EAAQsV,EAAR;AACA;;;;;;AAIA/F,IAAAA,QAAQ,CAAC,KAAK6I,YAAN,EAAoB,KAAKnS,GAAzB,CAAR;AACA;;;;;AAIA,QAAI,KAAK5D,MAAT,EAAiB;AACbwP,MAAAA,eAAe,CAAC,KAAKvE,SAAN,EAAiB,KAAKjL,MAAL,CAAYiL,SAA7B,EAAwC,KAAKjL,MAAL,CAAYpC,KAApD,CAAf;AACH;AACD;;;;;;AAIA6Q,IAAAA,eAAe,CAAC,KAAKsH,YAAN,EAAoB,KAAK/U,QAAzB,CAAf;AACA;;;;;;AAKAmN,IAAAA,kBAAkB,CAAC,KAAKmG,cAAN,EAAsB,KAAKhI,SAA3B,EAAsC,KAAKpM,MAA3C,CAAlB;AACA;;;;;;;;;;AASAqP,IAAAA,cAAc,CAAC,KAAK3R,KAAN,EAAa,KAAKmY,YAAlB,EAAgC,KAAKzJ,SAArC,CAAd;AACA;;;;;;;AAMAiD,IAAAA,cAAc,CAAC,KAAKlD,UAAN,EAAkB,KAAK0J,YAAvB,EAAqC,KAAKzB,cAA1C,CAAd;AACA;;;;AAGA,SAAKD,qBAAL,KAA+B,CAACpB,EAAE,GAAG,CAACtV,EAAE,GAAG,KAAK2C,MAAX,EAAmBkW,mBAAzB,MAAkD,IAAlD,IAA0DvD,EAAE,KAAK,KAAK,CAAtE,GAA0E,KAAK,CAA/E,GAAmFA,EAAE,CAAC2B,IAAH,CAAQjX,EAAR,EAAY,KAAK2O,SAAjB,EAA4B,KAAK1O,KAAjC,CAAlH;AACA,SAAKyW,qBAAL,GAA6B,KAA7B;AACA;;;;AAGA,QAAIoC,cAAc,GAAG1K,oBAAoB,CAAC,KAAKM,UAAN,EAAkB,KAAKpB,SAAvB,CAAzC;AACAwL,IAAAA,cAAc,KAAK,KAAKA,cAAxB,IAA0C,KAAK/V,cAAL,EAA1C;AACA,SAAK+V,cAAL,GAAsBA,cAAtB;AACH,GArDD;AAsDA;;;;;;AAKA;;;;;AAGA3C,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4BuY,KAA5B,GAAoC,YAAY;AAC5C,QAAI,KAAKtB,SAAL,KAAmBvT,SAAvB,EAAkC;AAC9B,WAAKoK,KAAL,CAAW0K,UAAX,GAAwB,KAAKvB,SAAL,GAAiB,SAAjB,GAA6B,QAArD;AACH;;AACDpJ,IAAAA,eAAe,CAAC,KAAK9L,MAAN,EAAc,KAAK+L,KAAnB,EAA0B,KAAKC,IAA/B,EAAqC,KAAK7H,SAA1C,EAAqD,KAAK8H,eAA1D,EAA2E,KAAKvC,aAAhF,EAA+F,KAAKtJ,MAApG,EAA4G,KAAK8L,yBAAL,IAAkC,CAAC,CAAC,KAAKxI,GAArJ,EAA0J,KAAKhG,KAA/J,EAAsK,KAAKyO,UAA3K,EAAuL,KAAKpB,SAA5L,EAAuM,KAAKqJ,cAA5M,CAAf;AACH,GALD;AAMA;;;;;AAGAR,EAAAA,iBAAiB,CAAC3V,SAAlB,CAA4Bf,MAA5B,GAAqC,YAAY;AAC7C;AACA,SAAKsZ,KAAL,GAF6C,CAG7C;AACA;;AACAlE,IAAAA,MAAM,CAACoE,MAAP,CAAc,KAAKjW,OAAL,CAAasL,KAA3B,EAAkC,KAAKA,KAAvC,EAL6C,CAM7C;;AACA,SAAK,IAAI5K,GAAT,IAAgB,KAAK6K,IAArB,EAA2B;AACvB,WAAKvL,OAAL,CAAasL,KAAb,CAAmB4K,WAAnB,CAA+BxV,GAA/B,EAAoC,KAAK6K,IAAL,CAAU7K,GAAV,CAApC;AACH;AACJ,GAVD;;AAWA,SAAOyS,iBAAP;AACH,CAzXsC,CAyXrC/T,aAzXqC,CAAvC;AA0XA;;;;;;AAIA,IAAI4U,qBAAqB,GAAG,UAAUxT,KAAV,EAAiB;AACzC,SAAOA,KAAK,CAACkB,iBAAN,EAAP;AACH,CAFD;AAIA;;;;;;;;;AAOA,SAASyU,WAAT,CAAqBja,IAArB,EAA2B;AACvB,MAAIP,GAAG,GAAGhB,MAAM,CAAC,IAAD,CAAhB;;AACA,MAAIgB,GAAG,CAACgB,OAAJ,KAAgB,IAApB,EAA0B;AACtBhB,IAAAA,GAAG,CAACgB,OAAJ,GAAcT,IAAI,EAAlB;AACH;;AACD,SAAOP,GAAG,CAACgB,OAAX;AACH;;AAED,SAASyZ,YAAT,CAAsBhT,MAAtB,EAA8BiT,MAA9B,EAAsC/Q,IAAtC,EAA4C;AACxC,SAAO,OAAOlC,MAAP,KAAkB,QAAlB,GACDA,MADC,GAED3J,EAAE,CAACiK,SAAH,CAAa2S,MAAM,GAAG/Q,IAAI,GAAGlC,MAA7B,CAFN;AAGH;AACD;;;;;;AAIA,SAASkT,sBAAT,CAAgCC,UAAhC,EAA4CtP,OAA5C,EAAqDC,OAArD,EAA8D;AAC1D,MAAIsP,SAAS,GAAGJ,YAAY,CAACnP,OAAD,EAAUsP,UAAU,CAACjU,CAArB,EAAwBiU,UAAU,CAACrR,KAAnC,CAA5B;AACA,MAAIuR,SAAS,GAAGL,YAAY,CAAClP,OAAD,EAAUqP,UAAU,CAAC9T,CAArB,EAAwB8T,UAAU,CAACnR,MAAnC,CAA5B;AACA,SAAOoR,SAAS,GAAG,GAAZ,GAAkBC,SAAzB;AACH,C,CAED;;;AACA,IAAIC,gBAAgB,GAAG,UAAU5d,QAAV,EAAoB4Q,MAApB,EAA4B;AAC/C,SAAOjQ,EAAE,CAACiK,SAAH,CAAa5K,QAAQ,GAAG4Q,MAAxB,CAAP;AACH,CAFD;;AAGA,IAAIiN,QAAQ,GAAG;AACXN,EAAAA,MAAM,EAAE,mBADG;AAEXO,EAAAA,KAAK,EAAE;AAFI,CAAf;AAIA,IAAIC,SAAS,GAAG;AACZR,EAAAA,MAAM,EAAE,kBADI;AAEZO,EAAAA,KAAK,EAAE;AAFK,CAAhB;AAIA;;;;;;;;AAOA,SAASE,YAAT,CAAsBC,KAAtB,EAA6BC,WAA7B,EAA0CtN,MAA1C,EAAkDuN,OAAlD,EAA2DZ,MAA3D,EAAmEa,WAAnE,EAAgF;AAC5E,MAAID,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,CAAV;AAAc;;AACxC,MAAIZ,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,CAAT;AAAa;;AACtC,MAAIa,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,IAAAA,WAAW,GAAG,IAAd;AAAqB,GAHyB,CAI5E;AACA;;;AACA,MAAIpF,IAAI,GAAGoF,WAAW,GAAGP,QAAH,GAAcE,SAApC,CAN4E,CAO5E;;AACAE,EAAAA,KAAK,CAACjF,IAAI,CAACuE,MAAN,CAAL,GAAqBK,gBAAgB,CAAC,CAACL,MAAF,EAAUW,WAAV,CAArC,CAR4E,CAS5E;;AACA,MAAIG,UAAU,GAAGT,gBAAgB,CAAChN,MAAD,EAASsN,WAAT,CAAjC;AACA,MAAII,WAAW,GAAGV,gBAAgB,CAACO,OAAD,EAAUD,WAAV,CAAlC;AACAD,EAAAA,KAAK,CAACjF,IAAI,CAAC8E,KAAN,CAAL,GAAoBO,UAAU,GAAG,GAAb,GAAmBC,WAAvC;AACH;;AAED,IAAIC,UAAU,GAAG;AAAE/U,EAAAA,CAAC,EAAE,CAAL;AAAQG,EAAAA,CAAC,EAAE,CAAX;AAAcyC,EAAAA,KAAK,EAAE,CAArB;AAAwBE,EAAAA,MAAM,EAAE;AAAhC,CAAjB;AACA;;;;AAGA,SAASkS,aAAT,CAAuBta,EAAvB,EAA2BsO,KAA3B,EAAkCC,IAAlC,EAAwCwL,KAAxC,EAA+CrT,SAA/C,EAA0D8H,eAA1D,EAA2EvC,aAA3E,EAA0FtJ,MAA1F,EAAkG4W,UAAlG,EAA8GgB,eAA9G,EAA+H;AAC3H,MAAIC,KAAK,GAAGxa,EAAE,CAACwa,KAAf;AAAA,MAAsBC,KAAK,GAAGza,EAAE,CAACya,KAAjC;AAAA,MAAwCxQ,OAAO,GAAGjK,EAAE,CAACiK,OAArD;AAAA,MAA8DC,OAAO,GAAGlK,EAAE,CAACkK,OAA3E;AAAA,MAAoFiQ,UAAU,GAAGna,EAAE,CAACma,UAApG;AAAA,MAAgH7E,EAAE,GAAGtV,EAAE,CAACoa,WAAxH;AAAA,MAAqIA,WAAW,GAAG9E,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAAvK;AAAA,MAA2KoF,EAAE,GAAG1a,EAAE,CAAC2a,UAAnL;AAAA,MAA+LA,UAAU,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAAhO;AAAA,MACA;AACAnY,EAAAA,MAAM,GAAGlH,MAAM,CAAC2E,EAAD,EAAK,CAAC,OAAD,EAAU,OAAV,EAAmB,SAAnB,EAA8B,SAA9B,EAAyC,YAAzC,EAAuD,aAAvD,EAAsE,YAAtE,CAAL,CAFf;AAGA;;;;;AAGAqO,EAAAA,eAAe,CAAC9L,MAAD,EAASwX,KAAT,EAAgBxL,IAAhB,EAAsB7H,SAAtB,EAAiC8H,eAAjC,EAAkDvC,aAAlD,EAAiEtJ,MAAjE,CAAf;AACA;;;;;AAIA,MAAIoX,KAAK,CAACrT,SAAV,EAAqB;AACjB4H,IAAAA,KAAK,CAAC5H,SAAN,GAAkBqT,KAAK,CAACrT,SAAxB;AACA,WAAOqT,KAAK,CAACrT,SAAb;AACH,GAf0H,CAgB3H;;;AACA,MAAIuD,OAAO,KAAK/F,SAAZ,IAAyBgG,OAAO,KAAKhG,SAArC,IAAkDoK,KAAK,CAAC5H,SAA5D,EAAuE;AACnE4H,IAAAA,KAAK,CAACE,eAAN,GAAwB8K,sBAAsB,CAACC,UAAU,IAAIc,UAAf,EAA2BpQ,OAAO,KAAK/F,SAAZ,GAAwB+F,OAAxB,GAAkC,GAA7D,EAAkEC,OAAO,KAAKhG,SAAZ,GAAwBgG,OAAxB,GAAkC,GAApG,CAA9C;AACH,GAnB0H,CAoB3H;;;AACA,MAAIsQ,KAAK,KAAKtW,SAAd,EACI6V,KAAK,CAACzU,CAAN,GAAUkV,KAAV;AACJ,MAAIC,KAAK,KAAKvW,SAAd,EACI6V,KAAK,CAACtU,CAAN,GAAUgV,KAAV,CAxBuH,CAyB3H;;AACA,MAAIF,eAAe,KAAKrW,SAApB,IAAiCiW,UAAU,KAAKjW,SAApD,EAA+D;AAC3D4V,IAAAA,YAAY,CAACC,KAAD,EAAQQ,eAAR,EAAyBJ,UAAzB,EAAqCC,WAArC,EAAkDO,UAAlD,EAA8D,KAA9D,CAAZ;AACH;;AACD,SAAOZ,KAAP;AACH;AAED;;;;;AAGA,IAAIa,mBAAmB,GAAG,IAAI5Z,GAAJ,CAAQ,CAC9B,eAD8B,EAE9B,iBAF8B,EAG9B,cAH8B,EAI9B,kBAJ8B,EAK9B,YAL8B,EAM9B,UAN8B,EAO9B,mBAP8B,EAQ9B,cAR8B,EAS9B,aAT8B,EAU9B,YAV8B,EAW9B,SAX8B,EAY9B,SAZ8B,EAa9B,cAb8B,EAc9B,kBAd8B,EAe9B,kBAf8B,EAgB9B,cAhB8B,EAiB9B,aAjB8B,CAAR,CAA1B;AAoBA,IAAI6Z,kBAAkB,GAAG,iBAAzB;AACA,IAAIC,gBAAgB,GAAG,OAAvB;AACA;;;;AAGA,IAAIC,WAAW,GAAG,UAAUC,GAAV,EAAe;AAC7B,SAAOA,GAAG,CAACC,OAAJ,CAAYJ,kBAAZ,EAAgCC,gBAAhC,EAAkDI,WAAlD,EAAP;AACH,CAFD;AAIA;;;;;;AAIA,IAAIC,gBAAgB;AAAG;AAAe,UAAU/E,MAAV,EAAkB;AACpD9a,EAAAA,SAAS,CAAC6f,gBAAD,EAAmB/E,MAAnB,CAAT;;AACA,WAAS+E,gBAAT,GAA4B;AACxB,QAAIhc,KAAK,GAAGiX,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACC,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;AACA;;;;;;AAIAnX,IAAAA,KAAK,CAAC4a,KAAN,GAAc,EAAd;AACA;;;;AAGA5a,IAAAA,KAAK,CAACoX,aAAN,GAAsB;AAClBnK,MAAAA,0BAA0B,EAAE;AADV,KAAtB;AAGA;;;;;AAIAjN,IAAAA,KAAK,CAACwD,MAAN,GAAexD,KAAK,CAACoX,aAArB;AACA,WAAOpX,KAAP;AACH;AACD;;;;;;;AAKAgc,EAAAA,gBAAgB,CAAC3a,SAAjB,CAA2ByC,KAA3B,GAAmC,UAAUD,OAAV,EAAmB;AAClDoT,IAAAA,MAAM,CAAC5V,SAAP,CAAiByC,KAAjB,CAAuBgU,IAAvB,CAA4B,IAA5B,EAAkCjU,OAAlC;;AACA,SAAKoY,OAAL;AACH,GAHD;AAIA;;;;;AAGAD,EAAAA,gBAAgB,CAAC3a,SAAjB,CAA2B4a,OAA3B,GAAqC,YAAY;AAC7C,QAAI;AACA,WAAK7B,UAAL,GACI,OAAO,KAAKvW,OAAL,CAAaqY,OAApB,KACI,UADJ,GAEM,KAAKrY,OAAL,CAAaqY,OAAb,EAFN,GAGM,KAAKrY,OAAL,CAAakT,qBAAb,EAJV;AAKH,KAND,CAOA,OAAOoF,CAAP,EAAU;AACN;AACA,WAAK/B,UAAL,GAAkB;AAAEjU,QAAAA,CAAC,EAAE,CAAL;AAAQG,QAAAA,CAAC,EAAE,CAAX;AAAcyC,QAAAA,KAAK,EAAE,CAArB;AAAwBE,QAAAA,MAAM,EAAE;AAAhC,OAAlB;AACH;;AACD,QAAImT,MAAM,CAAC,KAAKvY,OAAN,CAAV,EAA0B;AACtB,WAAKuX,eAAL,GAAuB,KAAKvX,OAAL,CAAawY,cAAb,EAAvB;AACH;AACJ,GAfD;AAgBA;;;;;AAGAL,EAAAA,gBAAgB,CAAC3a,SAAjB,CAA2B0W,KAA3B,GAAmC,YAAY;AAC3Cd,IAAAA,MAAM,CAAC5V,SAAP,CAAiB0W,KAAjB,CAAuBD,IAAvB,CAA4B,IAA5B;;AACA,SAAK8C,KAAL,GAAa,EAAb;AACH,GAHD;AAIA;;;;;AAGAoB,EAAAA,gBAAgB,CAAC3a,SAAjB,CAA2B2W,IAA3B,GAAkC,UAAUzT,GAAV,EAAe;AAC7CA,IAAAA,GAAG,GAAG,CAACkX,mBAAmB,CAACjX,GAApB,CAAwBD,GAAxB,CAAD,GAAgCqX,WAAW,CAACrX,GAAD,CAA3C,GAAmDA,GAAzD;AACA,WAAO,KAAKV,OAAL,CAAayY,YAAb,CAA0B/X,GAA1B,CAAP;AACH,GAHD;;AAIAyX,EAAAA,gBAAgB,CAAC3a,SAAjB,CAA2BuY,KAA3B,GAAmC,YAAY;AAC3CuB,IAAAA,aAAa,CAAC,KAAK/X,MAAN,EAAc,KAAK+L,KAAnB,EAA0B,KAAKC,IAA/B,EAAqC,KAAKwL,KAA1C,EAAiD,KAAKrT,SAAtD,EAAiE,KAAK8H,eAAtE,EAAuF,KAAKvC,aAA5F,EAA2G,KAAKtJ,MAAhH,EAAwH,KAAK4W,UAA7H,EAAyI,KAAKgB,eAA9I,CAAb;AACH,GAFD;;AAGAY,EAAAA,gBAAgB,CAAC3a,SAAjB,CAA2Bf,MAA3B,GAAoC,YAAY;AAC5C;AACA2W,IAAAA,MAAM,CAAC5V,SAAP,CAAiBf,MAAjB,CAAwBwX,IAAxB,CAA6B,IAA7B,EAF4C,CAG5C;;;AACA,SAAK,IAAIvT,GAAT,IAAgB,KAAKqW,KAArB,EAA4B;AACxB,WAAK/W,OAAL,CAAa0Y,YAAb,CAA0BX,WAAW,CAACrX,GAAD,CAArC,EAA4C,KAAKqW,KAAL,CAAWrW,GAAX,CAA5C;AACH;AACJ,GAPD;;AAQA,SAAOyX,gBAAP;AACH,CA5EqC,CA4EpChF,iBA5EoC,CAAtC;;AA6EA,SAASoF,MAAT,CAAgBvY,OAAhB,EAAyB;AACrB,SAAOA,OAAO,CAAC2Y,OAAR,KAAoB,MAA3B;AACH;AAED;;;;AAGA;;;;;AAGA,IAAIC,WAAW,GAAG,CACd,SADc,EAEd,QAFc,EAGd,UAHc,EAId,MAJc,EAKd,MALc,EAMd,SANc,EAOd,SAPc,EAQd,eARc,EASd,qBATc,EAUd,aAVc,EAWd,kBAXc,EAYd,mBAZc,EAad,mBAbc,EAcd,gBAdc,EAed,cAfc,EAgBd,SAhBc,EAiBd,SAjBc,EAkBd,SAlBc,EAmBd,SAnBc,EAoBd,SApBc,EAqBd,gBArBc,EAsBd,SAtBc,EAuBd,SAvBc,EAwBd,aAxBc,EAyBd,cAzBc,EA0Bd,UA1Bc,EA2Bd,cA3Bc,EA4Bd,oBA5Bc,EA6Bd,aA7Bc,EA8Bd,QA9Bc,EA+Bd,cA/Bc,EAgCd,QAhCc,EAiCd,eAjCc,EAkCd,GAlCc,EAmCd,OAnCc,EAoCd,MApCc,EAqCd,gBArCc,EAsCd,QAtCc,EAuCd,MAvCc,EAwCd,UAxCc,EAyCd,MAzCc,EA0Cd,SA1Cc,EA2Cd,SA3Cc,EA4Cd,UA5Cc,EA6Cd,gBA7Cc,EA8Cd,MA9Cc,EA+Cd,MA/Cc,EAgDd,KAhDc,EAiDd,QAjDc,EAkDd,QAlDc,EAmDd,MAnDc,EAoDd,UApDc,EAqDd,OArDc,EAsDd,KAtDc,EAuDd,MAvDc,CAAlB;AA0DA,IAAIC,WAAW,GAAG,IAAI7a,GAAJ,CAAQ4a,WAAR,CAAlB;AACA;;;;;;;AAMA,SAASE,cAAT,CAAwB3d,SAAxB,EAAmC;AAC/B,SAAO,OAAOA,SAAP,KAAqB,QAArB,IAAiC0d,WAAW,CAAClY,GAAZ,CAAgBxF,SAAhB,CAAxC;AACH;AAED;;;;;AAGA,IAAI4d,eAAe,GAAGne,aAAa,CAAC,IAAD,CAAnC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAASoe,WAAT,GAAuB;AACnB,MAAIC,OAAO,GAAGpe,UAAU,CAACke,eAAD,CAAxB;AACA,MAAIE,OAAO,KAAK,IAAhB,EACI,OAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACJ,MAAIC,SAAS,GAAGD,OAAO,CAACC,SAAxB;AAAA,MAAmCC,cAAc,GAAGF,OAAO,CAACE,cAA5D;AAAA,MAA4EC,QAAQ,GAAGH,OAAO,CAACG,QAA/F,CAJmB,CAKnB;AACA;AACA;;AACA,MAAIC,EAAE,GAAGC,WAAW,EAApB;AACAxe,EAAAA,SAAS,CAAC,YAAY;AAAE,WAAOse,QAAQ,CAACC,EAAD,CAAf;AAAsB,GAArC,EAAuC,EAAvC,CAAT;;AACA,MAAIE,YAAY,GAAG,YAAY;AAAE,WAAOJ,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACE,EAAD,CAArF;AAA4F,GAA7H;;AACA,SAAO,CAACH,SAAD,IAAcC,cAAd,GAA+B,CAAC,KAAD,EAAQI,YAAR,CAA/B,GAAuD,CAAC,IAAD,CAA9D;AACH;AACD;;;;;AAGA,SAASC,YAAT,GAAwB;AACpB,MAAIP,OAAO,GAAGpe,UAAU,CAACke,eAAD,CAAxB;AACA,SAAOE,OAAO,KAAK,IAAZ,GAAmB,IAAnB,GAA0BA,OAAO,CAACC,SAAzC;AACH;;AACD,IAAIO,OAAO,GAAG,CAAd;;AACA,IAAIC,WAAW,GAAG,YAAY;AAAE,SAAOD,OAAO,EAAd;AAAmB,CAAnD;;AACA,IAAIH,WAAW,GAAG,YAAY;AAAE,SAAOnD,WAAW,CAACuD,WAAD,CAAlB;AAAkC,CAAlE;AAEA;;;;;;AAIA,IAAIC,mBAAmB,GAAG,UAAUxe,SAAV,EAAqBye,KAArB,EAA4Bva,MAA5B,EAAoCwa,QAApC,EAA8Cle,GAA9C,EAAmD;AACzE,MAAIme,aAAa,GAAG3D,WAAW,CAAC,YAAY;AACxC,QAAI4D,gBAAgB,GAAGjB,cAAc,CAAC3d,SAAD,CAAd,GACjBgd,gBADiB,GAEjBhF,iBAFN;AAGA,WAAO,IAAI4G,gBAAJ,CAAqB1a,MAArB,EAA6B1D,GAA7B,CAAP;AACH,GAL8B,CAA/B;AAMAme,EAAAA,aAAa,CAACxY,YAAd,CAA2BnJ,QAAQ,CAAC;AAAEiR,IAAAA,0BAA0B,EAAE,CAACyQ;AAA/B,GAAD,EAA4CD,KAA5C,CAAnC;AACAE,EAAAA,aAAa,CAACE,QAAd,GAAyBJ,KAAK,CAACI,QAA/B;AACA,MAAId,SAAS,GAAGM,YAAY,EAA5B;AACAM,EAAAA,aAAa,CAACZ,SAAd,GACIU,KAAK,CAACV,SAAN,KAAoBhY,SAApB,GAAgC0Y,KAAK,CAACV,SAAtC,GAAkDA,SADtD;AAEA,SAAOY,aAAP;AACH,CAbD;AAeA;;;;;;;;AAMA,IAAIG,gBAAgB,GAAG,IAAIjc,GAAJ,CAAQ,CAC3B,SAD2B,EAE3B,SAF2B,EAG3B,MAH2B,EAI3B,OAJ2B,EAK3B,UAL2B,EAM3B,YAN2B,EAO3B,mBAP2B,EAQ3B,iBAR2B,EAS3B,QAT2B,EAU3B,SAV2B,EAW3B,QAX2B,EAY3B,QAZ2B,EAa3B,UAb2B,EAc3B,2BAd2B,EAe3B,qBAf2B,EAgB3B,kBAhB2B,EAiB3B,qBAjB2B,EAkB3B,UAlB2B,EAmB3B,aAnB2B,EAoB3B,QApB2B,EAqB3B,WArB2B,EAsB3B,0BAtB2B,EAuB3B,iBAvB2B,EAwB3B,qBAxB2B,EAyB3B,MAzB2B,EA0B3B,cA1B2B,EA2B3B,cA3B2B,EA4B3B,iBA5B2B,EA6B3B,mBA7B2B,EA8B3B,aA9B2B,EA+B3B,cA/B2B,EAgC3B,iBAhC2B,EAiC3B,gBAjC2B,EAkC3B,OAlC2B,EAmC3B,YAnC2B,EAoC3B,UApC2B,EAqC3B,mBArC2B,EAsC3B,OAtC2B,EAuC3B,YAvC2B,EAwC3B,aAxC2B,EAyC3B,YAzC2B,EA0C3B,UA1C2B,EA2C3B,YA3C2B,EA4C3B,cA5C2B,CAAR,CAAvB;AA8CA;;;;;;;;;AAQA,SAASkc,iBAAT,CAA2BxZ,GAA3B,EAAgC;AAC5B,SAAOuZ,gBAAgB,CAACtZ,GAAjB,CAAqBD,GAArB,CAAP;AACH;;AAED,IAAIyZ,WAAW,GAAG,UAAUzZ,GAAV,EAAe;AAAE,SAAO,CAACwZ,iBAAiB,CAACxZ,GAAD,CAAzB;AAAiC,CAApE;AACA;;;;;;;;;;;;;;;AAaA,IAAI;AACA,MAAI0Z,oBAAoB,GAAGC,OAAO,CAAC,wBAAD,CAAP,CAAkCpO,OAA7D;;AACAkO,EAAAA,WAAW,GAAG,UAAUzZ,GAAV,EAAe;AACzB;AACA,QAAIA,GAAG,CAACoJ,UAAJ,CAAe,IAAf,CAAJ,EAA0B;AACtB,aAAO,CAACoQ,iBAAiB,CAACxZ,GAAD,CAAzB;AACH,KAFD,MAGK;AACD,aAAO0Z,oBAAoB,CAAC1Z,GAAD,CAA3B;AACH;AACJ,GARD;AASH,CAXD,CAYA,OAAO1D,EAAP,EAAW,CACP;AACH;;AACD,SAASsd,WAAT,CAAqBV,KAArB,EAA4B;AACxB,MAAIW,QAAQ,GAAG,EAAf;;AACA,OAAK,IAAI7Z,GAAT,IAAgBkZ,KAAhB,EAAuB;AACnB,QAAIO,WAAW,CAACzZ,GAAD,CAAf,EACI6Z,QAAQ,CAAC7Z,GAAD,CAAR,GAAgBkZ,KAAK,CAAClZ,GAAD,CAArB;AACP;;AACD,SAAO6Z,QAAP;AACH;;AAED,SAASC,cAAT,CAAwBV,aAAxB,EAAuC9c,EAAvC,EAA2C;AACvC,MAAIyd,IAAI,GAAGzd,EAAE,CAACyd,IAAd,CADuC,CAEvC;;AACA,MAAIC,SAAS,GAAG;AACZpP,IAAAA,KAAK,EAAEnT,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK2hB,aAAa,CAACtG,UAAnB,CAAT,EAAyCsG,aAAa,CAACxO,KAAvD,CAAT,EAAwEwO,aAAa,CAACvO,IAAtF;AADH,GAAhB;;AAGA,MAAI,CAAC,CAACkP,IAAN,EAAY;AACR;AACAC,IAAAA,SAAS,CAACpP,KAAV,CAAgBqP,UAAhB,GAA6B,MAA7B,CAFQ,CAGR;;AACAD,IAAAA,SAAS,CAACE,SAAV,GAAsB,KAAtB;AACH;;AACD,SAAOF,SAAP;AACH;AAED;;;;;AAGA,SAASG,aAAT,CAAuBf,aAAvB,EAAsC;AAClC,SAAO3hB,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK2hB,aAAa,CAAC/C,KAAnB,CAAT,EAAoC;AAAEzL,IAAAA,KAAK,EAAEnT,QAAQ,CAAC,EAAD,EAAK2hB,aAAa,CAACtG,UAAnB;AAAjB,GAApC,CAAf;AACH;;AAED,SAAS/W,MAAT,CAAgBtB,SAAhB,EAA2Bye,KAA3B,EAAkCE,aAAlC,EAAiD;AAC7C;AACA;AACA,MAAIgB,cAAc,GAAG,OAAO3f,SAAP,KAAqB,QAArB,GAAgCmf,WAAW,CAACV,KAAD,CAA3C,GAAqDA,KAA1E;AACA;;;;;;;AAMAE,EAAAA,aAAa,CAAC5F,KAAd;AACA4F,EAAAA,aAAa,CAAC/D,KAAd,GAX6C,CAY7C;;AACA,MAAIgF,WAAW,GAAGjC,cAAc,CAAC3d,SAAD,CAAd,GACZ0f,aAAa,CAACf,aAAD,CADD,GAEZU,cAAc,CAACV,aAAD,EAAgBF,KAAhB,CAFpB;AAGA,SAAO7e,aAAa,CAACI,SAAD,EAAYhD,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK2iB,cAAL,CAAT,EAA+B;AAAEnf,IAAAA,GAAG,EAAEme,aAAa,CAACne;AAArB,GAA/B,CAAT,EAAqEof,WAArE,CAApB,CAApB;AACH;;AAED,SAASC,eAAT,CAAyBlf,KAAzB,EAAgC;AAC5B,SAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACgO,UAAN,CAAiB,QAAjB,CAApC;AACH;AACD;;;;;;;;;;;AASA,IAAImR,gBAAgB,GAAG,sDAAvB;;AACA,SAASC,gBAAT,CAA0Bve,OAA1B,EAAmC;AAC/B,MAAIwe,KAAK,GAAGF,gBAAgB,CAACG,IAAjB,CAAsBze,OAAtB,CAAZ;AACA,MAAI,CAACwe,KAAL,EACI,OAAO,GAAP;AACJ,MAAIE,KAAK,GAAGF,KAAK,CAAC,CAAD,CAAjB;AAAA,MAAsBG,QAAQ,GAAGH,KAAK,CAAC,CAAD,CAAtC;AACA,SAAO,CAACE,KAAD,EAAQC,QAAR,CAAP;AACH;;AACD,IAAIC,QAAQ,GAAG,CAAf;;AACA,SAASC,gBAAT,CAA0B7e,OAA1B,EAAmCqD,OAAnC,EAA4CM,KAA5C,EAAmD;AAC/C,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,IAAAA,KAAK,GAAG,CAAR;AAAY;;AACpClH,EAAAA,SAAS,CAACkH,KAAK,IAAIib,QAAV,EAAoB,4DAA4D5e,OAA5D,GAAsE,uDAA1F,CAAT;;AACA,MAAIK,EAAE,GAAGke,gBAAgB,CAACve,OAAD,CAAzB;AAAA,MAAoC0e,KAAK,GAAGre,EAAE,CAAC,CAAD,CAA9C;AAAA,MAAmDse,QAAQ,GAAGte,EAAE,CAAC,CAAD,CAAhE,CAH+C,CAI/C;;;AACA,MAAI,CAACqe,KAAL,EACI,OAN2C,CAO/C;;AACA,MAAII,QAAQ,GAAGxG,MAAM,CAACb,gBAAP,CAAwBpU,OAAxB,EAAiC0b,gBAAjC,CAAkDL,KAAlD,CAAf;;AACA,MAAII,QAAJ,EAAc;AACV,WAAOA,QAAP;AACH,GAFD,MAGK,IAAIT,eAAe,CAACM,QAAD,CAAnB,EAA+B;AAChC;AACA,WAAOE,gBAAgB,CAACF,QAAD,EAAWtb,OAAX,EAAoBM,KAAK,GAAG,CAA5B,CAAvB;AACH,GAHI,MAIA;AACD,WAAOgb,QAAP;AACH;AACJ;AACD;;;;;;;AAKA,SAASK,mBAAT,CAA6B7B,aAA7B,EAA4C9c,EAA5C,EAAgD4e,aAAhD,EAA+D;AAC3D,MAAI1N,MAAM,GAAG7V,MAAM,CAAC2E,EAAD,EAAK,EAAL,CAAnB;;AACA,MAAIgD,OAAO,GAAG8Z,aAAa,CAACzY,WAAd,EAAd;AACA,MAAI,EAAErB,OAAO,YAAY6b,WAArB,CAAJ,EACI,OAAO;AAAE3N,IAAAA,MAAM,EAAEA,MAAV;AAAkB0N,IAAAA,aAAa,EAAEA;AAAjC,GAAP,CAJuD,CAK3D;AACA;;AACA,MAAIA,aAAJ,EAAmB;AACfA,IAAAA,aAAa,GAAGzjB,QAAQ,CAAC,EAAD,EAAKyjB,aAAL,CAAxB;AACH,GAT0D,CAU3D;;;AACA9B,EAAAA,aAAa,CAAC3Y,YAAd,CAA2B,UAAUrF,KAAV,EAAiB;AACxC,QAAIa,OAAO,GAAGb,KAAK,CAACwC,GAAN,EAAd;AACA,QAAI,CAAC0c,eAAe,CAACre,OAAD,CAApB,EACI;AACJ,QAAI8e,QAAQ,GAAGD,gBAAgB,CAAC7e,OAAD,EAAUqD,OAAV,CAA/B;AACA,QAAIyb,QAAJ,EACI3f,KAAK,CAACyB,GAAN,CAAUke,QAAV;AACP,GAPD,EAX2D,CAmB3D;AACA;;AACA,OAAK,IAAI/a,GAAT,IAAgBwN,MAAhB,EAAwB;AACpB,QAAIvR,OAAO,GAAGuR,MAAM,CAACxN,GAAD,CAApB;AACA,QAAI,CAACsa,eAAe,CAACre,OAAD,CAApB,EACI;AACJ,QAAI8e,QAAQ,GAAGD,gBAAgB,CAAC7e,OAAD,EAAUqD,OAAV,CAA/B;AACA,QAAI,CAACyb,QAAL,EACI,SANgB,CAOpB;;AACAvN,IAAAA,MAAM,CAACxN,GAAD,CAAN,GAAc+a,QAAd,CARoB,CASpB;AACA;AACA;;AACA,QAAIG,aAAa,IAAIA,aAAa,CAAClb,GAAD,CAAb,KAAuBQ,SAA5C,EAAuD;AACnD0a,MAAAA,aAAa,CAAClb,GAAD,CAAb,GAAqB/D,OAArB;AACH;AACJ;;AACD,SAAO;AAAEuR,IAAAA,MAAM,EAAEA,MAAV;AAAkB0N,IAAAA,aAAa,EAAEA;AAAjC,GAAP;AACH;;AAED,IAAIE,cAAc,GAAG,IAAI9d,GAAJ,CAAQ,CACzB,OADyB,EAEzB,QAFyB,EAGzB,KAHyB,EAIzB,MAJyB,EAKzB,OALyB,EAMzB,QANyB,EAOzB,GAPyB,EAQzB,GARyB,CAAR,CAArB;;AAUA,IAAI+d,eAAe,GAAG,UAAUrb,GAAV,EAAe;AAAE,SAAOob,cAAc,CAACnb,GAAf,CAAmBD,GAAnB,CAAP;AAAiC,CAAxE;;AACA,IAAIsb,gBAAgB,GAAG,UAAU9N,MAAV,EAAkB;AACrC,SAAO2D,MAAM,CAACC,IAAP,CAAY5D,MAAZ,EAAoB+N,IAApB,CAAyBF,eAAzB,CAAP;AACH,CAFD;;AAGA,IAAIG,mBAAmB,GAAG,UAAUpgB,KAAV,EAAiB6T,EAAjB,EAAqB;AAC3C;AACA;AACA7T,EAAAA,KAAK,CAACyB,GAAN,CAAUoS,EAAV,EAAc,KAAd;AACA7T,EAAAA,KAAK,CAACyB,GAAN,CAAUoS,EAAV;AACH,CALD;;AAMA,IAAIwM,aAAa,GAAG,UAAU3f,CAAV,EAAa;AAC7B,SAAOA,CAAC,KAAKlD,MAAN,IAAgBkD,CAAC,KAAK/C,EAA7B;AACH,CAFD;;AAGA,IAAI2iB,oBAAJ;;AACA,CAAC,UAAUA,oBAAV,EAAgC;AAC7BA,EAAAA,oBAAoB,CAAC,OAAD,CAApB,GAAgC,OAAhC;AACAA,EAAAA,oBAAoB,CAAC,QAAD,CAApB,GAAiC,QAAjC;AACAA,EAAAA,oBAAoB,CAAC,MAAD,CAApB,GAA+B,MAA/B;AACAA,EAAAA,oBAAoB,CAAC,OAAD,CAApB,GAAgC,OAAhC;AACAA,EAAAA,oBAAoB,CAAC,KAAD,CAApB,GAA8B,KAA9B;AACAA,EAAAA,oBAAoB,CAAC,QAAD,CAApB,GAAiC,QAAjC;AACH,CAPD,EAOGA,oBAAoB,KAAKA,oBAAoB,GAAG,EAA5B,CAPvB;;AAQA,IAAIC,gBAAgB,GAAG,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AAC1C,SAAOvgB,UAAU,CAACsgB,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBD,GAAnB,CAAD,CAAjB;AACH,CAFD;;AAGA,IAAIE,sBAAsB,GAAG,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AAAE,SAAO,UAAUC,KAAV,EAAiB5f,EAAjB,EAAqB;AAC7E,QAAI0G,SAAS,GAAG1G,EAAE,CAAC0G,SAAnB;AACA,QAAIA,SAAS,KAAK,MAAd,IAAwB,CAACA,SAA7B,EACI,OAAO,CAAP;AACJ,QAAImZ,QAAQ,GAAGnZ,SAAS,CAACyX,KAAV,CAAgB,oBAAhB,CAAf;;AACA,QAAI0B,QAAJ,EAAc;AACV,aAAOR,gBAAgB,CAACQ,QAAQ,CAAC,CAAD,CAAT,EAAcF,IAAd,CAAvB;AACH,KAFD,MAGK;AACD,UAAIL,MAAM,GAAG5Y,SAAS,CAACyX,KAAV,CAAgB,kBAAhB,CAAb;;AACA,UAAImB,MAAJ,EAAY;AACR,eAAOD,gBAAgB,CAACC,MAAM,CAAC,CAAD,CAAP,EAAYI,IAAZ,CAAvB;AACH,OAFD,MAGK;AACD,eAAO,CAAP;AACH;AACJ;AACJ,GAjBoD;AAiBjD,CAjBJ;;AAkBA,IAAIzT,aAAa,GAAG,IAAIjL,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,CAApB;AACA,IAAI8e,6BAA6B,GAAG3U,cAAc,CAAC4U,MAAf,CAAsB,UAAUrc,GAAV,EAAe;AAAE,SAAO,CAACuI,aAAa,CAACtI,GAAd,CAAkBD,GAAlB,CAAR;AAAiC,CAAxE,CAApC;;AACA,SAASsc,+BAAT,CAAyClD,aAAzC,EAAwD;AACpD,MAAImD,iBAAiB,GAAG,EAAxB;AACAH,EAAAA,6BAA6B,CAACjgB,OAA9B,CAAsC,UAAU6D,GAAV,EAAe;AACjD,QAAI5E,KAAK,GAAGge,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,CAAZ;;AACA,QAAI5E,KAAK,KAAKoF,SAAd,EAAyB;AACrB+b,MAAAA,iBAAiB,CAAC3U,IAAlB,CAAuB,CAAC5H,GAAD,EAAM5E,KAAK,CAACwC,GAAN,EAAN,CAAvB;AACAxC,MAAAA,KAAK,CAACyB,GAAN,CAAUmD,GAAG,CAACoJ,UAAJ,CAAe,OAAf,IAA0B,CAA1B,GAA8B,CAAxC;AACH;AACJ,GAND,EAFoD,CASpD;;AACA,MAAImT,iBAAiB,CAACvT,MAAtB,EACIoQ,aAAa,CAACrd,MAAd;AACJ,SAAOwgB,iBAAP;AACH;;AACD,IAAIC,gBAAgB,GAAG;AACnB;AACAhY,EAAAA,KAAK,EAAE,UAAUlI,EAAV,EAAc;AACjB,QAAIsF,CAAC,GAAGtF,EAAE,CAACsF,CAAX;AACA,WAAOA,CAAC,CAACE,GAAF,GAAQF,CAAC,CAACC,GAAjB;AACH,GALkB;AAMnB6C,EAAAA,MAAM,EAAE,UAAUpI,EAAV,EAAc;AAClB,QAAIyF,CAAC,GAAGzF,EAAE,CAACyF,CAAX;AACA,WAAOA,CAAC,CAACD,GAAF,GAAQC,CAAC,CAACF,GAAjB;AACH,GATkB;AAUnBL,EAAAA,GAAG,EAAE,UAAU0a,KAAV,EAAiB5f,EAAjB,EAAqB;AACtB,QAAIkF,GAAG,GAAGlF,EAAE,CAACkF,GAAb;AACA,WAAOlG,UAAU,CAACkG,GAAD,CAAjB;AACH,GAbkB;AAcnBC,EAAAA,IAAI,EAAE,UAAUya,KAAV,EAAiB5f,EAAjB,EAAqB;AACvB,QAAImF,IAAI,GAAGnF,EAAE,CAACmF,IAAd;AACA,WAAOnG,UAAU,CAACmG,IAAD,CAAjB;AACH,GAjBkB;AAkBnBE,EAAAA,MAAM,EAAE,UAAUrF,EAAV,EAAcsV,EAAd,EAAkB;AACtB,QAAI7P,CAAC,GAAGzF,EAAE,CAACyF,CAAX;AACA,QAAIP,GAAG,GAAGoQ,EAAE,CAACpQ,GAAb;AACA,WAAOlG,UAAU,CAACkG,GAAD,CAAV,IAAmBO,CAAC,CAACD,GAAF,GAAQC,CAAC,CAACF,GAA7B,CAAP;AACH,GAtBkB;AAuBnBH,EAAAA,KAAK,EAAE,UAAUpF,EAAV,EAAcsV,EAAd,EAAkB;AACrB,QAAIhQ,CAAC,GAAGtF,EAAE,CAACsF,CAAX;AACA,QAAIH,IAAI,GAAGmQ,EAAE,CAACnQ,IAAd;AACA,WAAOnG,UAAU,CAACmG,IAAD,CAAV,IAAoBG,CAAC,CAACE,GAAF,GAAQF,CAAC,CAACC,GAA9B,CAAP;AACH,GA3BkB;AA4BnB;AACAD,EAAAA,CAAC,EAAEma,sBAAsB,CAAC,CAAD,EAAI,EAAJ,CA7BN;AA8BnBha,EAAAA,CAAC,EAAEga,sBAAsB,CAAC,CAAD,EAAI,EAAJ;AA9BN,CAAvB;;AAgCA,IAAIU,wBAAwB,GAAG,UAAUjP,MAAV,EAAkB4L,aAAlB,EAAiCsD,WAAjC,EAA8C;AACzE,MAAIC,UAAU,GAAGvD,aAAa,CAAC9G,cAAd,EAAjB;AACA,MAAIsK,oBAAoB,GAAGxD,aAAa,CAAC1F,gBAAd,EAA3B;AACA,MAAImJ,OAAO,GAAGD,oBAAoB,CAACC,OAAnC;AAAA,MAA4Crb,GAAG,GAAGob,oBAAoB,CAACpb,GAAvE;AAAA,MAA4EC,IAAI,GAAGmb,oBAAoB,CAACnb,IAAxG;AAAA,MAA8GE,MAAM,GAAGib,oBAAoB,CAACjb,MAA5I;AAAA,MAAoJD,KAAK,GAAGkb,oBAAoB,CAAClb,KAAjL;AAAA,MAAwLsB,SAAS,GAAG4Z,oBAAoB,CAAC5Z,SAAzN;AACA,MAAI8Z,mBAAmB,GAAG;AAAEtb,IAAAA,GAAG,EAAEA,GAAP;AAAYC,IAAAA,IAAI,EAAEA,IAAlB;AAAwBE,IAAAA,MAAM,EAAEA,MAAhC;AAAwCD,IAAAA,KAAK,EAAEA,KAA/C;AAAsDsB,IAAAA,SAAS,EAAEA;AAAjE,GAA1B,CAJyE,CAKzE;AACA;;AACA,MAAI6Z,OAAO,KAAK,MAAhB,EAAwB;AACpBzD,IAAAA,aAAa,CAACtY,eAAd,CAA8B,SAA9B,EAAyC0M,MAAM,CAACqP,OAAP,IAAkB,OAA3D;AACH,GATwE,CAUzE;;;AACAzD,EAAAA,aAAa,CAACrd,MAAd;AACA,MAAIghB,UAAU,GAAG3D,aAAa,CAAC9G,cAAd,EAAjB;AACAoK,EAAAA,WAAW,CAACvgB,OAAZ,CAAoB,UAAU6D,GAAV,EAAe;AAC/B;AACA;AACA,QAAI5E,KAAK,GAAGge,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,CAAZ;AACAwb,IAAAA,mBAAmB,CAACpgB,KAAD,EAAQohB,gBAAgB,CAACxc,GAAD,CAAhB,CAAsB2c,UAAtB,EAAkCG,mBAAlC,CAAR,CAAnB;AACAtP,IAAAA,MAAM,CAACxN,GAAD,CAAN,GAAcwc,gBAAgB,CAACxc,GAAD,CAAhB,CAAsB+c,UAAtB,EAAkCH,oBAAlC,CAAd;AACH,GAND;AAOA,SAAOpP,MAAP;AACH,CArBD;;AAsBA,IAAIwP,gCAAgC,GAAG,UAAU5D,aAAV,EAAyB5L,MAAzB,EAAiC9K,MAAjC,EAAyCwY,aAAzC,EAAwD;AAC3F,MAAIxY,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,MAAIwY,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,IAAAA,aAAa,GAAG,EAAhB;AAAqB;;AACrD1N,EAAAA,MAAM,GAAG/V,QAAQ,CAAC,EAAD,EAAK+V,MAAL,CAAjB;AACA0N,EAAAA,aAAa,GAAGzjB,QAAQ,CAAC,EAAD,EAAKyjB,aAAL,CAAxB;AACA,MAAI+B,oBAAoB,GAAG9L,MAAM,CAACC,IAAP,CAAY5D,MAAZ,EAAoB6O,MAApB,CAA2BhB,eAA3B,CAA3B,CAL2F,CAM3F;AACA;;AACA,MAAI6B,sBAAsB,GAAG,EAA7B;AACA,MAAIC,mCAAmC,GAAG,KAA1C;AACA,MAAIC,oBAAoB,GAAG,EAA3B;AACAH,EAAAA,oBAAoB,CAAC9gB,OAArB,CAA6B,UAAU6D,GAAV,EAAe;AACxC,QAAI5E,KAAK,GAAGge,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,CAAZ;AACA,QAAI,CAACoZ,aAAa,CAACrZ,QAAd,CAAuBC,GAAvB,CAAL,EACI;AACJ,QAAIyQ,IAAI,GAAG/N,MAAM,CAAC1C,GAAD,CAAjB;AACA,QAAIiP,EAAE,GAAGzB,MAAM,CAACxN,GAAD,CAAf;AACA,QAAIqd,QAAQ,GAAGpW,sBAAsB,CAACwJ,IAAD,CAArC;AACA,QAAI6M,MAAJ,CAPwC,CAQxC;AACA;AACA;AACA;;AACA,QAAI9O,iBAAiB,CAACS,EAAD,CAArB,EAA2B;AACvB,UAAIsO,YAAY,GAAGtO,EAAE,CAACjG,MAAtB;;AACA,WAAK,IAAIC,CAAC,GAAGgG,EAAE,CAAC,CAAD,CAAF,KAAU,IAAV,GAAiB,CAAjB,GAAqB,CAAlC,EAAqChG,CAAC,GAAGsU,YAAzC,EAAuDtU,CAAC,EAAxD,EAA4D;AACxD,YAAI,CAACqU,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAGrW,sBAAsB,CAACgI,EAAE,CAAChG,CAAD,CAAH,CAA/B;AACAvQ,UAAAA,SAAS,CAAC4kB,MAAM,KAAKD,QAAX,IACL5B,aAAa,CAAC4B,QAAD,CAAb,IAA2B5B,aAAa,CAAC6B,MAAD,CADpC,EAC+C,8DAD/C,CAAT;AAEH,SAJD,MAKK;AACD5kB,UAAAA,SAAS,CAACuO,sBAAsB,CAACgI,EAAE,CAAChG,CAAD,CAAH,CAAtB,KAAkCqU,MAAnC,EAA2C,wCAA3C,CAAT;AACH;AACJ;AACJ,KAZD,MAaK;AACDA,MAAAA,MAAM,GAAGrW,sBAAsB,CAACgI,EAAD,CAA/B;AACH;;AACD,QAAIoO,QAAQ,KAAKC,MAAjB,EAAyB;AACrB;AACA;AACA,UAAI7B,aAAa,CAAC4B,QAAD,CAAb,IAA2B5B,aAAa,CAAC6B,MAAD,CAA5C,EAAsD;AAClD,YAAIrhB,OAAO,GAAGb,KAAK,CAACwC,GAAN,EAAd;;AACA,YAAI,OAAO3B,OAAP,KAAmB,QAAvB,EAAiC;AAC7Bb,UAAAA,KAAK,CAACyB,GAAN,CAAUvB,UAAU,CAACW,OAAD,CAApB;AACH;;AACD,YAAI,OAAOgT,EAAP,KAAc,QAAlB,EAA4B;AACxBzB,UAAAA,MAAM,CAACxN,GAAD,CAAN,GAAc1E,UAAU,CAAC2T,EAAD,CAAxB;AACH,SAFD,MAGK,IAAIR,KAAK,CAACC,OAAN,CAAcO,EAAd,KAAqBqO,MAAM,KAAKvkB,EAApC,EAAwC;AACzCyU,UAAAA,MAAM,CAACxN,GAAD,CAAN,GAAciP,EAAE,CAAC2B,GAAH,CAAOtV,UAAP,CAAd;AACH;AACJ,OAXD,MAYK;AACD;AACA;AACA,YAAI,CAAC6hB,mCAAL,EAA0C;AACtCD,UAAAA,sBAAsB,GAAGZ,+BAA+B,CAAClD,aAAD,CAAxD;AACA+D,UAAAA,mCAAmC,GAAG,IAAtC;AACH;;AACDC,QAAAA,oBAAoB,CAACxV,IAArB,CAA0B5H,GAA1B;AACAkb,QAAAA,aAAa,CAAClb,GAAD,CAAb,GACIkb,aAAa,CAAClb,GAAD,CAAb,KAAuBQ,SAAvB,GACM0a,aAAa,CAAClb,GAAD,CADnB,GAEMwN,MAAM,CAACxN,GAAD,CAHhB;AAIAwb,QAAAA,mBAAmB,CAACpgB,KAAD,EAAQ6T,EAAR,CAAnB;AACH;AACJ;AACJ,GA1DD;;AA2DA,MAAImO,oBAAoB,CAACpU,MAAzB,EAAiC;AAC7B,QAAIwU,eAAe,GAAGf,wBAAwB,CAACjP,MAAD,EAAS4L,aAAT,EAAwBgE,oBAAxB,CAA9C,CAD6B,CAE7B;;AACA,QAAIF,sBAAsB,CAAClU,MAA3B,EAAmC;AAC/BkU,MAAAA,sBAAsB,CAAC/gB,OAAvB,CAA+B,UAAUG,EAAV,EAAc;AACzC,YAAI0D,GAAG,GAAG1D,EAAE,CAAC,CAAD,CAAZ;AAAA,YAAiBlB,KAAK,GAAGkB,EAAE,CAAC,CAAD,CAA3B;AACA8c,QAAAA,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,EAA4BnD,GAA5B,CAAgCzB,KAAhC;AACH,OAHD;AAIH,KAR4B,CAS7B;;;AACAge,IAAAA,aAAa,CAACrd,MAAd;AACA,WAAO;AAAEyR,MAAAA,MAAM,EAAEgQ,eAAV;AAA2BtC,MAAAA,aAAa,EAAEA;AAA1C,KAAP;AACH,GAZD,MAaK;AACD,WAAO;AAAE1N,MAAAA,MAAM,EAAEA,MAAV;AAAkB0N,MAAAA,aAAa,EAAEA;AAAjC,KAAP;AACH;AACJ,CAtFD;AAuFA;;;;;;;;;AAOA,SAASuC,cAAT,CAAwBrE,aAAxB,EAAuC5L,MAAvC,EAA+C9K,MAA/C,EAAuDwY,aAAvD,EAAsE;AAClE,SAAOI,gBAAgB,CAAC9N,MAAD,CAAhB,GACDwP,gCAAgC,CAAC5D,aAAD,EAAgB5L,MAAhB,EAAwB9K,MAAxB,EAAgCwY,aAAhC,CAD/B,GAED;AAAE1N,IAAAA,MAAM,EAAEA,MAAV;AAAkB0N,IAAAA,aAAa,EAAEA;AAAjC,GAFN;AAGH;AAED;;;;;;AAIA,IAAIwC,eAAe,GAAG,UAAUtE,aAAV,EAAyB5L,MAAzB,EAAiC9K,MAAjC,EAAyCwY,aAAzC,EAAwD;AAC1E,MAAIH,QAAQ,GAAGE,mBAAmB,CAAC7B,aAAD,EAAgB5L,MAAhB,EAAwB0N,aAAxB,CAAlC;AACA1N,EAAAA,MAAM,GAAGuN,QAAQ,CAACvN,MAAlB;AACA0N,EAAAA,aAAa,GAAGH,QAAQ,CAACG,aAAzB;AACA,SAAOuC,cAAc,CAACrE,aAAD,EAAgB5L,MAAhB,EAAwB9K,MAAxB,EAAgCwY,aAAhC,CAArB;AACH,CALD;AAOA;;;;;;;;;;;AASA,SAASyC,uBAAT,CAAiCjd,QAAjC,EAA2Ckd,aAA3C,EAA0D;AACtD,MAAIA,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,IAAAA,aAAa,GAAG,KAAhB;AAAwB;;AACxD,MAAIC,eAAe,GAAG5jB,MAAM,CAAC,IAAD,CAA5B;;AACA,MAAI,CAAC2jB,aAAD,IAAmBA,aAAa,IAAIC,eAAe,CAAC5hB,OAAxD,EAAkE;AAC9DyE,IAAAA,QAAQ;AACX;;AACDmd,EAAAA,eAAe,CAAC5hB,OAAhB,GAA0B,KAA1B;AACH;AAED;;;;;;;AAKA,IAAI6hB,iBAAiB;AAAG;AAAe,YAAY;AAC/C,WAASA,iBAAT,GAA6B;AACzB;;;;;AAKA,SAAKC,UAAL,GAAkB,KAAlB;AACA;;;;;;AAKA,SAAKC,iBAAL,GAAyB,EAAzB;AACA;;;;;;AAKA,SAAKC,iBAAL,GAAyB,IAAI3gB,GAAJ,EAAzB;AACH;AACD;;;;;;;;;AAOAwgB,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4BohB,WAA5B,GAA0C,UAAUC,QAAV,EAAoB;AAC1D,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKF,iBAAL,CAAuB9hB,OAAvB,CAA+B,UAAUiiB,QAAV,EAAoB;AAC/C,aAAOA,QAAQ,CAACF,WAAT,CAAqBC,QAArB,CAAP;AACH,KAFD;AAGH,GALD;AAMA;;;;;;;;;AAOAL,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4BuhB,oBAA5B,GAAmD,UAAUnN,UAAV,EAAsB;AACrE,SAAKoN,iBAAL,GAAyBpN,UAAzB;AACA,SAAK+M,iBAAL,CAAuB9hB,OAAvB,CAA+B,UAAUiiB,QAAV,EAAoB;AAC/C,aAAOA,QAAQ,CAACC,oBAAT,CAA8BnN,UAA9B,CAAP;AACH,KAFD;AAGH,GALD;AAMA;;;;;;;;;;AAQA4M,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4B+C,SAA5B,GAAwC,UAAUue,QAAV,EAAoB;AACxD,QAAI3iB,KAAK,GAAG,IAAZ;;AACA,SAAKwiB,iBAAL,CAAuB9gB,GAAvB,CAA2BihB,QAA3B;AACA,QAAI,KAAKD,QAAT,EACIC,QAAQ,CAACF,WAAT,CAAqB,KAAKC,QAA1B;AACJ,QAAI,KAAKG,iBAAT,EACIF,QAAQ,CAACC,oBAAT,CAA8B,KAAKC,iBAAnC;AACJ,WAAO,YAAY;AAAE,aAAO7iB,KAAK,CAACwiB,iBAAN,CAAwB7gB,MAAxB,CAA+BghB,QAA/B,CAAP;AAAkD,KAAvE;AACH,GARD;AASA;;;;;;;;;;;;;;;;;;;;;AAmBAN,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4BiB,KAA5B,GAAoC,UAAU6R,UAAV,EAAsB2O,kBAAtB,EAA0C;AAC1E,QAAI9iB,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKsiB,UAAT,EAAqB;AACjB,UAAIS,YAAY,GAAG,EAAnB;AACA,WAAKP,iBAAL,CAAuB9hB,OAAvB,CAA+B,UAAUiiB,QAAV,EAAoB;AAC/C,YAAIpgB,SAAS,GAAGogB,QAAQ,CAACrgB,KAAT,CAAe6R,UAAf,EAA2B;AACvC2O,UAAAA,kBAAkB,EAAEA;AADmB,SAA3B,CAAhB;AAGAC,QAAAA,YAAY,CAAC5W,IAAb,CAAkB5J,SAAlB;AACH,OALD;AAMA,aAAOE,OAAO,CAACugB,GAAR,CAAYD,YAAZ,CAAP;AACH,KATD,MAUK;AACD,aAAO,IAAItgB,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AAClC1C,QAAAA,KAAK,CAACuiB,iBAAN,CAAwBpW,IAAxB,CAA6B;AACzB5J,UAAAA,SAAS,EAAE,CAAC4R,UAAD,EAAa2O,kBAAb,CADc;AAEzBpgB,UAAAA,OAAO,EAAEA;AAFgB,SAA7B;AAIH,OALM,CAAP;AAMH;AACJ,GApBD;AAqBA;;;;;;;;;;;;;;;;;;;;;;AAoBA2f,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4BD,GAA5B,GAAkC,UAAU+S,UAAV,EAAsB;AACpDlX,IAAAA,SAAS,CAAC,KAAKqlB,UAAN,EAAkB,+GAAlB,CAAT;AACA,WAAO,KAAKE,iBAAL,CAAuB9hB,OAAvB,CAA+B,UAAUiiB,QAAV,EAAoB;AACtD,aAAOA,QAAQ,CAACzL,KAAT,CAAe/C,UAAf,CAAP;AACH,KAFM,CAAP;AAGH,GALD;AAMA;;;;;;;;;;;AASAkO,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4BmB,IAA5B,GAAmC,YAAY;AAC3C,SAAKggB,iBAAL,CAAuB9hB,OAAvB,CAA+B,UAAUiiB,QAAV,EAAoB;AAAE,aAAOA,QAAQ,CAACngB,IAAT,EAAP;AAAyB,KAA9E;AACH,GAFD;AAGA;;;;;;;AAKA6f,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4ByC,KAA5B,GAAoC,YAAY;AAC5C,QAAI9D,KAAK,GAAG,IAAZ;;AACA,SAAKsiB,UAAL,GAAkB,IAAlB;AACA,SAAKC,iBAAL,CAAuB7hB,OAAvB,CAA+B,UAAUG,EAAV,EAAc;AACzC,UAAI0B,SAAS,GAAG1B,EAAE,CAAC0B,SAAnB;AAAA,UAA8BG,OAAO,GAAG7B,EAAE,CAAC6B,OAA3C;AACA,aAAO1C,KAAK,CAACsC,KAAN,CAAY4U,KAAZ,CAAkBlX,KAAlB,EAAyBuC,SAAzB,EAAoCK,IAApC,CAAyCF,OAAzC,CAAP;AACH,KAHD;AAIH,GAPD;AAQA;;;;;;;AAKA2f,EAAAA,iBAAiB,CAAChhB,SAAlB,CAA4B0C,OAA5B,GAAsC,YAAY;AAC9C,SAAKue,UAAL,GAAkB,KAAlB;AACA,SAAK9f,IAAL;AACH,GAHD;;AAIA,SAAO6f,iBAAP;AACH,CArKsC,EAAvC;AAsKA;;;;;AAGA,IAAIY,iBAAiB,GAAG,YAAY;AAAE,SAAO,IAAIZ,iBAAJ,EAAP;AAAiC,CAAvE;AAEA;;;;;AAGA,IAAIa,aAAa,GAAGzkB,aAAa,CAAC;AAC9B0kB,EAAAA,MAAM,EAAE;AADsB,CAAD,CAAjC;;AAGA,IAAIC,cAAc,GAAG,UAAU/iB,CAAV,EAAa;AAC9B,SAAO,OAAOA,CAAP,KAAa,QAAb,IAAyB2S,KAAK,CAACC,OAAN,CAAc5S,CAAd,CAAhC;AACH,CAFD;;AAGA,IAAIgjB,mBAAmB,GAAG,UAAUhjB,CAAV,EAAa;AACnC,SAAOA,CAAC,YAAYgiB,iBAApB;AACH,CAFD;AAGA;;;;;;;AAKA,IAAIiB,gBAAgB,GAAG,UAAUC,aAAV,EAAyBZ,QAAzB,EAAmChF,aAAnC,EAAkDD,QAAlD,EAA4D7c,EAA5D,EAAgE;AACnF,MAAI6c,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,IAAAA,QAAQ,GAAG,KAAX;AAAmB;;AAC9C,MAAI8F,OAAO,GAAG3iB,EAAE,CAAC2iB,OAAjB;AAAA,MAA0B5M,OAAO,GAAG/V,EAAE,CAAC+V,OAAvC;AAAA,MAAgD8L,QAAQ,GAAG7hB,EAAE,CAAC6hB,QAA9D;AAAA,MAAwEe,QAAQ,GAAG5iB,EAAE,CAAC4iB,QAAtF;AAAA,MAAgGC,UAAU,GAAG7iB,EAAE,CAAC6iB,UAAhH;AAAA,MAA4H7F,QAAQ,GAAGhd,EAAE,CAACgd,QAA1I,CAFmF,CAGnF;;AACA,MAAI8F,eAAe,GAAGjlB,UAAU,CAACke,eAAD,CAAhC;AACA,MAAIgH,UAAU,GAAGD,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,eAAe,CAACzG,EAAnG;AACAS,EAAAA,aAAa,CAACkG,cAAd,GAA+BN,aAAa,CAACK,UAAd,KAA6BA,UAA5D,CANmF,CAOnF;;AACA,MAAI,CAACD,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,eAAe,CAACH,OAAnF,MAAgGze,SAApG,EAA+G;AAC3Gye,IAAAA,OAAO,GAAGG,eAAe,CAACH,OAA1B;AACH;;AACD,MAAIM,YAAJ;;AACA,MAAIN,OAAO,KAAK,KAAZ,IAAqB,CAACH,mBAAmB,CAACzM,OAAD,CAA7C,EAAwD;AACpDkN,IAAAA,YAAY,GAAGlN,OAAf;AACH,GAFD,MAGK,IAAI,OAAO4M,OAAP,KAAmB,SAAvB,EAAkC;AACnCM,IAAAA,YAAY,GAAGN,OAAf;AACH,GAjBkF,CAkBnF;AACA;;;AACA,MAAIlB,UAAU,GAAG9jB,MAAM,CAAC,KAAD,CAAvB,CApBmF,CAqBnF;AACA;AACA;AACA;AACA;;AACA,MAAIulB,uBAAuB,GAAGrB,QAAQ,IAClCU,cAAc,CAACxM,OAAD,CADY,IAE1BwM,cAAc,CAACK,QAAD,CAFY,IAG1BL,cAAc,CAACM,UAAD,CAHY,IAI1BL,mBAAmB,CAACzM,OAAD,CAJvB,CA1BmF,CA+BnF;;AACA,MAAIoN,aAAa,GAAGZ,cAAc,CAACU,YAAD,CAAd,GACdA,YADc,GAEdP,aAAa,CAACC,OAFpB,CAhCmF,CAmCnF;AACA;;AACA,MAAIS,aAAa,GAAGb,cAAc,CAACxM,OAAD,CAAd,GACdA,OADc,GAEd2M,aAAa,CAAC3M,OAFpB,CArCmF,CAwCnF;AACA;;AACA,MAAIsN,iBAAiB,GAAGxG,QAAQ,GAAGsG,aAAH,GAAmB,IAAnD,CA1CmF,CA2CnF;AACA;AACA;AACA;;AACA,MAAIG,iBAAiB,GAAGJ,uBAAuB,IAAIX,cAAc,CAACa,aAAD,CAAzC,GAClBA,aADkB,GAElB,IAFN,CA/CmF,CAkDnF;AACA;AACA;;AACA,MAAInH,OAAO,GAAGje,OAAO,CAAC,YAAY;AAAE,WAAQ;AACxC8jB,MAAAA,QAAQ,EAAEoB,uBAAuB,GAC3BpB,QAD2B,GAE3BY,aAAa,CAACZ,QAHoB;AAIxCa,MAAAA,OAAO,EAAEQ,aAJ+B;AAKxCpN,MAAAA,OAAO,EAAEqN,aAL+B;AAMxCtG,MAAAA,aAAa,EAAEA,aANyB;AAOxC2E,MAAAA,UAAU,EAAEA,UAP4B;AAQxC8B,MAAAA,eAAe,EAAEb,aAAa,CAACa,eARS;AASxCR,MAAAA,UAAU,EAAEA;AAT4B,KAAR;AAU/B,GAVgB,EAUd,CACHM,iBADG,EAEHC,iBAFG,EAGHZ,aAAa,CAACa,eAHX,EAIHxN,OAJG,EAKHiH,QALG,EAMH+F,UANG,CAVc,CAArB,CArDmF,CAuEnF;;AACA9G,EAAAA,OAAO,CAACqG,MAAR,GAAiBzF,QAAjB,CAxEmF,CAyEnF;AACA;;AACAwE,EAAAA,uBAAuB,CAAC,YAAY;AAChC,QAAImC,cAAc,GAAGP,YAAY,IAAIP,aAAa,CAACC,OAAnD;AACAa,IAAAA,cAAc,IAAI1B,QAAQ,CAACzL,KAAT,CAAemN,cAAf,CAAlB;AACH,GAHsB,EAGpB,CAAC3G,QAHmB,CAAvB;AAIA/e,EAAAA,SAAS,CAAC,YAAY;AAClB2jB,IAAAA,UAAU,CAAC9hB,OAAX,GAAqB,IAArB;AACH,GAFQ,EAEN,EAFM,CAAT;AAGA,SAAOsc,OAAP;AACH,CAnFD;;AAqFA,IAAIwH,yBAAyB,GAAG,UAAUzjB,EAAV,EAAc;AAC1C,MAAI+V,OAAO,GAAG/V,EAAE,CAAC+V,OAAjB;AAAA,MAA0B8L,QAAQ,GAAG7hB,EAAE,CAAC6hB,QAAxC;AAAA,MAAkDvM,EAAE,GAAGtV,EAAE,CAAC0jB,OAA1D;AAAA,MAAmEA,OAAO,GAAGpO,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAApG;AACA,SAAQoO,OAAO,IACX,CAAC,CAAC7B,QADE,KAEH,CAAC9L,OAAD,IAAYA,OAAO,YAAYyL,iBAF5B,CAAR;AAGH,CALD;;AAOA,IAAImC,aAAa,GAAG,UAAU7kB,KAAV,EAAiB;AACjC,SAAOA,KAAK,YAAYG,WAAxB;AACH,CAFD;AAIA;;;;;;AAIA,SAAS2kB,eAAT,CAAyB9G,aAAzB,EAAwCF,KAAxC,EAA+C;AAC3C,MAAIld,IAAI,GAAGyZ,WAAW,CAAC0K,KAAD,CAAtB;AACA;;;;AAGA,OAAK,IAAIngB,GAAT,IAAgBhE,IAAhB,EAAsB;AAClB,QAAIokB,WAAW,GAAGlY,eAAe,CAAClI,GAAD,CAAf,IAAwBoI,qBAAqB,CAACpI,GAAD,CAA/D;AACA,QAAIqgB,YAAY,GAAGnH,KAAK,CAAClZ,GAAD,CAAxB;AACA,QAAIsgB,aAAa,GAAGpH,KAAK,CAACtO,KAAN,IAAesO,KAAK,CAACtO,KAAN,CAAY5K,GAAZ,CAAnC;AACA,QAAIugB,iBAAiB,GAAGF,YAAY,IAAIJ,aAAa,CAAC/G,KAAK,CAAClZ,GAAD,CAAN,CAArD;AACA,QAAIwgB,kBAAkB,GAAGF,aAAa,IAAIL,aAAa,CAAC/G,KAAK,CAACtO,KAAN,CAAY5K,GAAZ,CAAD,CAAvD;AACA,QAAIygB,gBAAgB,GAAGL,WAAW,IAAI,CAACC,YAAhB,IAAgC,CAACC,aAAxD;AACA,QAAII,kBAAkB,GAAG,CAACN,WAAD,IAAgB,CAACG,iBAAjB,IAAsC,CAACC,kBAAhE;;AACA,QAAIC,gBAAgB,IAAIC,kBAAxB,EAA4C;AACxCtH,MAAAA,aAAa,CAACjZ,WAAd,CAA0BH,GAA1B;AACA,aAAOhE,IAAI,CAACgE,GAAD,CAAX;AACH;AACJ;AACD;;;;;AAGA2gB,EAAAA,eAAe,CAACvH,aAAD,EAAgBpd,IAAhB,EAAsBkd,KAAtB,CAAf;AACA,MAAIA,KAAK,CAACtO,KAAV,EACI+V,eAAe,CAACvH,aAAD,EAAgBpd,IAAhB,EAAsBkd,KAAK,CAACtO,KAA5B,EAAmC,IAAnC,CAAf;AACJ;;;;;AAIA,MAAIsO,KAAK,CAAC0H,eAAV,EAA2B;AACvBxH,IAAAA,aAAa,CAACtG,UAAd,GAA2BoG,KAAK,CAAC0H,eAAN,CAAsBxH,aAAa,CAACtG,UAApC,CAA3B;AACH;AACJ;AACD;;;;;;;AAKA,SAAS6N,eAAT,CAAyBvH,aAAzB,EAAwCpd,IAAxC,EAA8C2R,MAA9C,EAAsDkT,OAAtD,EAA+D;AAC3D,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,KAAV;AAAkB;;AAC5C,MAAIA,OAAJ,EACIzH,aAAa,CAACtG,UAAd,GAA2B,EAA3B;;AACJ,OAAK,IAAI9S,GAAT,IAAgB2N,MAAhB,EAAwB;AACpB,QAAIvS,KAAK,GAAGuS,MAAM,CAAC3N,GAAD,CAAlB;AACA,QAAI8gB,gBAAgB,GAAG,KAAvB;;AACA,QAAIb,aAAa,CAAC7kB,KAAD,CAAjB,EAA0B;AACtB;AACA,UAAI,CAAC2lB,aAAa,CAAC9gB,GAAd,CAAkBD,GAAlB,CAAL,EAA6B;AACzBoZ,QAAAA,aAAa,CAAClZ,QAAd,CAAuBF,GAAvB,EAA4B5E,KAA5B;AACA0lB,QAAAA,gBAAgB,GAAG,IAAnB;AACH;AACJ,KAND,MAOK,IAAI5Y,eAAe,CAAClI,GAAD,CAAf,IAAwBoI,qBAAqB,CAACpI,GAAD,CAAjD,EAAwD;AACzD;AACA;AACA,UAAI,CAACoZ,aAAa,CAACrZ,QAAd,CAAuBC,GAAvB,CAAL,EAAkC;AAC9BoZ,QAAAA,aAAa,CAAClZ,QAAd,CAAuBF,GAAvB,EAA4BvB,WAAW,CAACrD,KAAD,CAAvC;AACH,OAFD,MAGK,IAAIA,KAAK,KAAKY,IAAI,CAACgE,GAAD,CAAlB,EAAyB;AAC1B;AACA;AACA,YAAIghB,MAAM,GAAG5H,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,CAAb;AACAghB,QAAAA,MAAM,CAACnkB,GAAP,CAAWzB,KAAX;AACH;;AACD0lB,MAAAA,gBAAgB,GAAG,IAAnB;AACH,KAbI,MAcA,IAAID,OAAJ,EAAa;AACdzH,MAAAA,aAAa,CAACtG,UAAd,CAAyB9S,GAAzB,IAAgC5E,KAAhC;AACH;;AACD,QAAI0lB,gBAAJ,EACI9kB,IAAI,CAACgE,GAAD,CAAJ,GAAY5E,KAAZ;AACP;AACJ;AACD;;;;;;AAIA,IAAI2lB,aAAa,GAAG,IAAIzjB,GAAJ,CAAQ,EAAR,CAApB;;AACA,IAAI6iB,KAAK,GAAG,YAAY;AAAE,SAAQ,EAAR;AAAc,CAAxC;;AAEA,IAAIc,aAAa,GAAG,UAAUnlB,CAAV,EAAa;AAC7B,SAAOolB,OAAO,CAACplB,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8BA,CAAC,CAAC7D,GAAhC,IAAuC6D,CAAC,CAACqlB,OAA1C,CAAd;AACH,CAFD;;AAGA,IAAIC,4BAA4B,GAAG,UAAUtlB,CAAV,EAAa;AAC5C;AACA,SAAO0S,iBAAiB,CAAC1S,CAAD,CAAjB,GAAuBA,CAAC,CAACA,CAAC,CAACkN,MAAF,GAAW,CAAZ,CAAD,IAAmB,CAA1C,GAA8ClN,CAArD;AACH,CAHD;AAKA;;;;;AAGA,IAAIulB,iBAAiB,GAAG,UAAUvlB,CAAV,EAAa;AAAE,SAAO,iBAAiB+G,IAAjB,CAAsB/G,CAAtB,CAAP;AAAkC,CAAzE;AAEA;;;;;AAGA,IAAIwlB,UAAU,GAAG,UAAUlI,aAAV,EAAyB;AACtC,MAAInd,OAAO,GAAG,EAAd;AACAmd,EAAAA,aAAa,CAAC3Y,YAAd,CAA2B,UAAUrF,KAAV,EAAiB4E,GAAjB,EAAsB;AAAE,WAAQ/D,OAAO,CAAC+D,GAAD,CAAP,GAAe5E,KAAK,CAACwC,GAAN,EAAvB;AAAsC,GAAzF;AACA,SAAO3B,OAAP;AACH,CAJD;AAKA;;;;;AAGA,IAAI6B,WAAW,GAAG,UAAUsb,aAAV,EAAyB;AACvC,MAAI1I,QAAQ,GAAG,EAAf;AACA0I,EAAAA,aAAa,CAAC3Y,YAAd,CAA2B,UAAUrF,KAAV,EAAiB4E,GAAjB,EAAsB;AAAE,WAAQ0Q,QAAQ,CAAC1Q,GAAD,CAAR,GAAgB5E,KAAK,CAAC0C,WAAN,EAAxB;AAA+C,GAAlG;AACA,SAAO4S,QAAP;AACH,CAJD;AAKA;;;;;;AAIA,IAAI6Q,gBAAgB,GAAG,UAAUC,CAAV,EAAa;AAChC,SAAO,OAAOA,CAAP,KAAa,UAApB;AACH,CAFD;AAGA;;;;;AAGA,IAAIC,eAAe,GAAG,UAAU3lB,CAAV,EAAa;AAAE,SAAO2S,KAAK,CAACC,OAAN,CAAc5S,CAAd,CAAP;AAA0B,CAA/D;AACA;;;;;;;AAKA,IAAI4lB,8BAA8B;AAAG;AAAe,YAAY;AAC5D,WAASA,8BAAT,CAAwCtI,aAAxC,EAAuD9c,EAAvD,EAA2D;AACvD,QAAIb,KAAK,GAAG,IAAZ;;AACA,QAAIkmB,oBAAoB,GAAGrlB,EAAE,CAACqlB,oBAA9B;AACA;;;;;;AAKA,SAAKzI,KAAL,GAAa,EAAb;AACA;;;;AAGA,SAAKiF,QAAL,GAAgB,EAAhB;AACA;;;;AAGA,SAAKyD,UAAL,GAAkB,EAAlB;AACA;;;;AAGA,SAAKC,SAAL,GAAiB,EAAjB;AACA;;;;AAGA,SAAKC,iBAAL,GAAyB,EAAzB;AACA;;;;AAGA,SAAKC,eAAL,GAAuB,IAAIzkB,GAAJ,EAAvB;AACA;;;;AAGA,SAAKiB,WAAL,GAAmB,IAAIjB,GAAJ,EAAnB;AACA;;;;;AAIA,SAAKyC,QAAL,GAAgB,UAAUC,GAAV,EAAe;AAAE,aAAO,CAACvE,KAAK,CAAC2d,aAAN,CAAoBrZ,QAApB,CAA6BC,GAA7B,CAAR;AAA4C,KAA7E;;AACA,SAAKoZ,aAAL,GAAqBA,aAArB;AACA,SAAKuI,oBAAL,GAA4BA,oBAA5B;AACA,SAAKvI,aAAL,CAAmB3Y,YAAnB,CAAgC,UAAUrF,KAAV,EAAiB4E,GAAjB,EAAsB;AAAE,aAAQvE,KAAK,CAACmmB,UAAN,CAAiB5hB,GAAjB,IAAwB5E,KAAK,CAACwC,GAAN,EAAhC;AAA+C,KAAvG;AACH;AACD;;;;;;AAIA8jB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCklB,QAAzC,GAAoD,UAAU9I,KAAV,EAAiB;AACjE,SAAKA,KAAL,GAAaA,KAAb;AACH,GAFD;AAGA;;;;;;AAIAwI,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCohB,WAAzC,GAAuD,UAAUC,QAAV,EAAoB;AACvE,QAAIA,QAAJ,EACI,KAAKA,QAAL,GAAgBA,QAAhB;AACP,GAHD;AAIA;;;;;;AAIAuD,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCuhB,oBAAzC,GAAgE,UAAUnN,UAAV,EAAsB;AAClF,QAAIA,UAAJ,EACI,KAAKoN,iBAAL,GAAyBpN,UAAzB;AACP,GAHD;AAIA;;;;;;;;AAMAwQ,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCmlB,SAAzC,GAAqD,UAAUrS,UAAV,EAAsBtT,EAAtB,EAA0B;AAC3E,QAAIsV,EAAE,GAAGtV,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9B;AAAA,QAAkC0a,EAAE,GAAGpF,EAAE,CAACsQ,QAA1C;AAAA,QAAoDA,QAAQ,GAAGlL,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAI1Z,GAAJ,EAAhB,GAA4B0Z,EAA3F;AAAA,QAA+FmL,QAAQ,GAAGvQ,EAAE,CAACuQ,QAA7G;;AACA,QAAIC,EAAE,GAAG,KAAKC,cAAL,CAAoBzS,UAApB,CAAT;AAAA,QAA0CpC,MAAM,GAAG4U,EAAE,CAAC5U,MAAtD;AAAA,QAA8D0N,aAAa,GAAGkH,EAAE,CAAClH,aAAjF;;AACA1N,IAAAA,MAAM,GAAG,KAAKoT,eAAL,CAAqBnpB,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK+V,MAAL,CAAT,EAAuB0N,aAAvB,CAA7B,CAAT;;AACA,SAAK,IAAIlb,GAAT,IAAgBwN,MAAhB,EAAwB;AACpB,UAAI0U,QAAQ,CAACjiB,GAAT,CAAaD,GAAb,CAAJ,EACI;AACJkiB,MAAAA,QAAQ,CAAC/kB,GAAT,CAAa6C,GAAb;;AACA,UAAIwN,MAAJ,EAAY;AACR,YAAI8U,WAAW,GAAGlB,4BAA4B,CAAC5T,MAAM,CAACxN,GAAD,CAAP,CAA9C;;AACA,YAAI,KAAKoZ,aAAL,CAAmBrZ,QAAnB,CAA4BC,GAA5B,CAAJ,EAAsC;AAClC,cAAI5E,KAAK,GAAG,KAAKge,aAAL,CAAmB9Y,QAAnB,CAA4BN,GAA5B,CAAZ;AACA5E,UAAAA,KAAK,IAAIA,KAAK,CAACyB,GAAN,CAAUylB,WAAV,CAAT;AACH,SAHD,MAIK;AACD,eAAKlJ,aAAL,CAAmBlZ,QAAnB,CAA4BF,GAA5B,EAAiCvB,WAAW,CAAC6jB,WAAD,CAA5C;AACH;;AACD,YAAI,CAACH,QAAL,EACI,KAAKP,UAAL,CAAgB5hB,GAAhB,IAAuBsiB,WAAvB;AACP;AACJ;AACJ,GArBD;AAsBA;;;;;;;;;;AAQAZ,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC8jB,eAAzC,GAA2D,UAAU9hB,MAAV,EAAkB;AACzE,QAAI8hB,eAAe,GAAG,KAAK1H,KAAL,CAAW0H,eAAjC;AACA,WAAOA,eAAe,GAAGA,eAAe,CAAC9hB,MAAD,CAAlB,GAA6BA,MAAnD;AACH,GAHD;AAIA;;;;;;;;;;;;AAUA4iB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCylB,iBAAzC,GAA6D,UAAU/U,MAAV,EAAkB;AAC3E,QAAIgV,YAAY,GAAGrR,MAAM,CAACC,IAAP,CAAY5D,MAAZ,EAAoB6O,MAApB,CAA2B,KAAKtc,QAAhC,CAAnB;AACA,QAAI0iB,YAAY,GAAGD,YAAY,CAACxZ,MAAhC;AACA,QAAI,CAACyZ,YAAL,EACI;;AACJ,SAAK,IAAIxZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwZ,YAApB,EAAkCxZ,CAAC,EAAnC,EAAuC;AACnC,UAAIjJ,GAAG,GAAGwiB,YAAY,CAACvZ,CAAD,CAAtB;AACA,UAAIqZ,WAAW,GAAG9U,MAAM,CAACxN,GAAD,CAAxB;AACA,UAAI5E,KAAK,GAAG,IAAZ,CAHmC,CAInC;AACA;;AACA,UAAIqT,KAAK,CAACC,OAAN,CAAc4T,WAAd,CAAJ,EAAgC;AAC5BlnB,QAAAA,KAAK,GAAGknB,WAAW,CAAC,CAAD,CAAnB;AACH,OARkC,CASnC;AACA;AACA;;;AACA,UAAIlnB,KAAK,KAAK,IAAd,EAAoB;AAChB,YAAIsnB,SAAS,GAAG,KAAKtJ,aAAL,CAAmBzF,eAAnB,CAAmC3T,GAAnC,CAAhB;AACA5E,QAAAA,KAAK,GAAGsnB,SAAS,KAAKliB,SAAd,GAA0BkiB,SAA1B,GAAsClV,MAAM,CAACxN,GAAD,CAApD;AACAtH,QAAAA,SAAS,CAAC0C,KAAK,KAAK,IAAX,EAAiB,4BAA4B4E,GAA5B,GAAkC,oDAAlC,GAAyFA,GAAzF,GAA+F,iCAAhH,CAAT;AACH;;AACD,UAAI,OAAO5E,KAAP,KAAiB,QAAjB,IAA6BimB,iBAAiB,CAACjmB,KAAD,CAAlD,EAA2D;AACvD;AACAA,QAAAA,KAAK,GAAGE,UAAU,CAACF,KAAD,CAAlB;AACH,OAHD,MAIK,IAAI,CAACgM,aAAa,CAAChM,KAAD,CAAd,IAAyBtC,OAAO,CAAC+J,IAAR,CAAayf,WAAb,CAA7B,EAAwD;AACzD;AACAlnB,QAAAA,KAAK,GAAGtC,OAAO,CAAC6pB,iBAAR,CAA0BL,WAA1B,CAAR;AACH;;AACD,WAAKlJ,aAAL,CAAmBlZ,QAAnB,CAA4BF,GAA5B,EAAiCvB,WAAW,CAACrD,KAAD,CAA5C;AACA,WAAKwmB,UAAL,CAAgB5hB,GAAhB,IAAuB5E,KAAvB;AACH;AACJ,GAjCD;AAkCA;;;;;;AAIAsmB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCulB,cAAzC,GAA0D,UAAUO,OAAV,EAAmB;AACzE,QAAI,CAACA,OAAL,EAAc;AACV,aAAO;AACHpV,QAAAA,MAAM,EAAEhN,SADL;AAEH0Q,QAAAA,UAAU,EAAE1Q,SAFT;AAGH0a,QAAAA,aAAa,EAAE1a;AAHZ,OAAP;AAKH;;AACD,QAAI+gB,gBAAgB,CAACqB,OAAD,CAApB,EAA+B;AAC3B;AACAA,MAAAA,OAAO,GAAGA,OAAO,CAAC,KAAK1J,KAAL,CAAW2J,MAAZ,EAAoBvB,UAAU,CAAC,KAAKlI,aAAN,CAA9B,EAAoDtb,WAAW,CAAC,KAAKsb,aAAN,CAA/D,CAAjB;AACH;;AACD,QAAI9c,EAAE,GAAGsmB,OAAO,CAAC1R,UAAjB;AAAA,QAA6BA,UAAU,GAAG5U,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAKgiB,iBAArB,GAAyChiB,EAAnF;AAAA,QAAuF4e,aAAa,GAAG0H,OAAO,CAAC1H,aAA/G;AAAA,QAA8H1N,MAAM,GAAG7V,MAAM,CAACirB,OAAD,EAAU,CAAC,YAAD,EAAe,eAAf,CAAV,CAA7I;;AACA,WAAO;AAAE1R,MAAAA,UAAU,EAAEA,UAAd;AAA0BgK,MAAAA,aAAa,EAAEA,aAAzC;AAAwD1N,MAAAA,MAAM,EAAEA;AAAhE,KAAP;AACH,GAdD;AAeA;;;;;AAGAkU,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCgmB,kBAAzC,GAA8D,YAAY;AACtE,QAAI,CAAC,KAAKf,eAAL,CAAqBnd,IAA1B,EACI,OAAO,CAAP;AACJ,WAAO3B,IAAI,CAACnB,GAAL,CAAS6Q,KAAT,CAAe1P,IAAf,EAAqBwL,KAAK,CAACgC,IAAN,CAAW,KAAKsR,eAAhB,CAArB,CAAP;AACH,GAJD;AAKA;;;;;;;;;;;AASAL,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCimB,WAAzC,GAAuD,UAAUnT,UAAV,EAAsBoT,aAAtB,EAAqC;AACxF,SAAKnB,SAAL,CAAemB,aAAf,IAAgCpT,UAAhC;;AACA,QAAI,KAAKhR,QAAT,EAAmB;AACf,WAAKA,QAAL,CAAczC,OAAd,CAAsB,UAAU2D,KAAV,EAAiB;AACnC,eAAOA,KAAK,CAACijB,WAAN,CAAkBnT,UAAlB,EAA8BoT,aAA9B,CAAP;AACH,OAFD;AAGH;AACJ,GAPD;AAQA;;;;;;AAIAtB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCmmB,aAAzC,GAAyD,UAAUD,aAAV,EAAyB;AAC9E,QAAIE,QAAQ,GAAG,KAAKrB,SAAL,CAAemB,aAAf,CAAf;;AACA,QAAIE,QAAJ,EAAc;AACV,aAAO,KAAKnlB,KAAL,CAAWmlB,QAAX,EAAqB;AAAEf,QAAAA,QAAQ,EAAEa;AAAZ,OAArB,CAAP;AACH;AACJ,GALD;AAMA;;;;;;;AAKAtB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCqmB,aAAzC,GAAyD,UAAUH,aAAV,EAAyB;AAC9E,QAAIvnB,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKmD,QAAT,EAAmB;AACf,WAAKA,QAAL,CAAczC,OAAd,CAAsB,UAAU2D,KAAV,EAAiB;AAAE,eAAOA,KAAK,CAACqjB,aAAN,CAAoBH,aAApB,CAAP;AAA4C,OAArF;AACH;;AACD,QAAIE,QAAQ,GAAG,KAAKrB,SAAL,CAAemB,aAAf,CAAf;AACA,QAAI,CAACE,QAAL,EACI;AACJ,SAAKnB,eAAL,CAAqB3kB,MAArB,CAA4B4lB,aAA5B;AACA,QAAII,OAAO,GAAG,KAAKN,kBAAL,EAAd;AACA,SAAKO,gBAAL;;AACA,QAAID,OAAJ,EAAa;AACT,UAAIE,eAAe,GAAG,KAAKzB,SAAL,CAAeuB,OAAf,CAAtB;AACAE,MAAAA,eAAe,IAAI,KAAKL,aAAL,CAAmBG,OAAnB,CAAnB;AACH,KAd6E,CAe9E;;;AACA,QAAIG,cAAc,GAAG,KAAKzB,iBAAL,CAAuBkB,aAAvB,CAArB;AACA,QAAI,CAACO,cAAL,EACI;AACJ,QAAIC,eAAe,GAAG,EAAtB;;AACA,SAAK,IAAIxjB,GAAT,IAAgB,KAAK4hB,UAArB,EAAiC;AAC7B,UAAI2B,cAAc,CAACvjB,GAAD,CAAd,KAAwBQ,SAA5B,EAAuC;AACnCgjB,QAAAA,eAAe,CAACxjB,GAAD,CAAf,GAAuB,KAAK4hB,UAAL,CAAgB5hB,GAAhB,CAAvB;AACH;AACJ;;AACD,SAAKyjB,OAAL;AACA,SAAKpR,OAAL,CAAamR,eAAb,EAA8BnlB,IAA9B,CAAmC,YAAY;AAAE,aAAO5C,KAAK,CAACioB,UAAN,EAAP;AAA4B,KAA7E;AACH,GA3BD;AA4BA;;;;;AAGAhC,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC6V,KAAzC,GAAiD,UAAU/C,UAAV,EAAsB;AACnE,QAAInB,KAAK,CAACC,OAAN,CAAckB,UAAd,CAAJ,EAA+B;AAC3B,aAAO,KAAK+T,kBAAL,CAAwB/T,UAAxB,CAAP;AACH,KAFD,MAGK,IAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AACrC,aAAO,KAAK+T,kBAAL,CAAwB,CAAC/T,UAAD,CAAxB,CAAP;AACH,KAFI,MAGA;AACD,WAAKqS,SAAL,CAAerS,UAAf;AACH;AACJ,GAVD;AAWA;;;;;AAGA8R,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC6mB,kBAAzC,GAA8D,UAAUC,gBAAV,EAA4B;AACtF,QAAInoB,KAAK,GAAG,IAAZ;;AACA,QAAIymB,QAAQ,GAAG,IAAI5kB,GAAJ,EAAf;;AACA,QAAIumB,YAAY,GAAGnsB,cAAc,CAACksB,gBAAD,CAAd,CAAiCE,OAAjC,EAAnB;;AACAD,IAAAA,YAAY,CAAC1nB,OAAb,CAAqB,UAAU6D,GAAV,EAAe;AAChC,UAAI1D,EAAE,GAAGb,KAAK,CAAC4mB,cAAN,CAAqB5mB,KAAK,CAAC0iB,QAAN,CAAene,GAAf,CAArB,CAAT;AAAA,UAAoDwN,MAAM,GAAGlR,EAAE,CAACkR,MAAhE;AAAA,UAAwE0N,aAAa,GAAG5e,EAAE,CAAC4e,aAA3F;;AACA,UAAIA,aAAJ,EAAmB;AACfzf,QAAAA,KAAK,CAACwmB,SAAN,CAAgB/G,aAAhB,EAA+B;AAAEgH,UAAAA,QAAQ,EAAEA;AAAZ,SAA/B;AACH;;AACD,UAAI1U,MAAJ,EAAY;AACR/R,QAAAA,KAAK,CAACwmB,SAAN,CAAgBzU,MAAhB,EAAwB;AAAE0U,UAAAA,QAAQ,EAAEA;AAAZ,SAAxB;AACH;;AACD,UAAIzmB,KAAK,CAACmD,QAAN,IAAkBnD,KAAK,CAACmD,QAAN,CAAegG,IAArC,EAA2C;AACvCnJ,QAAAA,KAAK,CAACmD,QAAN,CAAezC,OAAf,CAAuB,UAAU2D,KAAV,EAAiB;AACpC,iBAAOA,KAAK,CAAC6jB,kBAAN,CAAyBC,gBAAzB,CAAP;AACH,SAFD;AAGH;AACJ,KAbD;AAcH,GAlBD;;AAmBAlC,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCiB,KAAzC,GAAiD,UAAU6R,UAAV,EAAsBY,IAAtB,EAA4B;AACzE,QAAI/U,KAAK,GAAG,IAAZ;;AACA,QAAI+U,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAEA,MAAAA,IAAI,GAAG,EAAP;AAAY;;AACnC,QAAIA,IAAI,CAAC2R,QAAT,EAAmB;AACf,WAAKJ,eAAL,CAAqB5kB,GAArB,CAAyBqT,IAAI,CAAC2R,QAA9B;AACH;;AACD,SAAKkB,gBAAL,CAAsB7S,IAAI,CAAC2R,QAA3B;AACA,QAAInkB,SAAJ;;AACA,QAAIyjB,eAAe,CAAC7R,UAAD,CAAnB,EAAiC;AAC7B5R,MAAAA,SAAS,GAAG,KAAK+lB,oBAAL,CAA0BnU,UAA1B,EAAsCY,IAAtC,CAAZ;AACH,KAFD,MAGK,IAAI,OAAOZ,UAAP,KAAsB,QAA1B,EAAoC;AACrC5R,MAAAA,SAAS,GAAG,KAAKgmB,cAAL,CAAoBpU,UAApB,EAAgCY,IAAhC,CAAZ;AACH,KAFI,MAGA;AACDxS,MAAAA,SAAS,GAAG,KAAKqU,OAAL,CAAazC,UAAb,EAAyBY,IAAzB,CAAZ;AACH;;AACD,SAAKiT,OAAL;AACA,WAAOzlB,SAAS,CAACK,IAAV,CAAe,YAAY;AAAE,aAAO5C,KAAK,CAACioB,UAAN,EAAP;AAA4B,KAAzD,CAAP;AACH,GAnBD;;AAoBAhC,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCuV,OAAzC,GAAmD,UAAU4R,mBAAV,EAA+B3nB,EAA/B,EAAmC;AAClF,QAAIb,KAAK,GAAG,IAAZ;;AACA,QAAImW,EAAE,GAAGtV,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9B;AAAA,QAAkC0a,EAAE,GAAGpF,EAAE,CAACpY,KAA1C;AAAA,QAAiDA,KAAK,GAAGwd,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAA7E;AAAA,QAAiFoL,EAAE,GAAGxQ,EAAE,CAACuQ,QAAzF;AAAA,QAAmGA,QAAQ,GAAGC,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAAlI;AAAA,QAAsI7D,kBAAkB,GAAG3M,EAAE,CAAC2M,kBAA9J;;AACA,QAAI2F,EAAE,GAAG,KAAK7B,cAAL,CAAoB4B,mBAApB,CAAT;AAAA,QAAmDzW,MAAM,GAAG0W,EAAE,CAAC1W,MAA/D;AAAA,QAAuE0D,UAAU,GAAGgT,EAAE,CAAChT,UAAvF;AAAA,QAAmGgK,aAAa,GAAGgJ,EAAE,CAAChJ,aAAtH;;AACA,QAAIqD,kBAAJ,EAAwB;AACpBrN,MAAAA,UAAU,GAAGqN,kBAAb;AACH;;AACD,QAAI,CAAC/Q,MAAL,EACI,OAAOtP,OAAO,CAACC,OAAR,EAAP;AACJqP,IAAAA,MAAM,GAAG,KAAKoT,eAAL,CAAqBpT,MAArB,CAAT;;AACA,QAAI0N,aAAJ,EAAmB;AACfA,MAAAA,aAAa,GAAG,KAAK0F,eAAL,CAAqB1F,aAArB,CAAhB;AACH;;AACD,SAAKqH,iBAAL,CAAuB/U,MAAvB;AACA,QAAI9K,MAAM,GAAG,KAAKke,eAAL,CAAqBuD,SAAS,CAAC3W,MAAD,EAAS0D,UAAT,EAAqB,KAAKkI,aAA1B,CAA9B,CAAb;;AACA,QAAI,KAAKuI,oBAAT,EAA+B;AAC3B,UAAIyC,UAAU,GAAG,KAAKzC,oBAAL,CAA0B,KAAKvI,aAA/B,EAA8C5L,MAA9C,EAAsD9K,MAAtD,EAA8DwY,aAA9D,CAAjB;AACA1N,MAAAA,MAAM,GAAG4W,UAAU,CAAC5W,MAApB;AACA0N,MAAAA,aAAa,GAAGkJ,UAAU,CAAClJ,aAA3B;AACH;;AACD,QAAIiH,QAAJ,EAAc;AACV,WAAKL,iBAAL,CAAuBK,QAAvB,IAAmC3U,MAAnC;AACH;;AACD,SAAK+U,iBAAL,CAAuB/U,MAAvB;AACA,QAAI6W,UAAU,GAAG,EAAjB;;AACA,SAAK,IAAIrkB,GAAT,IAAgBwN,MAAhB,EAAwB;AACpB,UAAIpS,KAAK,GAAG,KAAKge,aAAL,CAAmB9Y,QAAnB,CAA4BN,GAA5B,CAAZ;AACA,UAAI,CAAC5E,KAAD,IAAU,CAACoS,MAAX,IAAqBA,MAAM,CAACxN,GAAD,CAAN,KAAgBQ,SAAzC,EACI;AACJ,UAAI8jB,WAAW,GAAG9W,MAAM,CAACxN,GAAD,CAAxB;;AACA,UAAI,CAACmiB,QAAL,EAAe;AACX,aAAKP,UAAL,CAAgB5hB,GAAhB,IAAuBohB,4BAA4B,CAACkD,WAAD,CAAnD;AACH;;AACD,UAAI,KAAK/lB,WAAL,CAAiB0B,GAAjB,CAAqBD,GAArB,CAAJ,EACI;AACJ,WAAKzB,WAAL,CAAiBpB,GAAjB,CAAqB6C,GAArB;AACAqkB,MAAAA,UAAU,CAACzc,IAAX,CAAgBmK,cAAc,CAAC/R,GAAD,EAAM5E,KAAN,EAAakpB,WAAb,EAA0B7sB,QAAQ,CAAC;AAAE+B,QAAAA,KAAK,EAAEA;AAAT,OAAD,EAAmB0X,UAAnB,CAAlC,CAA9B;AACH;;AACD,QAAIqT,aAAa,GAAGrmB,OAAO,CAACugB,GAAR,CAAY4F,UAAZ,CAApB;AACA,WAAOnJ,aAAa,GACdqJ,aAAa,CAAClmB,IAAd,CAAmB,YAAY;AAC7B5C,MAAAA,KAAK,CAACwmB,SAAN,CAAgB/G,aAAhB,EAA+B;AAAEiH,QAAAA,QAAQ,EAAEA;AAAZ,OAA/B;AACH,KAFC,CADc,GAIdoC,aAJN;AAKH,GA5CD;;AA6CA7C,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCinB,oBAAzC,GAAgE,UAAUS,aAAV,EAAyBhU,IAAzB,EAA+B;AAC3F,QAAI/U,KAAK,GAAG,IAAZ;;AACA,QAAI4oB,UAAU,GAAG3sB,cAAc,CAAC8sB,aAAD,CAAd,CAA8BV,OAA9B,GACZlT,GADY,CACR,UAAU6T,KAAV,EAAiB;AAAE,aAAOhpB,KAAK,CAACuoB,cAAN,CAAqBS,KAArB,EAA4BjU,IAA5B,CAAP;AAA2C,KADtD,CAAjB;;AAEA,WAAOtS,OAAO,CAACugB,GAAR,CAAY4F,UAAZ,CAAP;AACH,GALD;;AAMA3C,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCknB,cAAzC,GAA0D,UAAUU,YAAV,EAAwBlU,IAAxB,EAA8B;AACpF,QAAI/U,KAAK,GAAG,IAAZ;;AACA,QAAIqV,IAAI,GAAG,KAAX;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,eAAe,GAAG,CAAtB;AACA,QAAIC,gBAAgB,GAAG,CAAvB;AACA,QAAIkR,QAAQ,GAAI3R,IAAI,IAAIA,IAAI,CAAC2R,QAAd,IAA2B,CAA1C;AACA,QAAIS,OAAO,GAAG,KAAKzE,QAAL,CAAcuG,YAAd,CAAd;AACA,QAAIC,aAAa,GAAG/B,OAAO,GACrB,YAAY;AAAE,aAAOnnB,KAAK,CAAC4W,OAAN,CAAcuQ,OAAd,EAAuBpS,IAAvB,CAAP;AAAsC,KAD/B,GAErB,YAAY;AAAE,aAAOtS,OAAO,CAACC,OAAR,EAAP;AAA2B,KAF/C;AAGA,QAAIymB,qBAAqB,GAAG,KAAKhmB,QAAL,GACtB,YAAY;AACV,aAAOnD,KAAK,CAACopB,eAAN,CAAsBH,YAAtB,EAAoC3T,aAApC,EAAmDC,eAAnD,EAAoEC,gBAApE,EAAsFkR,QAAtF,CAAP;AACH,KAHuB,GAItB,YAAY;AAAE,aAAOjkB,OAAO,CAACC,OAAR,EAAP;AAA2B,KAJ/C;;AAKA,QAAIykB,OAAO,IAAI,KAAKhkB,QAApB,EAA8B;AAC1B,UAAIsS,UAAU,GAAG,KAAKmR,cAAL,CAAoBO,OAApB,EAA6B1R,UAA9C;;AACA,UAAIA,UAAJ,EAAgB;AACZJ,QAAAA,IAAI,GAAGI,UAAU,CAACJ,IAAX,IAAmBA,IAA1B;AACAC,QAAAA,aAAa,GAAGG,UAAU,CAACH,aAAX,IAA4BA,aAA5C;AACAC,QAAAA,eAAe,GAAGE,UAAU,CAACF,eAAX,IAA8BA,eAAhD;AACAC,QAAAA,gBAAgB,GACZC,UAAU,CAACD,gBAAX,IAA+BA,gBADnC;AAEH;AACJ;;AACD,QAAIH,IAAJ,EAAU;AACN,UAAIxU,EAAE,GAAGwU,IAAI,KAAK,gBAAT,GACH,CAAC6T,aAAD,EAAgBC,qBAAhB,CADG,GAEH,CAACA,qBAAD,EAAwBD,aAAxB,CAFN;AAAA,UAE8CG,KAAK,GAAGxoB,EAAE,CAAC,CAAD,CAFxD;AAAA,UAE6DyoB,IAAI,GAAGzoB,EAAE,CAAC,CAAD,CAFtE;;AAGA,aAAOwoB,KAAK,GAAGzmB,IAAR,CAAa0mB,IAAb,CAAP;AACH,KALD,MAMK;AACD,aAAO7mB,OAAO,CAACugB,GAAR,CAAY,CAACkG,aAAa,EAAd,EAAkBC,qBAAqB,EAAvC,CAAZ,CAAP;AACH;AACJ,GAnCD;;AAoCAlD,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC+nB,eAAzC,GAA2D,UAAUH,YAAV,EAAwB3T,aAAxB,EAAuCC,eAAvC,EAAwDC,gBAAxD,EAA0EkR,QAA1E,EAAoF;AAC3I,QAAIpR,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,MAAAA,aAAa,GAAG,CAAhB;AAAoB;;AACpD,QAAIC,eAAe,KAAK,KAAK,CAA7B,EAAgC;AAAEA,MAAAA,eAAe,GAAG,CAAlB;AAAsB;;AACxD,QAAIC,gBAAgB,KAAK,KAAK,CAA9B,EAAiC;AAAEA,MAAAA,gBAAgB,GAAG,CAAnB;AAAuB;;AAC1D,QAAIkR,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,MAAAA,QAAQ,GAAG,CAAX;AAAe;;AAC1C,QAAI,CAAC,KAAKvjB,QAAV,EAAoB;AAChB,aAAOV,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,QAAIkmB,UAAU,GAAG,EAAjB;AACA,QAAIW,kBAAkB,GAAG,CAAC,KAAKpmB,QAAL,CAAcgG,IAAd,GAAqB,CAAtB,IAA2BoM,eAApD;AACA,QAAIiU,uBAAuB,GAAGhU,gBAAgB,KAAK,CAArB,GACxB,UAAUhI,CAAV,EAAa;AAAE,aAAOA,CAAC,GAAG+H,eAAX;AAA6B,KADpB,GAExB,UAAU/H,CAAV,EAAa;AAAE,aAAO+b,kBAAkB,GAAG/b,CAAC,GAAG+H,eAAhC;AAAkD,KAFvE;AAGAvC,IAAAA,KAAK,CAACgC,IAAN,CAAW,KAAK7R,QAAhB,EAA0BzC,OAA1B,CAAkC,UAAU+oB,aAAV,EAAyBjc,CAAzB,EAA4B;AAC1D,UAAIjL,SAAS,GAAGknB,aAAa,CAAClB,cAAd,CAA6BU,YAA7B,EAA2C;AACvDvC,QAAAA,QAAQ,EAAEA,QAD6C;AAEvD3oB,QAAAA,KAAK,EAAEuX,aAAa,GAAGkU,uBAAuB,CAAChc,CAAD;AAFS,OAA3C,CAAhB;AAIAob,MAAAA,UAAU,CAACzc,IAAX,CAAgB5J,SAAhB;AACH,KAND;AAOA,WAAOE,OAAO,CAACugB,GAAR,CAAY4F,UAAZ,CAAP;AACH,GArBD;;AAsBA3C,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC2mB,OAAzC,GAAmD,YAAY;AAC3D,QAAI0B,gBAAgB,GAAG,KAAKjM,KAAL,CAAWiM,gBAAlC;AACAA,IAAAA,gBAAgB,IAAIA,gBAAgB,EAApC;AACH,GAHD;;AAIAzD,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC4mB,UAAzC,GAAsD,YAAY;AAC9D,QAAI0B,mBAAmB,GAAG,KAAKlM,KAAL,CAAWkM,mBAArC;AACAA,IAAAA,mBAAmB,IAAIA,mBAAmB,EAA1C;AACH,GAHD;;AAIA1D,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCuoB,wBAAzC,GAAoE,UAAUlD,QAAV,EAAoB;AACpF,QAAImD,YAAY,GAAG,KAAKzD,SAAL,CAAe7Y,MAAlC;;AACA,SAAK,IAAIC,CAAC,GAAGkZ,QAAQ,GAAG,CAAxB,EAA2BlZ,CAAC,GAAGqc,YAA/B,EAA6Crc,CAAC,EAA9C,EAAkD;AAC9C,UAAIsc,gBAAgB,GAAG,KAAKzD,iBAAL,CAAuB7Y,CAAvB,CAAvB;;AACA,UAAIsc,gBAAJ,EAAsB;AAClB,aAAK,IAAIvlB,GAAT,IAAgBulB,gBAAhB,EAAkC;AAC9B,eAAKhnB,WAAL,CAAiBpB,GAAjB,CAAqB6C,GAArB;AACH;AACJ;AACJ;AACJ,GAVD;;AAWA0hB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCumB,gBAAzC,GAA4D,UAAUlB,QAAV,EAAoB;AAC5E,QAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,MAAAA,QAAQ,GAAG,CAAX;AAAe;;AAC1C,SAAK5jB,WAAL,CAAiBf,KAAjB,GAF4E,CAG5E;AACA;;AACA,QAAI2kB,QAAQ,GAAG,KAAKW,kBAAL,EAAf,EAA0C;AACtC,WAAKuC,wBAAL,CAA8BlD,QAA9B;AACH;;AACD,QAAI,KAAKvjB,QAAT,EAAmB;AACf,WAAKA,QAAL,CAAczC,OAAd,CAAsB,UAAU2D,KAAV,EAAiB;AAAE,eAAOA,KAAK,CAACujB,gBAAN,CAAuBlB,QAAvB,CAAP;AAA0C,OAAnF;AACH;AACJ,GAXD;;AAYAT,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyCmB,IAAzC,GAAgD,YAAY;AACxD,SAAKmb,aAAL,CAAmB3Y,YAAnB,CAAgC,UAAUrF,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAAC6C,IAAN,EAAP;AAAsB,KAAzE;AACH,GAFD;AAGA;;;;;;AAIAyjB,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC0oB,QAAzC,GAAoD,UAAUpH,QAAV,EAAoB;AACpE,QAAI,CAAC,KAAKxf,QAAV,EAAoB;AAChB,WAAKA,QAAL,GAAgB,IAAItB,GAAJ,EAAhB;AACH;;AACD,SAAKsB,QAAL,CAAczB,GAAd,CAAkBihB,QAAlB,EAJoE,CAKpE;AACA;;AACA,SAAKyD,SAAL,CAAe1lB,OAAf,CAAuB,UAAU+mB,QAAV,EAAoBja,CAApB,EAAuB;AAC1Cia,MAAAA,QAAQ,IAAI9E,QAAQ,CAAC2E,WAAT,CAAqBG,QAArB,EAA+Bja,CAA/B,CAAZ;AACH,KAFD;AAGH,GAVD;;AAWAyY,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC2oB,WAAzC,GAAuD,UAAUrH,QAAV,EAAoB;AACvE,QAAI,CAAC,KAAKxf,QAAV,EAAoB;AAChB;AACH;;AACD,SAAKA,QAAL,CAAcxB,MAAd,CAAqBghB,QAArB;AACH,GALD;;AAMAsD,EAAAA,8BAA8B,CAAC5kB,SAA/B,CAAyC4oB,aAAzC,GAAyD,YAAY;AACjE,QAAI,KAAK9mB,QAAT,EACI,KAAKA,QAAL,CAAcpB,KAAd;AACP,GAHD;;AAIA,SAAOkkB,8BAAP;AACH,CA9cmD,EAApD;;AA+cA,SAASiE,uBAAT,CAAiC3lB,GAAjC,EAAsCkR,UAAtC,EAAkD;AAC9C,MAAI,CAACA,UAAL,EACI;AACJ,MAAI0U,eAAe,GAAG1U,UAAU,CAAClR,GAAD,CAAV,IAAmBkR,UAAU,CAAC,SAAD,CAA7B,IAA4CA,UAAlE;AACA,SAAO0U,eAAe,CAACnV,IAAvB;AACH;;AACD,SAAS0T,SAAT,CAAmB3W,MAAnB,EAA2B0D,UAA3B,EAAuCkI,aAAvC,EAAsD;AAClD,MAAI9c,EAAJ,EAAQsV,EAAR;;AACA,MAAIlP,MAAM,GAAG,EAAb;;AACA,OAAK,IAAI1C,GAAT,IAAgBwN,MAAhB,EAAwB;AACpB9K,IAAAA,MAAM,CAAC1C,GAAD,CAAN,GAAc,CAAC1D,EAAE,GAAGqpB,uBAAuB,CAAC3lB,GAAD,EAAMkR,UAAN,CAA7B,MAAoD,IAApD,IAA4D5U,EAAE,KAAK,KAAK,CAAxE,GAA4EA,EAA5E,GAAiF,CAACsV,EAAE,GAAGwH,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,CAAN,MAAuC,IAAvC,IAA+C4R,EAAE,KAAK,KAAK,CAA3D,GAA+D,KAAK,CAApE,GAAwEA,EAAE,CAAChU,GAAH,EAAvK;AACH;;AACD,SAAO8E,MAAP;AACH;AAED;;;;;;;;;AAOA,SAASmjB,yBAAT,CAAmCzM,aAAnC,EAAkDF,KAAlD,EAAyDja,MAAzD,EAAiE;AAC7D,MAAI6mB,yBAAyB,GAAG/F,yBAAyB,CAAC7G,KAAD,CAAzD;AACA,MAAIiF,QAAQ,GAAGjF,KAAK,CAACiF,QAArB;AAAA,MAA+BjN,UAAU,GAAGgI,KAAK,CAAChI,UAAlD;AACA,MAAI6U,cAAc,GAAG5rB,UAAU,CAACwkB,aAAD,CAAV,CAA0BP,QAA/C;AACA,MAAIgB,eAAe,GAAGjlB,UAAU,CAACke,eAAD,CAAhC;AACA,MAAI+F,QAAQ,GAAG3I,WAAW,CAAC,YAAY;AAAE,WAAO,IAAIiM,8BAAJ,CAAmCtI,aAAnC,EAAkDna,MAAlD,CAAP;AAAmE,GAAlF,CAA1B,CAL6D,CAM7D;;AACA,MAAI,CAACmgB,eAAD,IAAoBA,eAAe,CAAC5G,SAAxC,EAAmD;AAC/C4F,IAAAA,QAAQ,CAACsH,aAAT;AACAtH,IAAAA,QAAQ,CAAC4D,QAAT,CAAkB9I,KAAlB;AACAkF,IAAAA,QAAQ,CAACF,WAAT,CAAqBC,QAArB;AACAC,IAAAA,QAAQ,CAACC,oBAAT,CAA8BnN,UAA9B;AACH,GAZ4D,CAa7D;AACA;;;AACA9W,EAAAA,SAAS,CAAC,YAAY;AAClB,QAAI0rB,yBAAyB,IAAIC,cAAjC,EAAiD;AAC7CA,MAAAA,cAAc,CAACP,QAAf,CAAwBpH,QAAxB;AACH;AACJ,GAJQ,CAAT;AAKAhkB,EAAAA,SAAS,CAAC,YAAY;AAClB,WAAO,YAAY;AACf;AACA;AACA;AACA,UAAIgrB,mBAAmB,GAAGlM,KAAK,CAACkM,mBAAhC;AAAA,UAAqDY,YAAY,GAAGruB,MAAM,CAACuhB,KAAD,EAAQ,CAAC,qBAAD,CAAR,CAA1E;;AACAkF,MAAAA,QAAQ,CAAC4D,QAAT,CAAkBgE,YAAlB;AACAD,MAAAA,cAAc,IAAIA,cAAc,CAACN,WAAf,CAA2BrH,QAA3B,CAAlB;AACH,KAPD;AAQH,GATQ,EASN,EATM,CAAT;AAUA,SAAOA,QAAP;AACH;AAED;;;;;AAGA,IAAI6H,mBAAmB,GAAG/rB,aAAa,CAAC;AACpCqY,EAAAA,kBAAkB,EAAE,UAAUiP,CAAV,EAAa;AAAE,WAAOA,CAAP;AAAW,GADV;AAEpC0E,EAAAA,QAAQ,EAAE;AAF0B,CAAD,CAAvC;AAIA;;;;;;;AAMA,SAASC,aAAT,CAAuB7pB,EAAvB,EAA2B;AACvB,MAAIsC,QAAQ,GAAGtC,EAAE,CAACsC,QAAlB;AAAA,MAA4Bsa,KAAK,GAAGvhB,MAAM,CAAC2E,EAAD,EAAK,CAAC,UAAD,CAAL,CAA1C;;AACA,MAAI8pB,aAAa,GAAGjsB,UAAU,CAAC8rB,mBAAD,CAA9B;AACA,MAAI7qB,KAAK,GAAGnB,MAAM,CAACxC,QAAQ,CAAC,EAAD,EAAK2uB,aAAL,CAAT,CAAN,CAAoCnqB,OAAhD,CAHuB,CAIvB;AACA;;AACA,OAAK,IAAI+D,GAAT,IAAgBkZ,KAAhB,EAAuB;AACnB9d,IAAAA,KAAK,CAAC4E,GAAD,CAAL,GAAakZ,KAAK,CAAClZ,GAAD,CAAlB;AACH;;AACD,SAAQ3F,aAAa,CAAC4rB,mBAAmB,CAACI,QAArB,EAA+B;AAAEjrB,IAAAA,KAAK,EAAEA;AAAT,GAA/B,EAAiDwD,QAAjD,CAArB;AACH;;AAED,IAAI0nB,eAAJ;;AACA,CAAC,UAAUA,eAAV,EAA2B;AACxBA,EAAAA,eAAe,CAAC,QAAD,CAAf,GAA4B,QAA5B;AACAA,EAAAA,eAAe,CAAC,cAAD,CAAf,GAAkC,cAAlC;AACAA,EAAAA,eAAe,CAAC,uBAAD,CAAf,GAA2C,uBAA3C;AACH,CAJD,EAIGA,eAAe,KAAKA,eAAe,GAAG,EAAvB,CAJlB;;AAMA,IAAIC,uBAAuB,GAAG,UAAUC,IAAV,EAAgB;AAAE,SAAO,UAAUtN,KAAV,EAAiB;AACpEsN,IAAAA,IAAI,CAACtN,KAAD,CAAJ;AACA,WAAO,IAAP;AACH,GAH+C;AAG5C,CAHJ;;AAKA,SAASuN,cAAT,CAAwBC,IAAxB,EAA8B1qB,IAA9B,EAAoC;AAChC,MAAIA,IAAI,KAAK,IAAb,EACI,OAAO,KAAP;AACJ,MAAI2qB,UAAU,GAAG3qB,IAAI,CAACgN,MAAtB;AACA,MAAI2d,UAAU,KAAKD,IAAI,CAAC1d,MAAxB,EACI,OAAO,KAAP;;AACJ,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0d,UAApB,EAAgC1d,CAAC,EAAjC,EAAqC;AACjC,QAAIjN,IAAI,CAACiN,CAAD,CAAJ,KAAYyd,IAAI,CAACzd,CAAD,CAApB,EACI,OAAO,KAAP;AACP;;AACD,SAAO,IAAP;AACH;;AAED,IAAI2d,UAAU,GAAG,UAAU5qB,IAAV,EAAgB0qB,IAAhB,EAAsB;AACnC,SAAQA,IAAI,KAAKlmB,SAAT,KACHiO,KAAK,CAACC,OAAN,CAAc1S,IAAd,KAAuByS,KAAK,CAACC,OAAN,CAAcgY,IAAd,CAAvB,GACK,CAACD,cAAc,CAACC,IAAD,EAAO1qB,IAAP,CADpB,GAEKA,IAAI,KAAK0qB,IAHX,CAAR;AAIH,CALD;;AAMA,SAASG,uBAAT,CAAiCvqB,EAAjC,EAAqCwqB,kBAArC,EAAyD;AACrD,MAAIA,kBAAkB,KAAK,KAAK,CAAhC,EAAmC;AAAEA,IAAAA,kBAAkB,GAAG,KAArB;AAA6B;;AAClE,MAAI5V,UAAU,GAAG5U,EAAE,CAAC4U,UAApB;AAAA,MAAgCgK,aAAa,GAAG5e,EAAE,CAAC4e,aAAnD;AAAA,MAAkE1N,MAAM,GAAG7V,MAAM,CAAC2E,EAAD,EAAK,CAAC,YAAD,EAAe,eAAf,CAAL,CAAjF;;AACA,SAAOwqB,kBAAkB,GACnBrvB,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK+V,MAAL,CAAT,EAAuB0N,aAAvB,CADW,GAEnB1N,MAFN;AAGH;AACD;;;;;;;;;;;;;;;;;;;;;;;AAqBA,SAASuZ,cAAT,CAAwBC,mBAAxB,EAA6C5I,QAA7C,EAAuDhF,aAAvD,EAAsEkF,iBAAtE,EAAyF;AACrF,MAAIT,eAAe,GAAG5jB,MAAM,CAAC,IAAD,CAA5B;AACA,MAAIgtB,UAAU,GAAGhtB,MAAM,CAAC,IAAD,CAAvB;;AACA,MAAI,CAACgtB,UAAU,CAAChrB,OAAhB,EAAyB;AACrBgrB,IAAAA,UAAU,CAAChrB,OAAX,GAAqB4qB,uBAAuB,CAACG,mBAAD,EAAsB,IAAtB,CAA5C;AACH;;AACD5sB,EAAAA,SAAS,CAAC,YAAY;AAClB,QAAI8sB,eAAe,GAAG,EAAtB,CADkB,CAElB;;AACA,QAAIC,eAAe,GAAGN,uBAAuB,CAACG,mBAAD,CAA7C,CAHkB,CAIlB;;AACA,QAAII,WAAW,GAAGP,uBAAuB,CAACG,mBAAD,EAAsB,IAAtB,CAAzC,CALkB,CAMlB;;AACA,SAAK,IAAIhnB,GAAT,IAAgBmnB,eAAhB,EAAiC;AAC7B;AACA;AACA,UAAIE,oBAAoB,GAAGxJ,eAAe,CAAC5hB,OAAhB,KACtB,CAACmd,aAAa,CAACrZ,QAAd,CAAuBC,GAAvB,CAAD,IACGoZ,aAAa,CAAC9Y,QAAd,CAAuBN,GAAvB,EAA4BpC,GAA5B,OAAsCwpB,WAAW,CAACpnB,GAAD,CAF9B,CAA3B,CAH6B,CAM7B;AACA;;AACA,UAAIsnB,YAAY,GAAGF,WAAW,CAACpnB,GAAD,CAAX,KAAqB,IAAxC;AACA,UAAIunB,eAAe,GAAGX,UAAU,CAACK,UAAU,CAAChrB,OAAX,CAAmB+D,GAAnB,CAAD,EAA0BonB,WAAW,CAACpnB,GAAD,CAArC,CAAhC;;AACA,UAAIsnB,YAAY,KAAKC,eAAe,IAAIF,oBAAxB,CAAhB,EAA+D;AAC3DH,QAAAA,eAAe,CAAClnB,GAAD,CAAf,GAAuBmnB,eAAe,CAACnnB,GAAD,CAAtC;AACH;AACJ;;AACD6d,IAAAA,eAAe,CAAC5hB,OAAhB,GAA0B,KAA1B;AACAgrB,IAAAA,UAAU,CAAChrB,OAAX,GAAqBxE,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKwvB,UAAU,CAAChrB,OAAhB,CAAT,EAAmCmrB,WAAnC,CAA7B;;AACA,QAAIjW,MAAM,CAACC,IAAP,CAAY8V,eAAZ,EAA6Ble,MAAjC,EAAyC;AACrCoV,MAAAA,QAAQ,CAACrgB,KAAT,CAAetG,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKyvB,eAAL,CAAT,EAAgC;AAAEhW,QAAAA,UAAU,EAAE8V,mBAAmB,CAAC9V,UAApB,IAAkCoN,iBAAhD;AAAmEpD,QAAAA,aAAa,EAAE8L,mBAAmB,CAAC9L;AAAtG,OAAhC,CAAvB;AACH;AACJ,GA1BQ,EA0BN,CAAC8L,mBAAD,CA1BM,CAAT;AA2BH;;AAED,IAAIQ,aAAa,GAAG,UAAU/C,KAAV,EAAiB;AACjC,MAAI,CAACA,KAAL,EAAY;AACR,WAAO,EAAP;AACH;;AACD,MAAIhW,KAAK,CAACC,OAAN,CAAc+V,KAAd,CAAJ,EAA0B;AACtB,WAAOA,KAAP;AACH;;AACD,SAAO,CAACA,KAAD,CAAP;AACH,CARD;;AASA,IAAIgD,oBAAoB,GAAG,UAAU7E,OAAV,EAAmB;AAC1C,MAAI8E,iBAAiB,GAAG9E,OAAO,YAAYrnB,WAAnB,GAAiCqnB,OAAO,CAAChlB,GAAR,EAAjC,GAAiDglB,OAAzE;AACA,SAAOnU,KAAK,CAACgC,IAAN,CAAW,IAAInT,GAAJ,CAAQkqB,aAAa,CAACE,iBAAD,CAArB,CAAX,CAAP;AACH,CAHD;AAIA;;;;;;;AAKA,IAAIC,gBAAgB,GAAG,UAAUC,IAAV,EAAgB;AAAE,SAAO,CAC5CA,IAAI,CAACC,IAAL,CAAU,GAAV,CAD4C,CAAP;AAErC,CAFJ;;AAIA,IAAIC,iBAAiB,GAAG,UAAUC,UAAV,EAAsBC,UAAtB,EAAkC;AACtD,SAAOD,UAAU,CAACF,IAAX,CAAgB,GAAhB,MAAyBG,UAAU,CAACH,IAAX,CAAgB,GAAhB,CAAhC;AACH,CAFD;AAGA;;;;;;;;;;;;AAUA,SAASI,WAAT,CAAqBhJ,OAArB,EAA8B5M,OAA9B,EAAuC2N,OAAvC,EAAgD5B,QAAhD,EAA0D;AACtD,MAAI8J,cAAc,GAAGT,oBAAoB,CAACpV,OAAD,CAAzC;AACA,MAAIkG,OAAO,GAAGpe,UAAU,CAACwkB,aAAD,CAAxB;AACA,MAAIwJ,oBAAoB,GAAG5P,OAAO,CAACwF,UAAR,IAAsBxF,OAAO,CAACwF,UAAR,CAAmB9hB,OAApE;AACA,MAAI8hB,UAAU,GAAG9jB,MAAM,CAAC,KAAD,CAAvB;AACAG,EAAAA,SAAS,CAAC,YAAY;AAClB,QAAIguB,aAAa,GAAG,KAApB;;AACA,QAAIpI,OAAJ,EAAa;AACT;AACA;AACA;AACAoI,MAAAA,aAAa,GAAG,CAAC,CAACD,oBAAlB;AACAD,MAAAA,cAAc,GAAGT,oBAAoB,CAAClP,OAAO,CAAClG,OAAT,CAArC;AACH,KAND,MAOK;AACD+V,MAAAA,aAAa,GACTrK,UAAU,CAAC9hB,OAAX,IACI6rB,iBAAiB,CAACL,oBAAoB,CAACxI,OAAD,CAArB,EAAgCiJ,cAAhC,CAFzB;AAGH;;AACDE,IAAAA,aAAa,IAAIhK,QAAQ,CAACrgB,KAAT,CAAemqB,cAAf,CAAjB;AACAnK,IAAAA,UAAU,CAAC9hB,OAAX,GAAqB,IAArB;AACH,GAhBQ,EAgBN0rB,gBAAgB,CAACO,cAAD,CAhBV,CAAT;AAiBH;AAED;;;;;;;;;;;AASA,SAASG,6BAAT,CAAuCrqB,SAAvC,EAAkDogB,QAAlD,EAA4D;AACxD,MAAI/d,WAAW,GAAG/F,OAAO,CAAC,YAAY;AAAE,WAAO0D,SAAS,CAAC6B,SAAV,CAAoBue,QAApB,CAAP;AAAuC,GAAtD,EAAwD,CAC7EpgB,SAD6E,CAAxD,CAAzB;AAGA5D,EAAAA,SAAS,CAAC,YAAY;AAAE,WAAO,YAAY;AACvCiG,MAAAA,WAAW,IAAIA,WAAW,EAA1B;AACH,KAFuB;AAEpB,GAFK,EAEH,CAACA,WAAD,CAFG,CAAT;AAGH;;AAED,IAAI/D,EAAJ,EAAQsV,EAAR;;AACA,IAAI0W,qBAAqB,IAAIhsB,EAAE,GAAG,EAAL,EACzBA,EAAE,CAACgqB,eAAe,CAACiC,MAAjB,CAAF,GAA6BhC,uBAAuB,CAAC,UAAUjqB,EAAV,EAAc;AAC/D,MAAI+V,OAAO,GAAG/V,EAAE,CAAC+V,OAAjB;AAAA,MAA0B+L,QAAQ,GAAG9hB,EAAE,CAAC8hB,QAAxC;AAAA,MAAkDhF,aAAa,GAAG9c,EAAE,CAAC8c,aAArE;AAAA,MAAoFlI,UAAU,GAAG5U,EAAE,CAAC4U,UAApG;AACA,SAAO6V,cAAc,CAAC1U,OAAD,EAAU+L,QAAV,EAAoBhF,aAApB,EAAmClI,UAAnC,CAArB;AACH,CAHmD,CAD3B,EAKzB5U,EAAE,CAACgqB,eAAe,CAACkC,YAAjB,CAAF,GAAmCjC,uBAAuB,CAAC,UAAUjqB,EAAV,EAAc;AACrE,MAAI+V,OAAO,GAAG/V,EAAE,CAAC+V,OAAjB;AAAA,MAA0BT,EAAE,GAAGtV,EAAE,CAAC0jB,OAAlC;AAAA,MAA2CA,OAAO,GAAGpO,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAA5E;AAAA,MAAgFwM,QAAQ,GAAG9hB,EAAE,CAAC8hB,QAA9F;AAAA,MAAwGa,OAAO,GAAG3iB,EAAE,CAAC2iB,OAArH;AACA,SAAOgJ,WAAW,CAAChJ,OAAD,EAAU5M,OAAV,EAAmB2N,OAAnB,EAA4B5B,QAA5B,CAAlB;AACH,CAHyD,CALjC,EASzB9hB,EAAE,CAACgqB,eAAe,CAACmC,qBAAjB,CAAF,GAA4ClC,uBAAuB,CAAC,UAAUjqB,EAAV,EAAc;AAC9E,MAAI+V,OAAO,GAAG/V,EAAE,CAAC+V,OAAjB;AAAA,MAA0B+L,QAAQ,GAAG9hB,EAAE,CAAC8hB,QAAxC;AACA,SAAOiK,6BAA6B,CAAChW,OAAD,EAAU+L,QAAV,CAApC;AACH,CAHkE,CAT1C,EAazB9hB,EAbqB,CAAzB;;AAcA,IAAIosB,gBAAgB,GAAG,UAAUC,IAAV,EAAgB;AACnC,SAAOla,KAAK,CAACC,OAAN,CAAcia,IAAd,KAAuB,OAAOA,IAAP,KAAgB,QAA9C;AACH,CAFD;;AAGA,IAAIC,uBAAuB,GAAG,UAAUtsB,EAAV,EAAc;AACxC,MAAI+V,OAAO,GAAG/V,EAAE,CAAC+V,OAAjB;AACA,SAAOA,OAAO,YAAYyL,iBAA1B;AACH,CAHD;;AAIA,IAAI+K,cAAc,GAAG,CAAC,SAAD,EAAY,SAAZ,EAAuB,UAAvB,EAAmC,YAAnC,CAArB;AACA,IAAIC,oBAAoB,IAAIlX,EAAE,GAAG,EAAL,EACxBA,EAAE,CAAC0U,eAAe,CAACiC,MAAjB,CAAF,GAA6B,UAAUrP,KAAV,EAAiB;AAC1C,SAAQA,KAAK,CAAC7G,OAAN,KAAkB7R,SAAlB,IACJ,CAACkoB,gBAAgB,CAACxP,KAAK,CAAC7G,OAAP,CADb,IAEJ,CAACuW,uBAAuB,CAAC1P,KAAD,CAF5B;AAGH,CALuB,EAMxBtH,EAAE,CAAC0U,eAAe,CAACkC,YAAjB,CAAF,GAAmC,UAAUtP,KAAV,EAAiB;AAChD,SAAQA,KAAK,CAACiF,QAAN,KAAmB3d,SAAnB,IACJqoB,cAAc,CAACtN,IAAf,CAAoB,UAAUvb,GAAV,EAAe;AAAE,WAAO,OAAOkZ,KAAK,CAAClZ,GAAD,CAAZ,KAAsB,QAA7B;AAAwC,GAA7E,CADJ;AAEH,CATuB,EAUxB4R,EAAE,CAAC0U,eAAe,CAACmC,qBAAjB,CAAF,GAA4CG,uBAVpB,EAWxBhX,EAXoB,CAAxB;;AAYA,IAAImX,qBAAqB,GAAG,UAAU7P,KAAV,EAAiB;AACzC,MAAI8P,eAAe,GAAGxoB,SAAtB;;AACA,OAAK,IAAIR,GAAT,IAAgBsmB,eAAhB,EAAiC;AAC7B,QAAIwC,oBAAoB,CAAC9oB,GAAD,CAApB,CAA0BkZ,KAA1B,CAAJ,EAAsC;AAClC8P,MAAAA,eAAe,GAAGhpB,GAAlB;AACH;AACJ;;AACD,SAAOgpB,eAAe,GAAGV,qBAAqB,CAACU,eAAD,CAAxB,GAA4CxoB,SAAlE;AACH,CARD;AAUA;;;;;AAGA,SAASyoB,WAAT,CAAqBC,eAArB,EAAsC/P,QAAtC,EAAgDC,aAAhD,EAA+DgF,QAA/D,EAAyElF,KAAzE,EAAgFX,OAAhF,EAAyFyG,aAAzF,EAAwGmK,oBAAxG,EAA8H;AAC1H,MAAIC,OAAO,GAAGjvB,UAAU,CAAC8rB,mBAAD,CAAxB,CAD0H,CAE1H;AACA;;AACA,MAAI9M,QAAQ,IAAI,OAAO5E,MAAP,KAAkB,WAAlC,EACI,OAAO,IAAP;;AACJ,MAAI8U,WAAW,GAAG3xB,cAAc,CAACwxB,eAAD,EAAkBE,OAAO,CAAClD,QAA1B,CAAhC;;AACA,MAAIoD,WAAW,GAAGD,WAAW,CAACrgB,MAA9B;AACA,MAAIkd,QAAQ,GAAG,EAAf,CAR0H,CAS1H;;AACA,MAAIqD,SAAS,GAAGR,qBAAqB,CAAC7P,KAAD,CAArC;;AACA,MAAIqQ,SAAJ,EAAe;AACXrD,IAAAA,QAAQ,CAACte,IAAT,CAAcvN,aAAa,CAACkvB,SAAD,EAAY;AAAEvpB,MAAAA,GAAG,EAAE,WAAP;AAAoBif,MAAAA,OAAO,EAAE/F,KAAK,CAAC+F,OAAnC;AAA4C5M,MAAAA,OAAO,EAAE6G,KAAK,CAAC7G,OAA3D;AAAoE8L,MAAAA,QAAQ,EAAEjF,KAAK,CAACiF,QAApF;AAA8FjN,MAAAA,UAAU,EAAEgI,KAAK,CAAChI,UAAhH;AAA4HkN,MAAAA,QAAQ,EAAEA,QAAtI;AAAgJ4B,MAAAA,OAAO,EAAEmJ,oBAAzJ;AAA+K/P,MAAAA,aAAa,EAAEA;AAA9L,KAAZ,CAA3B;AACH,GAbyH,CAc1H;;;AACA,OAAK,IAAInQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqgB,WAApB,EAAiCrgB,CAAC,EAAlC,EAAsC;AAClC,QAAI3M,EAAE,GAAG+sB,WAAW,CAACpgB,CAAD,CAApB;AAAA,QAAyBugB,YAAY,GAAGltB,EAAE,CAACktB,YAA3C;AAAA,QAAyDxpB,GAAG,GAAG1D,EAAE,CAAC0D,GAAlE;AAAA,QAAuEvF,SAAS,GAAG6B,EAAE,CAAC7B,SAAtF;;AACA,QAAI+uB,YAAY,CAACtQ,KAAD,EAAQ8F,aAAR,CAAhB,EAAwC;AACpCkH,MAAAA,QAAQ,CAACte,IAAT,CAAcvN,aAAa,CAACI,SAAD,EAAYhD,QAAQ,CAAC;AAAEuI,QAAAA,GAAG,EAAEA;AAAP,OAAD,EAAekZ,KAAf,EAAsB;AAAEuQ,QAAAA,YAAY,EAAElR,OAAhB;AAAyByG,QAAAA,aAAa,EAAEA,aAAxC;AAAuD5F,QAAAA,aAAa,EAAEA,aAAtE;AAAqFgF,QAAAA,QAAQ,EAAEA;AAA/F,OAAtB,CAApB,CAA3B;AACH;AACJ;;AACD,SAAO8H,QAAP;AACH;;AAED,IAAIwD,QAAJ;;AACA,CAAC,UAAUA,QAAV,EAAoB;AACjBA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,UAAD,CAAR,GAAuB,CAAxB,CAAR,GAAqC,UAArC;AACAA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,SAAD,CAAR,GAAsB,CAAvB,CAAR,GAAoC,SAApC;AACAA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,SAAD,CAAR,GAAsB,CAAvB,CAAR,GAAoC,SAApC;AACH,CAJD,EAIGA,QAAQ,KAAKA,QAAQ,GAAG,EAAhB,CAJX;;AAKA,IAAIC,gBAAJ;;AACA,CAAC,UAAUA,gBAAV,EAA4B;AACzBA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,MAAD,CAAhB,GAA2B,CAA5B,CAAhB,GAAiD,MAAjD;AACAA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,MAAD,CAAhB,GAA2B,CAA5B,CAAhB,GAAiD,MAAjD;AACH,CAHD,EAGGA,gBAAgB,KAAKA,gBAAgB,GAAG,EAAxB,CAHnB;AAKA;;;;;AAGA,IAAIC,cAAc,GAAG;AACjBnV,EAAAA,aAAa,EAAE,UAAU3U,KAAV,EAAiB;AAAE,WAAOA,KAAK,CAAC2U,aAAN,EAAP;AAA+B,GADhD;AAEjBP,EAAAA,WAAW,EAAE,UAAUpU,KAAV,EAAiB;AAAE,WAAOA,KAAK,CAACoU,WAAN,EAAP;AAA6B;AAF5C,CAArB;AAIA;;;;AAGA,IAAI2V,WAAW,GAAG,UAAU/hB,CAAV,EAAaC,CAAb,EAAgB;AAC9B,SAAOD,CAAC,CAAClI,KAAF,GAAUmI,CAAC,CAACnI,KAAnB;AACH,CAFD;AAGA;;;;;AAGA,SAASkqB,aAAT,GAAyB;AACrB,MAAIC,KAAK,GAAG,IAAIzsB,GAAJ,EAAZ;;AACA,MAAIH,GAAG,GAAG,UAAU2C,KAAV,EAAiB;AAAE,WAAOiqB,KAAK,CAAC5sB,GAAN,CAAU2C,KAAV,CAAP;AAA0B,GAAvD;;AACA,MAAIkqB,KAAK,GAAG,UAAU1tB,EAAV,EAAc;AACtB,QAAIsV,EAAE,GAAGtV,EAAE,KAAK,KAAK,CAAZ,GAAgBstB,cAAhB,GAAiCttB,EAA1C;AAAA,QAA8CmY,aAAa,GAAG7C,EAAE,CAAC6C,aAAjE;AAAA,QAAgFP,WAAW,GAAGtC,EAAE,CAACsC,WAAjG;;AACA,QAAI1M,KAAK,GAAGiH,KAAK,CAACgC,IAAN,CAAWsZ,KAAX,EAAkBjhB,IAAlB,CAAuB+gB,WAAvB,CAAZ;AACA;;;;AAGAriB,IAAAA,KAAK,CAACrL,OAAN,CAAc,UAAU2D,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACiV,cAAN,EAAP;AAAgC,KAAjE;AACA;;;;AAGAvN,IAAAA,KAAK,CAACrL,OAAN,CAAcsY,aAAd;AACA;;;;AAGAjN,IAAAA,KAAK,CAACrL,OAAN,CAAc+X,WAAd;AACA;;;;;;;AAMA1M,IAAAA,KAAK,CAACrL,OAAN,CAAc,UAAU2D,KAAV,EAAiB;AAC3B,UAAIA,KAAK,CAAC0Y,SAAV,EACI1Y,KAAK,CAACmqB,QAAN,GAAiBP,QAAQ,CAACQ,OAA1B;AACP,KAHD;AAIAH,IAAAA,KAAK,CAACvsB,KAAN;AACH,GA1BD;;AA2BA,SAAO;AAAEL,IAAAA,GAAG,EAAEA,GAAP;AAAY6sB,IAAAA,KAAK,EAAEA;AAAnB,GAAP;AACH;;AACD,SAASG,cAAT,CAAwB5R,OAAxB,EAAiC;AAC7B,SAAO,CAAC,CAACA,OAAO,CAAC6R,WAAjB;AACH;;AACD,IAAIC,mBAAmB,GAAGnwB,aAAa,CAAC4vB,aAAa,EAAd,CAAvC;;AAEA,SAASQ,gBAAT,CAA0B5pB,QAA1B,EAAoC;AAChC,SAAOtG,SAAS,CAAC,YAAY;AAAE,WAAO,YAAY;AAAE,aAAOsG,QAAQ,EAAf;AAAoB,KAAzC;AAA4C,GAA3D,EAA6D,EAA7D,CAAhB;AACH;;AAED,SAAS6pB,oBAAT,CAA8BnR,aAA9B,EAA6C;AACzC,MAAIoR,UAAU,GAAGrwB,UAAU,CAACkwB,mBAAD,CAA3B;AACAC,EAAAA,gBAAgB,CAAC,YAAY;AACzB,QAAIH,cAAc,CAACK,UAAD,CAAlB,EACIA,UAAU,CAACC,MAAX,CAAkBrR,aAAlB;AACP,GAHe,CAAhB;AAIH;AAED;;;;;;;;;;;;;AAWA,SAASsR,qBAAT,CAA+BjwB,SAA/B,EAA0C6B,EAA1C,EAA8C;AAC1C,MAAI4sB,eAAe,GAAG5sB,EAAE,CAAC4sB,eAAzB;AAAA,MAA0CyB,gBAAgB,GAAGruB,EAAE,CAACquB,gBAAhE;AAAA,MAAkF5uB,MAAM,GAAGO,EAAE,CAACP,MAA9F;AAAA,MAAsG6uB,uBAAuB,GAAGtuB,EAAE,CAACsuB,uBAAnI;;AACA,WAASC,eAAT,CAAyB3R,KAAzB,EAAgCzZ,WAAhC,EAA6C;AACzC,QAAIuf,aAAa,GAAG7kB,UAAU,CAACwkB,aAAD,CAA9B;AACA,QAAIwK,oBAAoB,GAAGpJ,yBAAyB,CAAC7G,KAAD,CAApD;AACA;;;;;;;AAMA,QAAIC,QAAQ,GAAG6F,aAAa,CAACJ,MAAd,IAAwB1F,KAAK,CAAC0F,MAA9B,IAAwC,KAAvD;AACA;;;;;;;AAMA,QAAIxF,aAAa,GAAGuR,gBAAgB,CAAClwB,SAAD,EAAYye,KAAZ,EAAmB8F,aAAa,CAAC5F,aAAjC,EAAgDD,QAAhD,EAA0D1Z,WAA1D,CAApC;AACA;;;;;AAIAygB,IAAAA,eAAe,CAAC9G,aAAD,EAAgBF,KAAhB,CAAf;AACA;;;;;AAIA,QAAIkF,QAAQ,GAAGyH,yBAAyB,CAACzM,aAAD,EAAgBF,KAAhB,EAAuB0R,uBAAvB,CAAxC;AACA;;;;AAGA,QAAIrS,OAAO,GAAGwG,gBAAgB,CAACC,aAAD,EAAgBZ,QAAhB,EAA0BhF,aAA1B,EAAyCD,QAAzC,EAAmDD,KAAnD,CAA9B;AACA;;;;AAGA,QAAIgN,QAAQ,GAAG+C,WAAW,CAACC,eAAD,EAAkB/P,QAAlB,EAA4BC,aAA5B,EAA2CgF,QAA3C,EAAqDlF,KAArD,EAA4DX,OAA5D,EAAqEyG,aAArE,EAAoFmK,oBAApF,CAA1B;AACA,QAAI2B,SAAS,GAAG/uB,MAAM,CAACtB,SAAD,EAAYye,KAAZ,EAAmBE,aAAnB,CAAtB;AACA;;;;AAGAmR,IAAAA,oBAAoB,CAACnR,aAAD,CAApB,CAvCyC,CAwCzC;AACA;;AACA,WAAQ/e,aAAa,CAACG,QAAD,EAAW,IAAX,EACjBH,aAAa,CAACskB,aAAa,CAAC0H,QAAf,EAAyB;AAAEjrB,MAAAA,KAAK,EAAEmd;AAAT,KAAzB,EAA6CuS,SAA7C,CADI,EAEjB5E,QAFiB,CAArB;AAGH;;AACD,SAAO3rB,UAAU,CAACswB,eAAD,CAAjB;AACH;;AAED,SAASE,UAAT,CAAoBC,IAApB,EAA0B;AACtB,MAAIC,IAAI,GAAG,IAAX;AACA,SAAO,YAAY;AACf,QAAIC,QAAQ,GAAG,YAAY;AACvBD,MAAAA,IAAI,GAAG,IAAP;AACH,KAFD;;AAGA,QAAIA,IAAI,KAAK,IAAb,EAAmB;AACfA,MAAAA,IAAI,GAAGD,IAAP;AACA,aAAOE,QAAP;AACH;;AACD,WAAO,KAAP;AACH,GATD;AAUH;;AACD,IAAIC,oBAAoB,GAAGJ,UAAU,CAAC,gBAAD,CAArC;AACA,IAAIK,kBAAkB,GAAGL,UAAU,CAAC,cAAD,CAAnC;;AACA,SAASM,aAAT,CAAuBtR,IAAvB,EAA6B;AACzB,MAAIkR,IAAI,GAAG,KAAX;;AACA,MAAIlR,IAAI,KAAK,GAAb,EAAkB;AACdkR,IAAAA,IAAI,GAAGG,kBAAkB,EAAzB;AACH,GAFD,MAGK,IAAIrR,IAAI,KAAK,GAAb,EAAkB;AACnBkR,IAAAA,IAAI,GAAGE,oBAAoB,EAA3B;AACH,GAFI,MAGA;AACD,QAAIG,gBAAgB,GAAGH,oBAAoB,EAA3C;AACA,QAAII,cAAc,GAAGH,kBAAkB,EAAvC;;AACA,QAAIE,gBAAgB,IAAIC,cAAxB,EAAwC;AACpCN,MAAAA,IAAI,GAAG,YAAY;AACfK,QAAAA,gBAAgB;AAChBC,QAAAA,cAAc;AACjB,OAHD;AAIH,KALD,MAMK;AACD;AACA,UAAID,gBAAJ,EACIA,gBAAgB;AACpB,UAAIC,cAAJ,EACIA,cAAc;AACrB;AACJ;;AACD,SAAON,IAAP;AACH;;AAED,IAAIO,uBAAuB,GAAG,KAA9B;AACA,IAAIC,SAAS,GAAG,OAAOlX,MAAP,KAAkB,WAAlC;;AACA,IAAIkX,SAAJ,EAAe;AACXC,EAAAA,QAAQ,CAACC,gBAAT,CAA0B,WAA1B,EAAuC,UAAUC,KAAV,EAAiB;AACpD,QAAIJ,uBAAJ,EAA6B;AACzBI,MAAAA,KAAK,CAACC,cAAN;AACH;AACJ,GAJD,EAIG;AAAEC,IAAAA,OAAO,EAAE;AAAX,GAJH;AAKH;;AACD,IAAIC,mBAAmB,GAAG,YAAY;AAAE,SAAQP,uBAAuB,GAAG,IAAlC;AAA0C,CAAlF;;AACA,IAAIQ,qBAAqB,GAAG,YAAY;AAAE,SAAQR,uBAAuB,GAAG,KAAlC;AAA2C,CAArF;;AAEA,SAASS,WAAT,CAAqBze,MAArB,EAA6B0e,SAA7B,EAAwC3d,OAAxC,EAAiD6D,OAAjD,EAA0D;AACtD,MAAI,CAAC7D,OAAL,EACI;AACJf,EAAAA,MAAM,CAACme,gBAAP,CAAwBO,SAAxB,EAAmC3d,OAAnC,EAA4C6D,OAA5C;AACA,SAAO,YAAY;AAAE,WAAO5E,MAAM,CAAC2e,mBAAP,CAA2BD,SAA3B,EAAsC3d,OAAtC,EAA+C6D,OAA/C,CAAP;AAAiE,GAAtF;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;AAqBA,SAASga,WAAT,CAAqBnxB,GAArB,EAA0BixB,SAA1B,EAAqC3d,OAArC,EAA8C6D,OAA9C,EAAuD;AACnDhY,EAAAA,SAAS,CAAC,YAAY;AAClB,QAAIkF,OAAO,GAAGrE,GAAG,CAACgB,OAAlB;;AACA,QAAIsS,OAAO,IAAIjP,OAAf,EAAwB;AACpB,aAAO2sB,WAAW,CAAC3sB,OAAD,EAAU4sB,SAAV,EAAqB3d,OAArB,EAA8B6D,OAA9B,CAAlB;AACH;AACJ,GALQ,EAKN,CAACnX,GAAD,EAAMixB,SAAN,EAAiB3d,OAAjB,EAA0B6D,OAA1B,CALM,CAAT;AAMH;;AAED,SAASia,YAAT,CAAsBT,KAAtB,EAA6B;AACzB;AACA,MAAI,OAAOU,YAAP,KAAwB,WAAxB,IAAuCV,KAAK,YAAYU,YAA5D,EAA0E;AACtE,WAAO,CAAC,EAAEV,KAAK,CAACW,WAAN,KAAsB,OAAxB,CAAR;AACH;;AACD,SAAOX,KAAK,YAAYY,UAAxB;AACH;;AACD,SAASC,YAAT,CAAsBb,KAAtB,EAA6B;AACzB,MAAIc,UAAU,GAAG,CAAC,CAACd,KAAK,CAACe,OAAzB;AACA,SAAOD,UAAP;AACH;AAED;;;;;;AAIA,SAASE,oBAAT,CAA8BC,YAA9B,EAA4C;AACxC,MAAI,CAACA,YAAL,EACI,OAAOrsB,SAAP;AACJ,SAAO,UAAUorB,KAAV,EAAiB;AACpB,QAAIS,YAAY,GAAGT,KAAK,YAAYY,UAApC;AACA,QAAIM,gBAAgB,GAAG,CAACT,YAAD,IAClBA,YAAY,IAAIT,KAAK,CAACmB,MAAN,KAAiB,CADtC;;AAEA,QAAID,gBAAJ,EAAsB;AAClBD,MAAAA,YAAY,CAACjB,KAAD,CAAZ;AACH;AACJ,GAPD;AAQH;;AACD,IAAIoB,gBAAgB,GAAG;AAAEC,EAAAA,KAAK,EAAE,CAAT;AAAYC,EAAAA,KAAK,EAAE;AAAnB,CAAvB;;AACA,SAASC,cAAT,CAAwBvV,CAAxB,EAA2BwV,SAA3B,EAAsC;AAClC,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAG,MAAZ;AAAqB;;AACjD,MAAIC,YAAY,GAAGzV,CAAC,CAAC+U,OAAF,CAAU,CAAV,KAAgB/U,CAAC,CAAC0V,cAAF,CAAiB,CAAjB,CAAnC;AACA,MAAIthB,KAAK,GAAGqhB,YAAY,IAAIL,gBAA5B;AACA,SAAO;AACHprB,IAAAA,CAAC,EAAEoK,KAAK,CAACohB,SAAS,GAAG,GAAb,CADL;AAEHrrB,IAAAA,CAAC,EAAEiK,KAAK,CAACohB,SAAS,GAAG,GAAb;AAFL,GAAP;AAIH;;AACD,SAASG,cAAT,CAAwBvhB,KAAxB,EAA+BohB,SAA/B,EAA0C;AACtC,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAG,MAAZ;AAAqB;;AACjD,SAAO;AACHxrB,IAAAA,CAAC,EAAEoK,KAAK,CAACohB,SAAS,GAAG,GAAb,CADL;AAEHrrB,IAAAA,CAAC,EAAEiK,KAAK,CAACohB,SAAS,GAAG,GAAb;AAFL,GAAP;AAIH;;AACD,SAASI,gBAAT,CAA0B5B,KAA1B,EAAiCwB,SAAjC,EAA4C;AACxC,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAG,MAAZ;AAAqB;;AACjD,SAAO;AACHphB,IAAAA,KAAK,EAAEygB,YAAY,CAACb,KAAD,CAAZ,GACDuB,cAAc,CAACvB,KAAD,EAAQwB,SAAR,CADb,GAEDG,cAAc,CAAC3B,KAAD,EAAQwB,SAAR;AAHjB,GAAP;AAKH;;AACD,SAASK,yBAAT,CAAmC7B,KAAnC,EAA0C;AACtC,SAAO4B,gBAAgB,CAAC5B,KAAD,EAAQ,QAAR,CAAvB;AACH;;AACD,IAAI8B,WAAW,GAAG,UAAUnf,OAAV,EAAmBof,0BAAnB,EAA+C;AAC7D,MAAIA,0BAA0B,KAAK,KAAK,CAAxC,EAA2C;AAAEA,IAAAA,0BAA0B,GAAG,KAA7B;AAAqC;;AAClF,MAAI,CAACpf,OAAL,EACI;;AACJ,MAAI4F,QAAQ,GAAG,UAAUyX,KAAV,EAAiB;AAAE,WAAOrd,OAAO,CAACqd,KAAD,EAAQ4B,gBAAgB,CAAC5B,KAAD,CAAxB,CAAd;AAAiD,GAAnF;;AACA,SAAO+B,0BAA0B,GAC3Bf,oBAAoB,CAACzY,QAAD,CADO,GAE3BA,QAFN;AAGH,CARD;;AAUA,IAAIyZ,WAAW,GAAG,OAAOrZ,MAAP,KAAkB,WAApC,C,CACA;;AACA,IAAIsZ,qBAAqB,GAAG,YAAY;AACpC,SAAOD,WAAW,IAAIrZ,MAAM,CAACuZ,aAAP,KAAyB,IAA/C;AACH,CAFD;;AAGA,IAAIC,mBAAmB,GAAG,YAAY;AAClC,SAAOH,WAAW,IAAIrZ,MAAM,CAACyZ,YAAP,KAAwB,IAA9C;AACH,CAFD;;AAGA,IAAIC,mBAAmB,GAAG,YAAY;AAClC,SAAOL,WAAW,IAAIrZ,MAAM,CAAC2Z,WAAP,KAAuB,IAA7C;AACH,CAFD;;AAIA,IAAIC,eAAe,GAAG;AAClBC,EAAAA,WAAW,EAAE,WADK;AAElBC,EAAAA,WAAW,EAAE,WAFK;AAGlBC,EAAAA,SAAS,EAAE,SAHO;AAIlBC,EAAAA,aAAa,EAAE,aAJG;AAKlBC,EAAAA,WAAW,EAAE,WALK;AAMlBC,EAAAA,UAAU,EAAE,UANM;AAOlBC,EAAAA,YAAY,EAAE,YAPI;AAQlBC,EAAAA,YAAY,EAAE;AARI,CAAtB;AAUA,IAAIC,eAAe,GAAG;AAClBR,EAAAA,WAAW,EAAE,YADK;AAElBC,EAAAA,WAAW,EAAE,WAFK;AAGlBC,EAAAA,SAAS,EAAE,UAHO;AAIlBC,EAAAA,aAAa,EAAE;AAJG,CAAtB;;AAMA,SAASM,mBAAT,CAA6B7D,IAA7B,EAAmC;AAC/B,MAAI6C,qBAAqB,EAAzB,EAA6B;AACzB,WAAO7C,IAAP;AACH,GAFD,MAGK,IAAI+C,mBAAmB,EAAvB,EAA2B;AAC5B,WAAOa,eAAe,CAAC5D,IAAD,CAAtB;AACH,GAFI,MAGA,IAAIiD,mBAAmB,EAAvB,EAA2B;AAC5B,WAAOE,eAAe,CAACnD,IAAD,CAAtB;AACH;;AACD,SAAOA,IAAP;AACH;;AACD,SAAS8D,eAAT,CAAyBthB,MAAzB,EAAiC0e,SAAjC,EAA4C3d,OAA5C,EAAqD6D,OAArD,EAA8D;AAC1D,SAAO6Z,WAAW,CAACze,MAAD,EAASqhB,mBAAmB,CAAC3C,SAAD,CAA5B,EAAyCwB,WAAW,CAACnf,OAAD,EAAU2d,SAAS,KAAK,aAAxB,CAApD,EAA4F9Z,OAA5F,CAAlB;AACH;;AACD,SAAS2c,eAAT,CAAyB9zB,GAAzB,EAA8BixB,SAA9B,EAAyC3d,OAAzC,EAAkD6D,OAAlD,EAA2D;AACvD,SAAOga,WAAW,CAACnxB,GAAD,EAAM4zB,mBAAmB,CAAC3C,SAAD,CAAzB,EAAsCwB,WAAW,CAACnf,OAAD,EAAU2d,SAAS,KAAK,aAAxB,CAAjD,EAAyF9Z,OAAzF,CAAlB;AACH;AAED;;;AACA,IAAI4c,KAAJ;;AACA,CAAC,UAAUA,KAAV,EAAiB;AACd;AACAA,EAAAA,KAAK,CAACC,QAAN,GAAiB,UAAUnnB,CAAV,EAAaC,CAAb,EAAgB;AAC7B,WAAO;AAAEnG,MAAAA,CAAC,EAAEkG,CAAC,CAAClG,CAAF,GAAMmG,CAAC,CAACnG,CAAb;AAAgBG,MAAAA,CAAC,EAAE+F,CAAC,CAAC/F,CAAF,GAAMgG,CAAC,CAAChG;AAA3B,KAAP;AACH,GAFD;AAGA;;;AACAitB,EAAAA,KAAK,CAACE,UAAN,GAAmB,UAAUC,QAAV,EAAoB;AACnC,QAAIC,IAAJ;;AACA,QAAIC,OAAO,GAAG,YAAY;AACtB;AACA,UAAID,IAAI,KAAK5uB,SAAb,EACI,OAAO4uB,IAAP;;AACJ,UAAI,OAAOD,QAAP,KAAoB,QAAxB,EAAkC;AAC9BC,QAAAA,IAAI,GAAG1D,QAAQ,CAAC4D,cAAT,CAAwBH,QAAxB,CAAP;AACH,OAFD,MAGK;AACDC,QAAAA,IAAI,GAAGD,QAAP;AACH;;AACD,aAAOC,IAAP;AACH,KAXD;;AAYA,WAAO,UAAU9yB,EAAV,EAAc;AACjB,UAAIsF,CAAC,GAAGtF,EAAE,CAACsF,CAAX;AAAA,UAAcG,CAAC,GAAGzF,EAAE,CAACyF,CAArB;AACA,UAAIwtB,SAAS,GAAGF,OAAO,EAAvB;AACA,UAAI,CAACE,SAAL,EACI,OAAO/uB,SAAP;AACJ,UAAIgvB,IAAI,GAAGD,SAAS,CAAC/c,qBAAV,EAAX;AACA,aAAO;AACH5Q,QAAAA,CAAC,EAAEA,CAAC,GAAG4tB,IAAI,CAAC/tB,IAAT,GAAgB8S,MAAM,CAACkb,OADvB;AAEH1tB,QAAAA,CAAC,EAAEA,CAAC,GAAGytB,IAAI,CAAChuB,GAAT,GAAe+S,MAAM,CAACmb;AAFtB,OAAP;AAIH,KAVD;AAWH,GAzBD;AA0BH,CAhCD,EAgCGV,KAAK,KAAKA,KAAK,GAAG,EAAb,CAhCR;AAkCA;;;;;AAGA,IAAIW,UAAU;AAAG;AAAe,YAAY;AACxC,WAASA,UAAT,CAAoB/D,KAApB,EAA2BgE,QAA3B,EAAqCtzB,EAArC,EAAyC;AACrC,QAAIb,KAAK,GAAG,IAAZ;;AACA,QAAI8W,kBAAkB,GAAG,CAACjW,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAAtB,EAA0BiW,kBAAnD;AACA;;;;AAGA,SAAKsd,UAAL,GAAkB,IAAlB;AACA;;;;AAGA,SAAKC,aAAL,GAAqB,IAArB;AACA;;;;AAGA,SAAKC,iBAAL,GAAyB,IAAzB;AACA;;;;AAGA,SAAKH,QAAL,GAAgB,EAAhB;;AACA,SAAKI,WAAL,GAAmB,YAAY;AAC3B,UAAI,EAAEv0B,KAAK,CAACq0B,aAAN,IAAuBr0B,KAAK,CAACs0B,iBAA/B,CAAJ,EACI;AACJ,UAAIE,IAAI,GAAGC,UAAU,CAACz0B,KAAK,CAACs0B,iBAAP,EAA0Bt0B,KAAK,CAAC00B,OAAhC,CAArB;AACA,UAAIC,YAAY,GAAG30B,KAAK,CAACo0B,UAAN,KAAqB,IAAxC,CAJ2B,CAK3B;AACA;AACA;;AACA,UAAIQ,uBAAuB,GAAGl4B,QAAQ,CAAC83B,IAAI,CAACta,MAAN,EAAc;AAAE/T,QAAAA,CAAC,EAAE,CAAL;AAAQG,QAAAA,CAAC,EAAE;AAAX,OAAd,CAAR,IAAyC,CAAvE;AACA,UAAI,CAACquB,YAAD,IAAiB,CAACC,uBAAtB,EACI;AACJ,UAAIrkB,KAAK,GAAGikB,IAAI,CAACjkB,KAAjB;AACA,UAAIxP,SAAS,GAAG1E,YAAY,GAAG0E,SAA/B;;AACAf,MAAAA,KAAK,CAAC00B,OAAN,CAAcvoB,IAAd,CAAmBnQ,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKuU,KAAL,CAAT,EAAsB;AAAExP,QAAAA,SAAS,EAAEA;AAAb,OAAtB,CAA3B;;AACA,UAAIF,EAAE,GAAGb,KAAK,CAACm0B,QAAf;AAAA,UAAyBnM,OAAO,GAAGnnB,EAAE,CAACmnB,OAAtC;AAAA,UAA+C6M,MAAM,GAAGh0B,EAAE,CAACg0B,MAA3D;;AACA,UAAI,CAACF,YAAL,EAAmB;AACf3M,QAAAA,OAAO,IAAIA,OAAO,CAAChoB,KAAK,CAACq0B,aAAP,EAAsBG,IAAtB,CAAlB;AACAx0B,QAAAA,KAAK,CAACo0B,UAAN,GAAmBp0B,KAAK,CAACq0B,aAAzB;AACH;;AACDQ,MAAAA,MAAM,IAAIA,MAAM,CAAC70B,KAAK,CAACq0B,aAAP,EAAsBG,IAAtB,CAAhB;AACH,KApBD,CAnBqC,CAwCrC;;;AACA,QAAIxD,YAAY,CAACb,KAAD,CAAZ,IAAuBA,KAAK,CAACe,OAAN,CAAc3jB,MAAd,GAAuB,CAAlD,EACI;AACJ,SAAK4mB,QAAL,GAAgBA,QAAhB;AACA,SAAKrd,kBAAL,GAA0BA,kBAA1B;AACA,QAAI0d,IAAI,GAAGzC,gBAAgB,CAAC5B,KAAD,CAA3B;AACA,QAAI2E,WAAW,GAAGruB,cAAc,CAAC+tB,IAAD,EAAO,KAAK1d,kBAAZ,CAAhC;AACA,QAAIvG,KAAK,GAAGukB,WAAW,CAACvkB,KAAxB;AACA,QAAIxP,SAAS,GAAG1E,YAAY,GAAG0E,SAA/B;AACA,SAAK2zB,OAAL,GAAe,CAAC14B,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKuU,KAAL,CAAT,EAAsB;AAAExP,MAAAA,SAAS,EAAEA;AAAb,KAAtB,CAAT,CAAf;AACA,QAAIg0B,cAAc,GAAGZ,QAAQ,CAACY,cAA9B;AACAA,IAAAA,cAAc,IACVA,cAAc,CAAC5E,KAAD,EAAQsE,UAAU,CAACK,WAAD,EAAc,KAAKJ,OAAnB,CAAlB,CADlB;AAEA,QAAIM,mBAAmB,GAAG3B,eAAe,CAACva,MAAD,EAAS,aAAT,EAAwB,UAAUqX,KAAV,EAAiBqE,IAAjB,EAAuB;AAAE,aAAOx0B,KAAK,CAACi1B,iBAAN,CAAwB9E,KAAxB,EAA+BqE,IAA/B,CAAP;AAA8C,KAA/F,CAAzC;AACA,QAAIU,iBAAiB,GAAG7B,eAAe,CAACva,MAAD,EAAS,WAAT,EAAsB,UAAUqX,KAAV,EAAiBqE,IAAjB,EAAuB;AAAE,aAAOx0B,KAAK,CAACm1B,eAAN,CAAsBhF,KAAtB,EAA6BqE,IAA7B,CAAP;AAA4C,KAA3F,CAAvC;;AACA,SAAKY,eAAL,GAAuB,YAAY;AAC/BJ,MAAAA,mBAAmB,IAAIA,mBAAmB,EAA1C;AACAE,MAAAA,iBAAiB,IAAIA,iBAAiB,EAAtC;AACH,KAHD;AAIH;;AACDhB,EAAAA,UAAU,CAAC7yB,SAAX,CAAqB4zB,iBAArB,GAAyC,UAAU9E,KAAV,EAAiBqE,IAAjB,EAAuB;AAC5D,SAAKH,aAAL,GAAqBlE,KAArB;AACA,SAAKmE,iBAAL,GAAyB7tB,cAAc,CAAC+tB,IAAD,EAAO,KAAK1d,kBAAZ,CAAvC,CAF4D,CAG5D;;AACA,QAAI8Z,YAAY,CAACT,KAAD,CAAZ,IAAuBA,KAAK,CAACkF,OAAN,KAAkB,CAA7C,EAAgD;AAC5C,WAAKF,eAAL,CAAqBhF,KAArB,EAA4BqE,IAA5B;AACA;AACH,KAP2D,CAQ5D;;;AACAp4B,IAAAA,IAAI,CAACqH,MAAL,CAAY,KAAK8wB,WAAjB,EAA8B,IAA9B;AACH,GAVD;;AAWAL,EAAAA,UAAU,CAAC7yB,SAAX,CAAqB8zB,eAArB,GAAuC,UAAUhF,KAAV,EAAiBqE,IAAjB,EAAuB;AAC1D,SAAKc,GAAL;AACA,QAAIC,KAAK,GAAG,KAAKpB,QAAL,CAAcoB,KAA1B;AACA,QAAI,CAACA,KAAL,EACI;AACJ,QAAIC,OAAO,GAAGf,UAAU,CAAChuB,cAAc,CAAC+tB,IAAD,EAAO,KAAK1d,kBAAZ,CAAf,EAAgD,KAAK4d,OAArD,CAAxB;AACAa,IAAAA,KAAK,IAAIA,KAAK,CAACpF,KAAD,EAAQqF,OAAR,CAAd;AACH,GAPD;;AAQAtB,EAAAA,UAAU,CAAC7yB,SAAX,CAAqBo0B,cAArB,GAAsC,UAAUtB,QAAV,EAAoB;AACtD,SAAKA,QAAL,GAAgBA,QAAhB;AACH,GAFD;;AAGAD,EAAAA,UAAU,CAAC7yB,SAAX,CAAqBi0B,GAArB,GAA2B,YAAY;AACnC,SAAKF,eAAL,IAAwB,KAAKA,eAAL,EAAxB;AACA94B,IAAAA,UAAU,CAACmH,MAAX,CAAkB,KAAK8wB,WAAvB;AACAhE,IAAAA,qBAAqB;AACxB,GAJD;;AAKA,SAAO2D,UAAP;AACH,CAzF+B,EAAhC;;AA0FA,SAASztB,cAAT,CAAwB+tB,IAAxB,EAA8B1d,kBAA9B,EAAkD;AAC9C,SAAOA,kBAAkB,GAAG;AAAEvG,IAAAA,KAAK,EAAEuG,kBAAkB,CAAC0d,IAAI,CAACjkB,KAAN;AAA3B,GAAH,GAA+CikB,IAAxE;AACH;;AACD,SAASC,UAAT,CAAoB5zB,EAApB,EAAwB6zB,OAAxB,EAAiC;AAC7B,MAAInkB,KAAK,GAAG1P,EAAE,CAAC0P,KAAf;AACA,SAAO;AACHA,IAAAA,KAAK,EAAEA,KADJ;AAEHzP,IAAAA,KAAK,EAAEyyB,KAAK,CAACC,QAAN,CAAejjB,KAAf,EAAsBmlB,eAAe,CAAChB,OAAD,CAArC,CAFJ;AAGHxa,IAAAA,MAAM,EAAEqZ,KAAK,CAACC,QAAN,CAAejjB,KAAf,EAAsBolB,gBAAgB,CAACjB,OAAD,CAAtC,CAHL;AAIHzf,IAAAA,QAAQ,EAAE2gB,aAAa,CAAClB,OAAD,EAAU,GAAV;AAJpB,GAAP;AAMH;;AACD,SAASiB,gBAAT,CAA0BjB,OAA1B,EAAmC;AAC/B,SAAOA,OAAO,CAAC,CAAD,CAAd;AACH;;AACD,SAASgB,eAAT,CAAyBhB,OAAzB,EAAkC;AAC9B,SAAOA,OAAO,CAACA,OAAO,CAACnnB,MAAR,GAAiB,CAAlB,CAAd;AACH;;AACD,SAASqoB,aAAT,CAAuBlB,OAAvB,EAAgCz0B,SAAhC,EAA2C;AACvC,MAAIy0B,OAAO,CAACnnB,MAAR,GAAiB,CAArB,EAAwB;AACpB,WAAO;AAAEpH,MAAAA,CAAC,EAAE,CAAL;AAAQG,MAAAA,CAAC,EAAE;AAAX,KAAP;AACH;;AACD,MAAIkH,CAAC,GAAGknB,OAAO,CAACnnB,MAAR,GAAiB,CAAzB;AACA,MAAIsoB,gBAAgB,GAAG,IAAvB;AACA,MAAIC,SAAS,GAAGJ,eAAe,CAAChB,OAAD,CAA/B;;AACA,SAAOlnB,CAAC,IAAI,CAAZ,EAAe;AACXqoB,IAAAA,gBAAgB,GAAGnB,OAAO,CAAClnB,CAAD,CAA1B;;AACA,QAAIsoB,SAAS,CAAC/0B,SAAV,GAAsB80B,gBAAgB,CAAC90B,SAAvC,GACA4T,qBAAqB,CAAC1U,SAAD,CADzB,EACsC;AAClC;AACH;;AACDuN,IAAAA,CAAC;AACJ;;AACD,MAAI,CAACqoB,gBAAL,EAAuB;AACnB,WAAO;AAAE1vB,MAAAA,CAAC,EAAE,CAAL;AAAQG,MAAAA,CAAC,EAAE;AAAX,KAAP;AACH;;AACD,MAAIyvB,IAAI,GAAG,CAACD,SAAS,CAAC/0B,SAAV,GAAsB80B,gBAAgB,CAAC90B,SAAxC,IAAqD,IAAhE;;AACA,MAAIg1B,IAAI,KAAK,CAAb,EAAgB;AACZ,WAAO;AAAE5vB,MAAAA,CAAC,EAAE,CAAL;AAAQG,MAAAA,CAAC,EAAE;AAAX,KAAP;AACH;;AACD,MAAI0vB,eAAe,GAAG;AAClB7vB,IAAAA,CAAC,EAAE,CAAC2vB,SAAS,CAAC3vB,CAAV,GAAc0vB,gBAAgB,CAAC1vB,CAAhC,IAAqC4vB,IADtB;AAElBzvB,IAAAA,CAAC,EAAE,CAACwvB,SAAS,CAACxvB,CAAV,GAAcuvB,gBAAgB,CAACvvB,CAAhC,IAAqCyvB;AAFtB,GAAtB;;AAIA,MAAIC,eAAe,CAAC7vB,CAAhB,KAAsB8vB,QAA1B,EAAoC;AAChCD,IAAAA,eAAe,CAAC7vB,CAAhB,GAAoB,CAApB;AACH;;AACD,MAAI6vB,eAAe,CAAC1vB,CAAhB,KAAsB2vB,QAA1B,EAAoC;AAChCD,IAAAA,eAAe,CAAC1vB,CAAhB,GAAoB,CAApB;AACH;;AACD,SAAO0vB,eAAP;AACH;AAED;;;;;;;AAKA,SAASE,gBAAT,CAA0B3lB,KAA1B,EAAiC1P,EAAjC,EAAqCs1B,OAArC,EAA8C;AAC1C,MAAI/vB,GAAG,GAAGvF,EAAE,CAACuF,GAAb;AAAA,MAAkBC,GAAG,GAAGxF,EAAE,CAACwF,GAA3B;;AACA,MAAID,GAAG,KAAKrB,SAAR,IAAqBwL,KAAK,GAAGnK,GAAjC,EAAsC;AAClC;AACAmK,IAAAA,KAAK,GAAG4lB,OAAO,GAAG35B,GAAG,CAAC4J,GAAD,EAAMmK,KAAN,EAAa4lB,OAAb,CAAN,GAA8B3uB,IAAI,CAACnB,GAAL,CAASkK,KAAT,EAAgBnK,GAAhB,CAA7C;AACH,GAHD,MAIK,IAAIC,GAAG,KAAKtB,SAAR,IAAqBwL,KAAK,GAAGlK,GAAjC,EAAsC;AACvC;AACAkK,IAAAA,KAAK,GAAG4lB,OAAO,GAAG35B,GAAG,CAAC6J,GAAD,EAAMkK,KAAN,EAAa4lB,OAAb,CAAN,GAA8B3uB,IAAI,CAACpB,GAAL,CAASmK,KAAT,EAAgBlK,GAAhB,CAA7C;AACH;;AACD,SAAOkK,KAAP;AACH;AACD;;;;;;;;;;AAQA,SAAS6lB,uBAAT,CAAiC7lB,KAAjC,EAAwChD,MAAxC,EAAgD5Q,QAAhD,EAA0D05B,WAA1D,EAAuEF,OAAvE,EAAgF;AAC5E;AACA,MAAI/vB,GAAG,GAAGmK,KAAK,GAAGhD,MAAM,GAAG5Q,QAA3B;AACA,SAAO05B,WAAW,GAAGH,gBAAgB,CAAC9vB,GAAD,EAAMiwB,WAAN,EAAmBF,OAAnB,CAAnB,GAAiD/vB,GAAnE;AACH;AACD;;;;;;AAIA,SAASkwB,2BAAT,CAAqCxoB,IAArC,EAA2C1H,GAA3C,EAAgDC,GAAhD,EAAqD;AACjD,MAAIgwB,WAAW,GAAG,EAAlB;AACA,MAAI9oB,MAAM,GAAGO,IAAI,CAACzH,GAAL,GAAWyH,IAAI,CAAC1H,GAA7B;;AACA,MAAIA,GAAG,KAAKrB,SAAZ,EAAuB;AACnBsxB,IAAAA,WAAW,CAACjwB,GAAZ,GAAkB0H,IAAI,CAAC1H,GAAL,GAAWA,GAA7B;AACH;;AACD,MAAIC,GAAG,KAAKtB,SAAZ,EAAuB;AACnBsxB,IAAAA,WAAW,CAAChwB,GAAZ,GAAkBmB,IAAI,CAACnB,GAAL,CAASyH,IAAI,CAAC1H,GAAL,GAAWC,GAAX,GAAiBkH,MAA1B,EAAkCO,IAAI,CAAC1H,GAAL,GAAWC,GAA7C,CAAlB;AACH;;AACD,SAAOgwB,WAAP;AACH;AACD;;;;;;AAIA,SAASE,uBAAT,CAAiCC,SAAjC,EAA4C31B,EAA5C,EAAgD;AAC5C,MAAIkF,GAAG,GAAGlF,EAAE,CAACkF,GAAb;AAAA,MAAkBC,IAAI,GAAGnF,EAAE,CAACmF,IAA5B;AAAA,MAAkCE,MAAM,GAAGrF,EAAE,CAACqF,MAA9C;AAAA,MAAsDD,KAAK,GAAGpF,EAAE,CAACoF,KAAjE;AACA,SAAO;AACHE,IAAAA,CAAC,EAAEmwB,2BAA2B,CAACE,SAAS,CAACrwB,CAAX,EAAcH,IAAd,EAAoBC,KAApB,CAD3B;AAEHK,IAAAA,CAAC,EAAEgwB,2BAA2B,CAACE,SAAS,CAAClwB,CAAX,EAAcP,GAAd,EAAmBG,MAAnB;AAF3B,GAAP;AAIH;AACD;;;;;AAGA,SAASuwB,2BAAT,CAAqCC,UAArC,EAAiDC,eAAjD,EAAkE;AAC9D,MAAI91B,EAAJ;;AACA,MAAIuF,GAAG,GAAGuwB,eAAe,CAACvwB,GAAhB,GAAsBswB,UAAU,CAACtwB,GAA3C;AACA,MAAIC,GAAG,GAAGswB,eAAe,CAACtwB,GAAhB,GAAsBqwB,UAAU,CAACrwB,GAA3C,CAH8D,CAI9D;AACA;;AACA,MAAIswB,eAAe,CAACtwB,GAAhB,GAAsBswB,eAAe,CAACvwB,GAAtC,GACAswB,UAAU,CAACrwB,GAAX,GAAiBqwB,UAAU,CAACtwB,GADhC,EACqC;AACjCvF,IAAAA,EAAE,GAAG,CAACwF,GAAD,EAAMD,GAAN,CAAL,EAAiBA,GAAG,GAAGvF,EAAE,CAAC,CAAD,CAAzB,EAA8BwF,GAAG,GAAGxF,EAAE,CAAC,CAAD,CAAtC;AACH;;AACD,SAAO;AACHuF,IAAAA,GAAG,EAAEswB,UAAU,CAACtwB,GAAX,GAAiBA,GADnB;AAEHC,IAAAA,GAAG,EAAEqwB,UAAU,CAACtwB,GAAX,GAAiBC;AAFnB,GAAP;AAIH;AACD;;;;;AAGA,SAASuwB,uBAAT,CAAiCJ,SAAjC,EAA4CK,cAA5C,EAA4D;AACxD,SAAO;AACH1wB,IAAAA,CAAC,EAAEswB,2BAA2B,CAACD,SAAS,CAACrwB,CAAX,EAAc0wB,cAAc,CAAC1wB,CAA7B,CAD3B;AAEHG,IAAAA,CAAC,EAAEmwB,2BAA2B,CAACD,SAAS,CAAClwB,CAAX,EAAcuwB,cAAc,CAACvwB,CAA7B;AAF3B,GAAP;AAIH;AACD;;;;;AAGA,SAASwwB,wBAAT,CAAkChpB,IAAlC,EAAwCuoB,WAAxC,EAAqD15B,QAArD,EAA+D;AAC3D,MAAIo6B,UAAU,GAAGjpB,IAAI,CAACzH,GAAL,GAAWyH,IAAI,CAAC1H,GAAjC;AACA,MAAIA,GAAG,GAAG5J,GAAG,CAAC65B,WAAW,CAACjwB,GAAb,EAAkBiwB,WAAW,CAAChwB,GAAZ,GAAkB0wB,UAApC,EAAgDp6B,QAAhD,CAAb;AACA,SAAO;AAAEyJ,IAAAA,GAAG,EAAEA,GAAP;AAAYC,IAAAA,GAAG,EAAED,GAAG,GAAG2wB;AAAvB,GAAP;AACH;;AAED,IAAIC,mBAAmB,GAAG,IAAIC,OAAJ,EAA1B;AACA;;;;AAGA,IAAIC,gBAAJ;;AACA,IAAIC,yBAAyB;AAAG;AAAe,YAAY;AACvD,WAASA,yBAAT,CAAmCt2B,EAAnC,EAAuC;AACnC,QAAI8c,aAAa,GAAG9c,EAAE,CAAC8c,aAAvB;AACA;;;;;;AAKA,SAAKyZ,UAAL,GAAkB,KAAlB;AACA;;;;;;AAKA,SAAKC,gBAAL,GAAwB,IAAxB;AACA;;;;;;AAKA,SAAKhB,WAAL,GAAmB,KAAnB;AACA;;;;;;AAKA,SAAK5Y,KAAL,GAAa,EAAb;AACA;;;;;;;;AAOA,SAAK6Z,cAAL,GAAsB;AAClBnxB,MAAAA,CAAC,EAAE,GADe;AAElBG,MAAAA,CAAC,EAAE;AAFe,KAAtB,CAjCmC,CAqCnC;AACA;AACA;;AACA,SAAKixB,cAAL,GAAsB,IAAtB;AACA;;;;AAGA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAK7Z,aAAL,GAAqBA,aAArB;AACA,SAAKA,aAAL,CAAmBvF,sBAAnB;AACA4e,IAAAA,mBAAmB,CAAC51B,GAApB,CAAwBuc,aAAxB,EAAuC,IAAvC;AACH;AACD;;;;;;;AAKAwZ,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCiB,KAApC,GAA4C,UAAUm1B,WAAV,EAAuB52B,EAAvB,EAA2B;AACnE,QAAIb,KAAK,GAAG,IAAZ;;AACA,QAAImW,EAAE,GAAGtV,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9B;AAAA,QAAkC0a,EAAE,GAAGpF,EAAE,CAACuhB,YAA1C;AAAA,QAAwDA,YAAY,GAAGnc,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAA/F;AAAA,QAAmG+b,cAAc,GAAGnhB,EAAE,CAACmhB,cAAvH;AACA;;;;;;;AAKAI,IAAAA,YAAY,IAAI,KAAKA,YAAL,CAAkBD,WAAlB,CAAhB;;AACA,QAAI1C,cAAc,GAAG,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACAzE,MAAAA,mBAAmB,GAPU,CAQ7B;AACA;;AACAtwB,MAAAA,KAAK,CAAC23B,UAAN;AACH,KAXD;;AAYA,QAAI3P,OAAO,GAAG,UAAUmI,KAAV,EAAiBqE,IAAjB,EAAuB;AACjC,UAAI3zB,EAAJ,EAAQsV,EAAR,CADiC,CAEjC;;;AACA,UAAIoF,EAAE,GAAGvb,KAAK,CAACyd,KAAf;AAAA,UAAsBa,IAAI,GAAG/C,EAAE,CAAC+C,IAAhC;AAAA,UAAsCsZ,eAAe,GAAGrc,EAAE,CAACqc,eAA3D;;AACA,UAAItZ,IAAI,IAAI,CAACsZ,eAAb,EAA8B;AAC1B,YAAI53B,KAAK,CAACu3B,cAAV,EACIv3B,KAAK,CAACu3B,cAAN;AACJv3B,QAAAA,KAAK,CAACu3B,cAAN,GAAuB3H,aAAa,CAACtR,IAAD,CAApC,CAH0B,CAI1B;;AACA,YAAI,CAACte,KAAK,CAACu3B,cAAX,EACI;AACP;AACD;;;;;;;;AAMAv3B,MAAAA,KAAK,CAAC63B,kBAAN;;AACA73B,MAAAA,KAAK,CAAC2d,aAAN,CAAoBxE,aAApB;AACA;;;;;;;AAKAnZ,MAAAA,KAAK,CAAC83B,sBAAN;AACA;;;;;;;;;;;;;AAWA,UAAIvnB,KAAK,GAAGyhB,yBAAyB,CAAC7B,KAAD,CAAzB,CAAiC5f,KAA7C;AACAsC,MAAAA,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AACrB,YAAIjN,EAAE,GAAGb,KAAK,CAAC2d,aAAN,CAAoBnO,SAApB,CAA8B1B,IAA9B,CAAT;AAAA,YAA8C1H,GAAG,GAAGvF,EAAE,CAACuF,GAAvD;AAAA,YAA4DC,GAAG,GAAGxF,EAAE,CAACwF,GAArE;AACArG,QAAAA,KAAK,CAACs3B,cAAN,CAAqBxpB,IAArB,IAA6BwpB,cAAc,GACrCA,cAAc,CAACxpB,IAAD,CADuB,GAErCnR,QAAQ,CAACyJ,GAAD,EAAMC,GAAN,EAAWkK,KAAK,CAACzC,IAAD,CAAhB,CAFd;AAGH,OALO,CAAR,CAtCiC,CA4CjC;;AACA9N,MAAAA,KAAK,CAACo3B,UAAN,GAAmB,IAAnB;AACAp3B,MAAAA,KAAK,CAACq3B,gBAAN,GAAyB,IAAzB,CA9CiC,CA+CjC;;AACA,OAAClhB,EAAE,GAAG,CAACtV,EAAE,GAAGb,KAAK,CAACyd,KAAZ,EAAmBsa,WAAzB,MAA0C,IAA1C,IAAkD5hB,EAAE,KAAK,KAAK,CAA9D,GAAkE,KAAK,CAAvE,GAA2EA,EAAE,CAAC2B,IAAH,CAAQjX,EAAR,EAAYsvB,KAAZ,EAAmBqE,IAAnB,CAA3E;AACH,KAjDD;;AAkDA,QAAIK,MAAM,GAAG,UAAU1E,KAAV,EAAiBqE,IAAjB,EAAuB;AAChC,UAAI3zB,EAAJ,EAAQsV,EAAR,EAAYoF,EAAZ,EAAgBoL,EAAhB;;AACA,UAAI8B,EAAE,GAAGzoB,KAAK,CAACyd,KAAf;AAAA,UAAsBma,eAAe,GAAGnP,EAAE,CAACmP,eAA3C;AAAA,UAA4DI,iBAAiB,GAAGvP,EAAE,CAACuP,iBAAnF,CAFgC,CAGhC;;AACA,UAAI,CAACJ,eAAD,IAAoB,CAAC53B,KAAK,CAACu3B,cAA/B,EACI;AACJ,UAAIrd,MAAM,GAAGsa,IAAI,CAACta,MAAlB,CANgC,CAOhC;;AACA,UAAI8d,iBAAiB,IAAIh4B,KAAK,CAACq3B,gBAAN,KAA2B,IAApD,EAA0D;AACtDr3B,QAAAA,KAAK,CAACq3B,gBAAN,GAAyBY,mBAAmB,CAAC/d,MAAD,CAA5C,CADsD,CAEtD;;AACA,YAAIla,KAAK,CAACq3B,gBAAN,KAA2B,IAA/B,EAAqC;AACjC,WAAClhB,EAAE,GAAG,CAACtV,EAAE,GAAGb,KAAK,CAACyd,KAAZ,EAAmBya,eAAzB,MAA8C,IAA9C,IAAsD/hB,EAAE,KAAK,KAAK,CAAlE,GAAsE,KAAK,CAA3E,GAA+EA,EAAE,CAAC2B,IAAH,CAAQjX,EAAR,EAAYb,KAAK,CAACq3B,gBAAlB,CAA/E;AACH;;AACD;AACH,OAf+B,CAgBhC;;;AACAr3B,MAAAA,KAAK,CAACm4B,UAAN,CAAiB,GAAjB,EAAsBhI,KAAtB;;AACAnwB,MAAAA,KAAK,CAACm4B,UAAN,CAAiB,GAAjB,EAAsBhI,KAAtB,EAlBgC,CAmBhC;;;AACA,OAACxJ,EAAE,GAAG,CAACpL,EAAE,GAAGvb,KAAK,CAACyd,KAAZ,EAAmB2a,MAAzB,MAAqC,IAArC,IAA6CzR,EAAE,KAAK,KAAK,CAAzD,GAA6D,KAAK,CAAlE,GAAsEA,EAAE,CAAC7O,IAAH,CAAQyD,EAAR,EAAY4U,KAAZ,EAAmBqE,IAAnB,CAAtE,CApBgC,CAqBhC;;AACA0C,MAAAA,gBAAgB,GAAG/G,KAAnB;AACH,KAvBD;;AAwBA,QAAIoF,KAAK,GAAG,UAAUpF,KAAV,EAAiBqE,IAAjB,EAAuB;AAAE,aAAOx0B,KAAK,CAACwC,IAAN,CAAW2tB,KAAX,EAAkBqE,IAAlB,CAAP;AAAiC,KAAtE;;AACA,QAAI1d,kBAAkB,GAAG,KAAK2G,KAAL,CAAW3G,kBAApC;AACA,SAAK0gB,UAAL,GAAkB,IAAItD,UAAJ,CAAeuD,WAAf,EAA4B;AAC1C1C,MAAAA,cAAc,EAAEA,cAD0B;AAE1C/M,MAAAA,OAAO,EAAEA,OAFiC;AAG1C6M,MAAAA,MAAM,EAAEA,MAHkC;AAI1CU,MAAAA,KAAK,EAAEA;AAJmC,KAA5B,EAKf;AAAEze,MAAAA,kBAAkB,EAAEA;AAAtB,KALe,CAAlB;AAMH,GAvGD;AAwGA;;;;;AAGAqgB,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCw2B,kBAApC,GAAyD,YAAY;AACjE,QAAIh0B,OAAO,GAAG,KAAK8Z,aAAL,CAAmBzY,WAAnB,EAAd;AACA,QAAIqC,SAAS,GAAG1D,OAAO,CAACsL,KAAR,CAAc5H,SAA9B;AACA,SAAKoW,aAAL,CAAmBrE,cAAnB;AACA,SAAKqE,aAAL,CAAmB3E,aAAnB;AACAnV,IAAAA,OAAO,CAACsL,KAAR,CAAc5H,SAAd,GAA0BA,SAA1B;AACA,SAAKoW,aAAL,CAAmBzE,gBAAnB;AACH,GAPD;;AAQAie,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCy2B,sBAApC,GAA6D,YAAY;AACrE,QAAIO,eAAe,GAAG,KAAK5a,KAAL,CAAW4a,eAAjC;;AACA,QAAIA,eAAJ,EAAqB;AACjB,WAAKhC,WAAL,GAAmB92B,WAAW,CAAC84B,eAAD,CAAX,GACb,KAAKC,qBAAL,CAA2B,KAAK3a,aAAL,CAAmB7W,GAA9C,EAAmDuxB,eAAnD,CADa,GAEb9B,uBAAuB,CAAC,KAAK5Y,aAAL,CAAmB7W,GAApB,EAAyBuxB,eAAzB,CAF7B;AAGH,KAJD,MAKK;AACD,WAAKhC,WAAL,GAAmB,KAAnB;AACH;AACJ,GAVD;;AAWAc,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCi3B,qBAApC,GAA4D,UAAU9B,SAAV,EAAqBH,WAArB,EAAkC;AAC1F,QAAIx1B,EAAE,GAAG,KAAK4c,KAAd;AAAA,QAAqB8a,wBAAwB,GAAG13B,EAAE,CAAC03B,wBAAnD;AAAA,QAA6EzhB,kBAAkB,GAAGjW,EAAE,CAACiW,kBAArG;AACA,QAAI0hB,kBAAkB,GAAGnC,WAAW,CAAC71B,OAArC;AACAvD,IAAAA,SAAS,CAACu7B,kBAAkB,KAAK,IAAxB,EAA8B,wGAA9B,CAAT;AACA,SAAK3B,cAAL,GAAsBhgB,cAAc,CAAC2hB,kBAAD,EAAqB1hB,kBAArB,CAApC;AACA,QAAI2hB,mBAAmB,GAAG7B,uBAAuB,CAACJ,SAAD,EAAY,KAAKK,cAAjB,CAAjD;AACA;;;;;AAIA,QAAI0B,wBAAJ,EAA8B;AAC1B,UAAIG,eAAe,GAAGH,wBAAwB,CAAChyB,2BAA2B,CAACkyB,mBAAD,CAA5B,CAA9C;;AACA,UAAIC,eAAJ,EAAqB;AACjBD,QAAAA,mBAAmB,GAAG3yB,2BAA2B,CAAC4yB,eAAD,CAAjD;AACH;AACJ;;AACD,WAAOD,mBAAP;AACH,GAjBD;;AAkBAtB,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCs3B,UAApC,GAAiD,YAAY;AACzDpI,IAAAA,qBAAqB;AACrB,SAAK6G,UAAL,GAAkB,KAAlB;AACA,SAAKI,UAAL,IAAmB,KAAKA,UAAL,CAAgBlC,GAAhB,EAAnB;AACA,SAAKkC,UAAL,GAAkB,IAAlB;;AACA,QAAI,CAAC,KAAK/Z,KAAL,CAAWma,eAAZ,IAA+B,KAAKL,cAAxC,EAAwD;AACpD,WAAKA,cAAL;AACA,WAAKA,cAAL,GAAsB,IAAtB;AACH;AACJ,GATD;;AAUAJ,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCmB,IAApC,GAA2C,UAAU2tB,KAAV,EAAiBqE,IAAjB,EAAuB;AAC9D,QAAI3zB,EAAJ;;AACA,SAAK8c,aAAL,CAAmBvE,eAAnB;AACA,KAACvY,EAAE,GAAG,KAAK22B,UAAX,MAA2B,IAA3B,IAAmC32B,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACy0B,GAAH,EAA5D;AACA,SAAKkC,UAAL,GAAkB,IAAlB;AACA,QAAIJ,UAAU,GAAG,KAAKA,UAAtB;AACA,SAAKuB,UAAL;AACA,QAAI,CAACvB,UAAL,EACI;AACJ,QAAIjhB,EAAE,GAAG,KAAKsH,KAAd;AAAA,QAAqBmb,YAAY,GAAGziB,EAAE,CAACyiB,YAAvC;AAAA,QAAqDC,WAAW,GAAG1iB,EAAE,CAAC0iB,WAAtE;AAAA,QAAmFC,SAAS,GAAG3iB,EAAE,CAAC2iB,SAAlG;;AACA,QAAIF,YAAY,IAAIC,WAApB,EAAiC;AAC7B,UAAI5jB,QAAQ,GAAGuf,IAAI,CAACvf,QAApB;AACA,WAAK8jB,cAAL,CAAoB9jB,QAApB;AACH;;AACD6jB,IAAAA,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAAC3I,KAAD,EAAQqE,IAAR,CAA/D;AACH,GAfD;;AAgBA2C,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCq2B,YAApC,GAAmD,UAAUvH,KAAV,EAAiB;AAChE,SAAK0H,kBAAL;AACA,SAAKP,cAAL,CAAoBnxB,CAApB,GAAwB,GAAxB;AACA,SAAKmxB,cAAL,CAAoBhxB,CAApB,GAAwB,GAAxB;AACA,SAAK6xB,UAAL,CAAgB,GAAhB,EAAqBhI,KAArB;AACA,SAAKgI,UAAL,CAAgB,GAAhB,EAAqBhI,KAArB;AACH,GAND;AAOA;;;;;AAGAgH,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoC82B,UAApC,GAAiD,UAAUrqB,IAAV,EAAgBqiB,KAAhB,EAAuB;AACpE,QAAItvB,EAAJ;;AACA,QAAIsV,EAAE,GAAG,KAAKsH,KAAd;AAAA,QAAqBa,IAAI,GAAGnI,EAAE,CAACmI,IAA/B;AAAA,QAAqCua,WAAW,GAAG1iB,EAAE,CAAC0iB,WAAtD,CAFoE,CAGpE;;AACA,QAAI,CAACG,UAAU,CAAClrB,IAAD,EAAOwQ,IAAP,EAAa,KAAK+Y,gBAAlB,CAAf,EACI,OALgE,CAMpE;;AACA,QAAI4B,UAAU,GAAG,KAAKtb,aAAL,CAAmB7W,GAAnB,CAAuBgH,IAAvB,CAAjB,CAPoE,CAQpE;AACA;;AACA,QAAIipB,UAAU,GAAGkC,UAAU,CAAC5yB,GAAX,GAAiB4yB,UAAU,CAAC7yB,GAA7C,CAVoE,CAWpE;;AACA,QAAIuR,YAAY,GAAG,KAAK2f,cAAL,CAAoBxpB,IAApB,CAAnB;AACA,QAAIyC,KAAK,GAAGyhB,yBAAyB,CAAC7B,KAAD,CAAzB,CAAiC5f,KAA7C,CAboE,CAcpE;;AACA,QAAInK,GAAG,GAAGgwB,uBAAuB,CAAC7lB,KAAK,CAACzC,IAAD,CAAN,EAAcipB,UAAd,EAA0Bpf,YAA1B,EAAwC,CAAC9W,EAAE,GAAG,KAAKw1B,WAAX,MAA4B,IAA5B,IAAoCx1B,EAAE,KAAK,KAAK,CAAhD,GAAoD,KAAK,CAAzD,GAA6DA,EAAE,CAACiN,IAAD,CAAvG,EAA+G+qB,WAA/G,CAAjC,CAfoE,CAgBpE;;AACA,SAAKlb,aAAL,CAAmBpE,aAAnB,CAAiCzL,IAAjC,EAAuC1H,GAAvC,EAA4CA,GAAG,GAAG2wB,UAAlD;AACH,GAlBD;;AAmBAI,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoC63B,WAApC,GAAkD,UAAUr4B,EAAV,EAAc;AAC5D,QAAIsV,EAAE,GAAGtV,EAAE,CAACyd,IAAZ;AAAA,QAAkBA,IAAI,GAAGnI,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAAjD;AAAA,QAAqDoF,EAAE,GAAG1a,EAAE,CAACm3B,iBAA7D;AAAA,QAAgFA,iBAAiB,GAAGzc,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAA5H;AAAA,QAAgIoL,EAAE,GAAG9lB,EAAE,CAAC+2B,eAAxI;AAAA,QAAyJA,eAAe,GAAGjR,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAAnM;AAAA,QAAuM8B,EAAE,GAAG5nB,EAAE,CAACw3B,eAA/M;AAAA,QAAgOA,eAAe,GAAG5P,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAA1Q;AAAA,QAA8Q0Q,EAAE,GAAGt4B,EAAE,CAACg4B,WAAtR;AAAA,QAAmSA,WAAW,GAAGM,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAAxU;AAAA,QAA4UC,EAAE,GAAGv4B,EAAE,CAAC+3B,YAApV;AAAA,QAAkWA,YAAY,GAAGQ,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAAxY;AAAA,QAA4YC,cAAc,GAAGn9B,MAAM,CAAC2E,EAAD,EAAK,CAAC,MAAD,EAAS,mBAAT,EAA8B,iBAA9B,EAAiD,iBAAjD,EAAoE,aAApE,EAAmF,cAAnF,CAAL,CAAna;;AACA,SAAK4c,KAAL,GAAazhB,QAAQ,CAAC;AAAEsiB,MAAAA,IAAI,EAAEA,IAAR;AAClB0Z,MAAAA,iBAAiB,EAAEA,iBADD;AAElBJ,MAAAA,eAAe,EAAEA,eAFC;AAGlBS,MAAAA,eAAe,EAAEA,eAHC;AAIlBQ,MAAAA,WAAW,EAAEA,WAJK;AAKlBD,MAAAA,YAAY,EAAEA;AALI,KAAD,EAKaS,cALb,CAArB;AAMH,GARD;;AASAlC,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoC03B,cAApC,GAAqD,UAAU9jB,QAAV,EAAoB;AACrE,QAAIjV,KAAK,GAAG,IAAZ;;AACA,QAAIa,EAAE,GAAG,KAAK4c,KAAd;AAAA,QAAqBa,IAAI,GAAGzd,EAAE,CAACyd,IAA/B;AAAA,QAAqCsa,YAAY,GAAG/3B,EAAE,CAAC+3B,YAAvD;AAAA,QAAqEC,WAAW,GAAGh4B,EAAE,CAACg4B,WAAtF;AAAA,QAAmGS,cAAc,GAAGz4B,EAAE,CAACy4B,cAAvH;AACA,QAAIC,kBAAkB,GAAG1mB,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AAC9C,UAAI,CAACkrB,UAAU,CAAClrB,IAAD,EAAOwQ,IAAP,EAAate,KAAK,CAACq3B,gBAAnB,CAAf,EAAqD;AACjD;AACH;;AACD,UAAI5hB,UAAU,GAAGzV,KAAK,CAACq2B,WAAN,GAAoBr2B,KAAK,CAACq2B,WAAN,CAAkBvoB,IAAlB,CAApB,GAA8C,EAA/D;AACA;;;;;;;AAMA,UAAI0rB,eAAe,GAAGX,WAAW,GAAG,GAAH,GAAS,OAA1C;AACA,UAAIY,aAAa,GAAGZ,WAAW,GAAG,EAAH,GAAQ,QAAvC;;AACA,UAAIz6B,OAAO,GAAGpC,QAAQ,CAACA,QAAQ,CAAC;AAAEuP,QAAAA,IAAI,EAAE,SAAR;AAAmB0J,QAAAA,QAAQ,EAAE2jB,YAAY,GAAG3jB,QAAQ,CAACnH,IAAD,CAAX,GAAoB,CAA7D;AAAgE0rB,QAAAA,eAAe,EAAEA,eAAjF;AAC5BC,QAAAA,aAAa,EAAEA,aADa;AACEC,QAAAA,YAAY,EAAE,GADhB;AACqBrmB,QAAAA,SAAS,EAAE,CADhC;AACmCC,QAAAA,SAAS,EAAE;AAD9C,OAAD,EACqDgmB,cADrD,CAAT,EAC+E7jB,UAD/E,CAAtB,CAb8C,CAe9C;AACA;AACA;;;AACA,aAAOzV,KAAK,CAAC2d,aAAN,CAAoBlE,wBAApB,CAA6C3L,IAA7C,EAAmD1P,OAAnD,CAAP;AACH,KAnBgC,CAAjC,CAHqE,CAuBrE;;AACA,WAAOqE,OAAO,CAACugB,GAAR,CAAYuW,kBAAZ,EAAgC32B,IAAhC,CAAqC,YAAY;AACpD,UAAI/B,EAAJ,EAAQsV,EAAR;;AACA,OAACA,EAAE,GAAG,CAACtV,EAAE,GAAGb,KAAK,CAACyd,KAAZ,EAAmBkc,mBAAzB,MAAkD,IAAlD,IAA0DxjB,EAAE,KAAK,KAAK,CAAtE,GAA0E,KAAK,CAA/E,GAAmFA,EAAE,CAAC2B,IAAH,CAAQjX,EAAR,CAAnF;AACH,KAHM,CAAP;AAIH,GA5BD;;AA6BAs2B,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCs2B,UAApC,GAAiD,YAAY;AACzD,SAAKha,aAAL,CAAmBtE,mBAAnB;AACH,GAFD;;AAGA8d,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCiP,UAApC,GAAiD,YAAY;AACzD,QAAItQ,KAAK,GAAG,IAAZ;;AACA,QAAIa,EAAE,GAAG,KAAK4c,KAAd;AAAA,QAAqBa,IAAI,GAAGzd,EAAE,CAACyd,IAA/B;AAAA,QAAqC+Z,eAAe,GAAGx3B,EAAE,CAACw3B,eAA1D;AACA,QAAI,CAAC94B,WAAW,CAAC84B,eAAD,CAAZ,IAAiC,CAAC,KAAKxB,cAA3C,EACI,OAJqD,CAKzD;;AACA,SAAKc,UAAL,GANyD,CAOzD;;AACA,QAAIiC,WAAW,GAAG;AAAEzzB,MAAAA,CAAC,EAAE,CAAL;AAAQG,MAAAA,CAAC,EAAE;AAAX,KAAlB;AACAuM,IAAAA,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AACrB8rB,MAAAA,WAAW,CAAC9rB,IAAD,CAAX,GAAoBuE,UAAU,CAACrS,KAAK,CAAC2d,aAAN,CAAoBnO,SAApB,CAA8B1B,IAA9B,CAAD,EAAsC9N,KAAK,CAAC62B,cAAN,CAAqB/oB,IAArB,CAAtC,CAA9B;AACH,KAFO,CAAR;AAGA;;;;;;AAKA,SAAK+pB,kBAAL;AACA,SAAKC,sBAAL;AACAjlB,IAAAA,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AACrB,UAAI,CAACkrB,UAAU,CAAClrB,IAAD,EAAOwQ,IAAP,EAAa,IAAb,CAAf,EACI,OAFiB,CAGrB;AACA;;AACA,UAAIzd,EAAE,GAAGi2B,wBAAwB,CAAC92B,KAAK,CAAC2d,aAAN,CAAoBnO,SAApB,CAA8B1B,IAA9B,CAAD,EAAsC9N,KAAK,CAAC62B,cAAN,CAAqB/oB,IAArB,CAAtC,EAAkE8rB,WAAW,CAAC9rB,IAAD,CAA7E,CAAjC;AAAA,UAAuH1H,GAAG,GAAGvF,EAAE,CAACuF,GAAhI;AAAA,UAAqIC,GAAG,GAAGxF,EAAE,CAACwF,GAA9I;;AACArG,MAAAA,KAAK,CAAC2d,aAAN,CAAoBpE,aAApB,CAAkCzL,IAAlC,EAAwC1H,GAAxC,EAA6CC,GAA7C;AACH,KAPO,CAAR;AAQH,GA3BD;;AA4BA8wB,EAAAA,yBAAyB,CAAC91B,SAA1B,CAAoCyC,KAApC,GAA4C,UAAU6Z,aAAV,EAAyB;AACjE,QAAI3d,KAAK,GAAG,IAAZ;;AACA,QAAI6D,OAAO,GAAG8Z,aAAa,CAACzY,WAAd,EAAd;AACA;;;;AAGA,QAAI20B,mBAAmB,GAAGxG,eAAe,CAACxvB,OAAD,EAAU,aAAV,EAAyB,UAAUssB,KAAV,EAAiB;AAC/E,UAAItvB,EAAE,GAAGb,KAAK,CAACyd,KAAf;AAAA,UAAsBa,IAAI,GAAGzd,EAAE,CAACyd,IAAhC;AAAA,UAAsCnI,EAAE,GAAGtV,EAAE,CAACi5B,YAA9C;AAAA,UAA4DA,YAAY,GAAG3jB,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAAlG;AACAmI,MAAAA,IAAI,IAAIwb,YAAR,IAAwB95B,KAAK,CAACsC,KAAN,CAAY6tB,KAAZ,CAAxB;AACH,KAHwC,CAAzC;AAIA;;;;;AAIA,QAAI4J,kBAAkB,GAAGvJ,WAAW,CAAC1X,MAAD,EAAS,QAAT,EAAmB,YAAY;AAC/D9Y,MAAAA,KAAK,CAACsQ,UAAN;AACH,KAFmC,CAApC;AAGA;;;;;AAIA,QAAI0pB,wBAAwB,GAAGrc,aAAa,CAACnF,cAAd,CAA6B,YAAY;AACpE,UAAIxY,KAAK,CAACo3B,UAAV,EACIp3B,KAAK,CAAC83B,sBAAN;AACP,KAH8B,CAA/B;AAIA;;;;;AAIA,QAAImC,YAAY,GAAGtc,aAAa,CAACsc,YAAjC;AACA,KAACA,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAAC7C,UAA1E,KACI,KAAK90B,KAAL,CAAW40B,gBAAX,EAA6B;AACzBI,MAAAA,cAAc,EAAE2C,YAAY,CAAC3C;AADJ,KAA7B,CADJ;AAIA;;;;AAGA,WAAO,YAAY;AACfuC,MAAAA,mBAAmB,KAAK,IAAxB,IAAgCA,mBAAmB,KAAK,KAAK,CAA7D,GAAiE,KAAK,CAAtE,GAA0EA,mBAAmB,EAA7F;AACAE,MAAAA,kBAAkB,KAAK,IAAvB,IAA+BA,kBAAkB,KAAK,KAAK,CAA3D,GAA+D,KAAK,CAApE,GAAwEA,kBAAkB,EAA1F;AACAC,MAAAA,wBAAwB,KAAK,IAA7B,IAAqCA,wBAAwB,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,wBAAwB,EAA5G;;AACAh6B,MAAAA,KAAK,CAAC24B,UAAN;AACH,KALD;AAMH,GA3CD;;AA4CA,SAAOxB,yBAAP;AACH,CAhX8C,EAA/C;;AAiXA,SAAS6B,UAAT,CAAoBkB,SAApB,EAA+B5b,IAA/B,EAAqC+Y,gBAArC,EAAuD;AACnD,SAAQ,CAAC/Y,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK4b,SAA3B,MACH7C,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK6C,SAD/C,CAAR;AAEH;AACD;;;;;;;;;AAOA,SAASjC,mBAAT,CAA6B/d,MAA7B,EAAqCigB,aAArC,EAAoD;AAChD,MAAIA,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,IAAAA,aAAa,GAAG,EAAhB;AAAqB;;AACrD,MAAID,SAAS,GAAG,IAAhB;;AACA,MAAI1yB,IAAI,CAAC4yB,GAAL,CAASlgB,MAAM,CAAC5T,CAAhB,IAAqB6zB,aAAzB,EAAwC;AACpCD,IAAAA,SAAS,GAAG,GAAZ;AACH,GAFD,MAGK,IAAI1yB,IAAI,CAAC4yB,GAAL,CAASlgB,MAAM,CAAC/T,CAAhB,IAAqBg0B,aAAzB,EAAwC;AACzCD,IAAAA,SAAS,GAAG,GAAZ;AACH;;AACD,SAAOA,SAAP;AACH;AAED;;;;;;;AAKA,SAASG,OAAT,CAAiB5c,KAAjB,EAAwBE,aAAxB,EAAuC;AACnC,MAAI2c,iBAAiB,GAAG7c,KAAK,CAAC8c,YAA9B;AACA,MAAIzjB,kBAAkB,GAAGpY,UAAU,CAAC8rB,mBAAD,CAAV,CAAgC1T,kBAAzD;AACA,MAAIyjB,YAAY,GAAGvgB,WAAW,CAAC,YAAY;AACvC,WAAO,IAAImd,yBAAJ,CAA8B;AACjCxZ,MAAAA,aAAa,EAAEA;AADkB,KAA9B,CAAP;AAGH,GAJ6B,CAA9B;AAKA4c,EAAAA,YAAY,CAACrB,WAAb,CAAyBl9B,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKyhB,KAAL,CAAT,EAAsB;AAAE3G,IAAAA,kBAAkB,EAAEA;AAAtB,GAAtB,CAAjC,EARmC,CASnC;AACA;;AACAnY,EAAAA,SAAS,CAAC,YAAY;AAAE,WAAO27B,iBAAiB,IAAIA,iBAAiB,CAACl2B,SAAlB,CAA4Bm2B,YAA5B,CAA5B;AAAwE,GAAvF,EAAyF,CAACA,YAAD,CAAzF,CAAT,CAXmC,CAYnC;;AACA57B,EAAAA,SAAS,CAAC,YAAY;AAAE,WAAO47B,YAAY,CAACz2B,KAAb,CAAmB6Z,aAAnB,CAAP;AAA2C,GAA1D,EAA4D,EAA5D,CAAT;AACH;;AAED,IAAI6c,IAAI,GAAG;AACPj2B,EAAAA,GAAG,EAAE,MADE;AAEPwpB,EAAAA,YAAY,EAAE,UAAUtQ,KAAV,EAAiB;AAAE,WAAO,CAAC,CAACA,KAAK,CAACa,IAAf;AAAsB,GAFhD;AAGPtf,EAAAA,SAAS,EAAE8rB,uBAAuB,CAAC,UAAUjqB,EAAV,EAAc;AAC7C,QAAI8c,aAAa,GAAG9c,EAAE,CAAC8c,aAAvB;AAAA,QAAsCF,KAAK,GAAGvhB,MAAM,CAAC2E,EAAD,EAAK,CAAC,eAAD,CAAL,CAApD;;AACA,WAAOw5B,OAAO,CAAC5c,KAAD,EAAQE,aAAR,CAAd;AACH,GAHiC;AAH3B,CAAX;AASA;;;;;;;;;;;;;AAYA,SAAS8c,aAAT,CAAuB55B,EAAvB,EAA2BrB,GAA3B,EAAgC;AAC5B,MAAIk7B,KAAK,GAAG75B,EAAE,CAAC65B,KAAf;AAAA,MAAsBC,UAAU,GAAG95B,EAAE,CAAC85B,UAAtC;AAAA,MAAkDC,QAAQ,GAAG/5B,EAAE,CAAC+5B,QAAhE;AAAA,MAA0EC,iBAAiB,GAAGh6B,EAAE,CAACg6B,iBAAjG;AACA,MAAIC,YAAY,GAAGJ,KAAK,IAAIC,UAAT,IAAuBC,QAAvB,IAAmCC,iBAAtD;AACA,MAAIrD,UAAU,GAAGh5B,MAAM,CAAC,IAAD,CAAvB;AACA,MAAIsY,kBAAkB,GAAGpY,UAAU,CAAC8rB,mBAAD,CAAV,CAAgC1T,kBAAzD;AACA,MAAIqd,QAAQ,GAAG;AACXY,IAAAA,cAAc,EAAE8F,iBADL;AAEX7S,IAAAA,OAAO,EAAE2S,UAFE;AAGX9F,IAAAA,MAAM,EAAE6F,KAHG;AAIXnF,IAAAA,KAAK,EAAE,UAAUpF,KAAV,EAAiBqE,IAAjB,EAAuB;AAC1BgD,MAAAA,UAAU,CAACh3B,OAAX,GAAqB,IAArB;AACAo6B,MAAAA,QAAQ,IAAIA,QAAQ,CAACzK,KAAD,EAAQqE,IAAR,CAApB;AACH;AAPU,GAAf;AASA71B,EAAAA,SAAS,CAAC,YAAY;AAClB,QAAI64B,UAAU,CAACh3B,OAAX,KAAuB,IAA3B,EAAiC;AAC7Bg3B,MAAAA,UAAU,CAACh3B,OAAX,CAAmBi1B,cAAnB,CAAkCtB,QAAlC;AACH;AACJ,GAJQ,CAAT;;AAKA,WAAS4G,aAAT,CAAuB5K,KAAvB,EAA8B;AAC1BqH,IAAAA,UAAU,CAACh3B,OAAX,GAAqB,IAAI0zB,UAAJ,CAAe/D,KAAf,EAAsBgE,QAAtB,EAAgC;AACjDrd,MAAAA,kBAAkB,EAAEA;AAD6B,KAAhC,CAArB;AAGH;;AACDwc,EAAAA,eAAe,CAAC9zB,GAAD,EAAM,aAAN,EAAqBs7B,YAAY,IAAIC,aAArC,CAAf;AACAlM,EAAAA,gBAAgB,CAAC,YAAY;AAAE,WAAO2I,UAAU,CAACh3B,OAAX,IAAsBg3B,UAAU,CAACh3B,OAAX,CAAmB80B,GAAnB,EAA7B;AAAwD,GAAvE,CAAhB;AACH;AAED;;;;;;;;;AAOA,IAAI0F,aAAa,GAAG,UAAU93B,MAAV,EAAkBmB,KAAlB,EAAyB;AACzC,MAAI,CAACA,KAAL,EAAY;AACR,WAAO,KAAP;AACH,GAFD,MAGK,IAAInB,MAAM,KAAKmB,KAAf,EAAsB;AACvB,WAAO,IAAP;AACH,GAFI,MAGA;AACD,WAAO22B,aAAa,CAAC93B,MAAD,EAASmB,KAAK,CAAC42B,aAAf,CAApB;AACH;AACJ,CAVD;;AAYA,IAAIC,OAAO,GAAG,CAAC,YAAD,EAAe,UAAf,EAA2B,WAA3B,CAAd;;AACA,IAAIC,kBAAkB,GAAG,UAAUC,OAAV,EAAmB;AACxC,SAAOF,OAAO,CAAC3uB,OAAR,CAAgB6uB,OAAhB,IAA2B,CAAlC;AACH,CAFD;;AAIA,IAAIC,kBAAkB,GAAGF,kBAAkB,CAAC,UAAD,CAA3C;AACA;;;;;AAIA,SAASG,aAAT,CAAuBz6B,EAAvB,EAA2BrB,GAA3B,EAAgC;AAC5B,MAAI+7B,KAAK,GAAG16B,EAAE,CAAC06B,KAAf;AAAA,MAAsBC,UAAU,GAAG36B,EAAE,CAAC26B,UAAtC;AAAA,MAAkDC,WAAW,GAAG56B,EAAE,CAAC46B,WAAnE;AAAA,MAAgFhY,QAAQ,GAAG5iB,EAAE,CAAC4iB,QAA9F;AAAA,MAAwGd,QAAQ,GAAG9hB,EAAE,CAAC8hB,QAAtH;AACA,MAAI+Y,eAAe,GAAGH,KAAK,IAAIC,UAAT,IAAuBC,WAAvB,IAAsChY,QAA5D;AACA,MAAIkY,SAAS,GAAGn9B,MAAM,CAAC,KAAD,CAAtB;AACA,MAAIo9B,0BAA0B,GAAGp9B,MAAM,CAAC,IAAD,CAAvC;;AACA,WAASq9B,eAAT,GAA2B;AACvBD,IAAAA,0BAA0B,CAACp7B,OAA3B,IACIo7B,0BAA0B,CAACp7B,OAA3B,EADJ;AAEAo7B,IAAAA,0BAA0B,CAACp7B,OAA3B,GAAqC,IAArC;AACH;;AACD,MAAIijB,QAAQ,IAAId,QAAhB,EAA0B;AACtBA,IAAAA,QAAQ,CAAC2E,WAAT,CAAqB7D,QAArB,EAA+B4X,kBAA/B;AACH,GAZ2B,CAa5B;AACA;;;AACA,MAAIS,WAAW,GAAGt9B,MAAM,CAAC,IAAD,CAAxB;;AACAs9B,EAAAA,WAAW,CAACt7B,OAAZ,GAAsB,UAAU2vB,KAAV,EAAiBqE,IAAjB,EAAuB;AACzC,QAAI3wB,OAAO,GAAGrE,GAAG,CAACgB,OAAlB;AACAq7B,IAAAA,eAAe;AACf,QAAI,CAACF,SAAS,CAACn7B,OAAX,IAAsB,CAACqD,OAA3B,EACI;AACJ83B,IAAAA,SAAS,CAACn7B,OAAV,GAAoB,KAApB;;AACA,QAAImiB,QAAQ,IAAIc,QAAhB,EAA0B;AACtBd,MAAAA,QAAQ,CAAC+E,aAAT,CAAuB2T,kBAAvB;AACH,KARwC,CASzC;AACA;;;AACA,QAAIU,eAAe,GAAGnM,aAAa,CAAC,IAAD,CAAnC;AACA,QAAI,CAACmM,eAAL,EACI;AACJA,IAAAA,eAAe;;AACf,QAAI,CAACf,aAAa,CAACn3B,OAAD,EAAUssB,KAAK,CAACpe,MAAhB,CAAlB,EAA2C;AACvC0pB,MAAAA,WAAW,IAAIA,WAAW,CAACtL,KAAD,EAAQqE,IAAR,CAA1B;AACH,KAFD,MAGK;AACD+G,MAAAA,KAAK,IAAIA,KAAK,CAACpL,KAAD,EAAQqE,IAAR,CAAd;AACH;AACJ,GArBD;;AAsBA,WAASuG,aAAT,CAAuB5K,KAAvB,EAA8BqE,IAA9B,EAAoC;AAChCqH,IAAAA,eAAe;AACfD,IAAAA,0BAA0B,CAACp7B,OAA3B,GAAqC6yB,eAAe,CAACva,MAAD,EAAS,WAAT,EAAsB,UAAUqX,KAAV,EAAiBqE,IAAjB,EAAuB;AAAE,aAAOsH,WAAW,CAACt7B,OAAZ,CAAoB2vB,KAApB,EAA2BqE,IAA3B,CAAP;AAA0C,KAAzF,CAApD;AACA,QAAI3wB,OAAO,GAAGrE,GAAG,CAACgB,OAAlB;AACA,QAAI,CAACqD,OAAD,IAAY83B,SAAS,CAACn7B,OAA1B,EACI;AACJm7B,IAAAA,SAAS,CAACn7B,OAAV,GAAoB,IAApB;AACAg7B,IAAAA,UAAU,IAAIA,UAAU,CAACrL,KAAD,EAAQqE,IAAR,CAAxB;;AACA,QAAI7R,QAAQ,IAAIc,QAAhB,EAA0B;AACtBd,MAAAA,QAAQ,CAAC6E,aAAT,CAAuB6T,kBAAvB;AACH;AACJ;;AACD/H,EAAAA,eAAe,CAAC9zB,GAAD,EAAM,aAAN,EAAqBk8B,eAAe,GAAGX,aAAH,GAAmBh2B,SAAvD,CAAf;AACA8pB,EAAAA,gBAAgB,CAACgN,eAAD,CAAhB;AACH;;AAED,IAAIG,aAAa,GAAGb,kBAAkB,CAAC,YAAD,CAAtC;;AACA,IAAIc,WAAW,GAAG,UAAUvjB,QAAV,EAAoB;AAAE,SAAO,UAAUyX,KAAV,EAAiBqE,IAAjB,EAAuB;AAClE,QAAI5D,YAAY,CAACT,KAAD,CAAhB,EACIzX,QAAQ,CAACyX,KAAD,EAAQqE,IAAR,CAAR;AACP,GAHuC;AAGpC,CAHJ;AAIA;;;;;;;;AAMA,SAAS0H,eAAT,CAAyBr7B,EAAzB,EAA6BrB,GAA7B,EAAkC;AAC9B,MAAIkkB,UAAU,GAAG7iB,EAAE,CAAC6iB,UAApB;AAAA,MAAgCyY,YAAY,GAAGt7B,EAAE,CAACs7B,YAAlD;AAAA,MAAgEC,UAAU,GAAGv7B,EAAE,CAACu7B,UAAhF;AAAA,MAA4FzZ,QAAQ,GAAG9hB,EAAE,CAAC8hB,QAA1G;;AACA,MAAIe,UAAU,IAAIf,QAAlB,EAA4B;AACxBA,IAAAA,QAAQ,CAAC2E,WAAT,CAAqB5D,UAArB,EAAiCsY,aAAjC;AACH;;AACD1I,EAAAA,eAAe,CAAC9zB,GAAD,EAAM,cAAN,EAAsBy8B,WAAW,CAAC,UAAU9L,KAAV,EAAiBqE,IAAjB,EAAuB;AACpE,QAAI2H,YAAJ,EACIA,YAAY,CAAChM,KAAD,EAAQqE,IAAR,CAAZ;;AACJ,QAAI9Q,UAAU,IAAIf,QAAlB,EAA4B;AACxBA,MAAAA,QAAQ,CAAC6E,aAAT,CAAuBwU,aAAvB;AACH;AACJ,GAN+C,CAAjC,CAAf;AAOA1I,EAAAA,eAAe,CAAC9zB,GAAD,EAAM,cAAN,EAAsBy8B,WAAW,CAAC,UAAU9L,KAAV,EAAiBqE,IAAjB,EAAuB;AACpE,QAAI4H,UAAJ,EACIA,UAAU,CAACjM,KAAD,EAAQqE,IAAR,CAAV;;AACJ,QAAI9Q,UAAU,IAAIf,QAAlB,EAA4B;AACxBA,MAAAA,QAAQ,CAAC+E,aAAT,CAAuBsU,aAAvB;AACH;AACJ,GAN+C,CAAjC,CAAf;AAOH;AAED;;;;;;;;;AAOA,SAASK,WAAT,CAAqB5e,KAArB,EAA4Bje,GAA5B,EAAiC;AAC7Bi7B,EAAAA,aAAa,CAAChd,KAAD,EAAQje,GAAR,CAAb;AACA87B,EAAAA,aAAa,CAAC7d,KAAD,EAAQje,GAAR,CAAb;AACA08B,EAAAA,eAAe,CAACze,KAAD,EAAQje,GAAR,CAAf;AACH;;AAED,IAAI88B,YAAY,GAAG,CACf,OADe,EAEf,YAFe,EAGf,UAHe,EAIf,mBAJe,EAKf,OALe,EAMf,YANe,EAOf,aAPe,EAQf,UARe,EASf,YATe,EAUf,cAVe,EAWf,YAXe,CAAnB;AAaA,IAAIC,QAAQ,GAAG;AACXh4B,EAAAA,GAAG,EAAE,UADM;AAEXwpB,EAAAA,YAAY,EAAE,UAAUtQ,KAAV,EAAiB;AAC3B,WAAO6e,YAAY,CAACxc,IAAb,CAAkB,UAAUvb,GAAV,EAAe;AAAE,aAAOkZ,KAAK,CAAChe,cAAN,CAAqB8E,GAArB,CAAP;AAAmC,KAAtE,CAAP;AACH,GAJU;AAKXvF,EAAAA,SAAS,EAAE8rB,uBAAuB,CAAC,UAAUjqB,EAAV,EAAc;AAC7C,QAAI8c,aAAa,GAAG9c,EAAE,CAAC8c,aAAvB;AAAA,QAAsCF,KAAK,GAAGvhB,MAAM,CAAC2E,EAAD,EAAK,CAAC,eAAD,CAAL,CAApD;;AACAw7B,IAAAA,WAAW,CAAC5e,KAAD,EAAQE,aAAR,CAAX;AACH,GAHiC;AALvB,CAAf;AAWA,IAAI6e,IAAI,GAAG;AACPj4B,EAAAA,GAAG,EAAE,MADE;AAEPwpB,EAAAA,YAAY,EAAE,UAAUtQ,KAAV,EAAiB;AAAE,WAAO,CAAC,CAACA,KAAK,CAACgf,IAAR,IAAgB,CAACnY,yBAAyB,CAAC7G,KAAD,CAAjD;AAA2D,GAFrF;AAGPze,EAAAA,SAAS,EAAE8rB,uBAAuB,CAAC,UAAUrN,KAAV,EAAiB;AAChD,QAAI7G,OAAO,GAAG6G,KAAK,CAAC7G,OAApB;AAAA,QAA6B+L,QAAQ,GAAGlF,KAAK,CAACkF,QAA9C;AAAA,QAAwD8Z,IAAI,GAAGhf,KAAK,CAACgf,IAArE;;AACA,QAAI57B,EAAE,GAAGgc,WAAW,EAApB;AAAA,QAAwBE,SAAS,GAAGlc,EAAE,CAAC,CAAD,CAAtC;AAAA,QAA2Cmc,cAAc,GAAGnc,EAAE,CAAC,CAAD,CAA9D;;AACA,QAAI8iB,eAAe,GAAGjlB,UAAU,CAACke,eAAD,CAAhC;AACA,QAAI8f,sBAAsB,GAAGl+B,MAAM,CAAC,KAAD,CAAnC;AACA,QAAI4oB,MAAM,GAAG,CAACzD,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,eAAe,CAACyD,MAAnF,MAA+FriB,SAA/F,GACP4e,eAAe,CAACyD,MADT,GAEP3J,KAAK,CAAC2J,MAFZ;AAGAzoB,IAAAA,SAAS,CAAC,YAAY;AAClB,UAAI,CAACoe,SAAL,EAAgB;AACZ,YAAI,CAAC2f,sBAAsB,CAACl8B,OAAxB,IAAmCi8B,IAAvC,EAA6C;AACzC9Z,UAAAA,QAAQ,CAAC4D,QAAT,CAAkBvqB,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKyhB,KAAL,CAAT,EAAsB;AAAE2J,YAAAA,MAAM,EAAEA;AAAV,WAAtB,CAA1B;AACAzE,UAAAA,QAAQ,CAACrgB,KAAT,CAAem6B,IAAf,EAAqB75B,IAArB,CAA0Boa,cAA1B;AACH;;AACD0f,QAAAA,sBAAsB,CAACl8B,OAAvB,GAAiC,IAAjC;AACH,OAND,MAOK,IAAIk8B,sBAAsB,CAACl8B,OAAvB,IACLoW,OADK,IAEL,OAAOA,OAAP,KAAmB,SAFd,IAGL,EAAEA,OAAO,YAAYyL,iBAArB,CAHC,EAGwC;AACzCM,QAAAA,QAAQ,CAACrgB,KAAT,CAAesU,OAAf;AACH;;AACD,UAAImG,SAAJ,EAAe;AACX2f,QAAAA,sBAAsB,CAACl8B,OAAvB,GAAiC,KAAjC;AACH;AACJ,KAjBQ,EAiBN,CAACoW,OAAD,EAAU+L,QAAV,EAAoByE,MAApB,EAA4BqV,IAA5B,EAAkC1f,SAAlC,EAA6CC,cAA7C,EAA6DS,KAA7D,CAjBM,CAAT;AAkBH,GA1BiC;AAH3B,CAAX;;AAgCA,SAASkf,SAAT,CAAmB5qB,MAAnB,EAA2BxR,IAA3B,EAAiC0qB,IAAjC,EAAuClF,CAAvC,EAA0C;AACtChU,EAAAA,MAAM,CAAC3L,GAAP,GAAa5J,GAAG,CAAC+D,IAAI,CAAC6F,GAAN,EAAW6kB,IAAI,CAAC7kB,GAAhB,EAAqB2f,CAArB,CAAhB;AACAhU,EAAAA,MAAM,CAAC1L,GAAP,GAAa7J,GAAG,CAAC+D,IAAI,CAAC8F,GAAN,EAAW4kB,IAAI,CAAC5kB,GAAhB,EAAqB0f,CAArB,CAAhB;AACH;;AAED,IAAI6W,cAAc,GAAG,IAArB;;AACA,IAAIC,OAAO;AAAG;AAAe,UAAU5lB,MAAV,EAAkB;AAC3C9a,EAAAA,SAAS,CAAC0gC,OAAD,EAAU5lB,MAAV,CAAT;;AACA,WAAS4lB,OAAT,GAAmB;AACf,QAAI78B,KAAK,GAAGiX,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACC,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AACAnX,IAAAA,KAAK,CAAC88B,WAAN,GAAoB;AAChB32B,MAAAA,CAAC,EAAE;AAAEC,QAAAA,GAAG,EAAE,CAAP;AAAUC,QAAAA,GAAG,EAAE;AAAf,OADa;AAEhBC,MAAAA,CAAC,EAAE;AAAEF,QAAAA,GAAG,EAAE,CAAP;AAAUC,QAAAA,GAAG,EAAE;AAAf;AAFa,KAApB;AAIArG,IAAAA,KAAK,CAAC+8B,iBAAN,GAA0B;AACtB52B,MAAAA,CAAC,EAAEpB,SADmB;AAEtBuB,MAAAA,CAAC,EAAEvB;AAFmB,KAA1B;;AAIA/E,IAAAA,KAAK,CAAC4W,OAAN,GAAgB,UAAU7E,MAAV,EAAkB9K,MAAlB,EAA0BpG,EAA1B,EAA8B;AAC1C,UAAIA,EAAE,KAAK,KAAK,CAAhB,EAAmB;AAAEA,QAAAA,EAAE,GAAG,EAAL;AAAU;;AAC/B,UAAIwP,SAAS,GAAGxP,EAAE,CAACwP,SAAnB;AAAA,UAA8Bb,SAAS,GAAG3O,EAAE,CAAC2O,SAA7C;AAAA,UAAwDwtB,gBAAgB,GAAGn8B,EAAE,CAACm8B,gBAA9E;AAAA,UAAgGx5B,MAAM,GAAGtH,MAAM,CAAC2E,EAAD,EAAK,CAAC,WAAD,EAAc,WAAd,EAA2B,kBAA3B,CAAL,CAA/G;;AACA,UAAIsV,EAAE,GAAGnW,KAAK,CAACyd,KAAf;AAAA,UAAsBE,aAAa,GAAGxH,EAAE,CAACwH,aAAzC;AAAA,UAAwDsf,MAAM,GAAG9mB,EAAE,CAAC8mB,MAApE;AACA;;;;;AAIAh2B,MAAAA,MAAM,GAAGoJ,SAAS,IAAIpJ,MAAtB;AACA8K,MAAAA,MAAM,GAAGvC,SAAS,IAAIuC,MAAtB;AACA,UAAImrB,WAAW,GAAGC,QAAQ,CAACl2B,MAAD,EAAS8K,MAAT,CAA1B;AACA,UAAI6W,UAAU,GAAG/V,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AACtC;;;;AAIA,YAAImvB,MAAM,KAAK,UAAf,EAA2B;AACvB,cAAI1qB,YAAY,GAAGR,MAAM,CAACjE,IAAD,CAAN,CAAazH,GAAb,GAAmB0L,MAAM,CAACjE,IAAD,CAAN,CAAa1H,GAAnD;AACAa,UAAAA,MAAM,CAAC6G,IAAD,CAAN,CAAazH,GAAb,GAAmBY,MAAM,CAAC6G,IAAD,CAAN,CAAa1H,GAAb,GAAmBmM,YAAtC;AACH;;AACD,YAAIoL,aAAa,CAACjG,iBAAlB,EAAqC;AACjC;AACH,SAFD,MAGK,IAAIslB,gBAAgB,KAAKj4B,SAAzB,EAAoC;AACrC;AACAi4B,UAAAA,gBAAgB,KAAK9O,gBAAgB,CAACkP,IAAtC,GACMzf,aAAa,CAACtF,IAAd,EADN,GAEMsF,aAAa,CAACpF,IAAd,EAFN;AAGH,SALI,MAMA,IAAI2kB,WAAJ,EAAiB;AAClB;AACA;AACA,iBAAOl9B,KAAK,CAACq9B,WAAN,CAAkBvvB,IAAlB,EAAwBiE,MAAM,CAACjE,IAAD,CAA9B,EAAsC7G,MAAM,CAAC6G,IAAD,CAA5C,EAAoDtK,MAApD,CAAP;AACH,SAJI,MAKA;AACD;AACA;AACA,iBAAOma,aAAa,CAACpE,aAAd,CAA4BzL,IAA5B,EAAkCiE,MAAM,CAACjE,IAAD,CAAN,CAAa1H,GAA/C,EAAoD2L,MAAM,CAACjE,IAAD,CAAN,CAAazH,GAAjE,CAAP;AACH;AACJ,OA5BwB,CAAzB,CAX0C,CAwC1C;;AACAsX,MAAAA,aAAa,CAACrd,MAAd;AACA;;;;;;AAKA,aAAOmC,OAAO,CAACugB,GAAR,CAAY4F,UAAZ,EAAwBhmB,IAAxB,CAA6B,YAAY;AAC5C,YAAI/B,EAAJ,EAAQsV,EAAR;;AACA,SAACtV,EAAE,GAAG2C,MAAM,CAAC85B,yBAAb,MAA4C,IAA5C,IAAoDz8B,EAAE,KAAK,KAAK,CAAhE,GAAoE,KAAK,CAAzE,GAA6EA,EAAE,CAACiX,IAAH,CAAQtU,MAAR,CAA7E;;AACA,YAAIma,aAAa,CAACZ,SAAlB,EAA6B;AACzBY,UAAAA,aAAa,CAAC6Q,QAAd,GAAyBP,QAAQ,CAACQ,OAAlC;AACH,SAFD,MAGK;AACD,WAACtY,EAAE,GAAG3S,MAAM,CAAC85B,yBAAb,MAA4C,IAA5C,IAAoDnnB,EAAE,KAAK,KAAK,CAAhE,GAAoE,KAAK,CAAzE,GAA6EA,EAAE,CAAC2B,IAAH,CAAQtU,MAAR,CAA7E;;AACAxD,UAAAA,KAAK,CAACod,YAAN;AACH;AACJ,OAVM,CAAP;AAWH,KA1DD;;AA2DA,WAAOpd,KAAP;AACH;;AACD68B,EAAAA,OAAO,CAACx7B,SAAR,CAAkBk8B,iBAAlB,GAAsC,YAAY;AAC9C,QAAI5f,aAAa,GAAG,KAAKF,KAAL,CAAWE,aAA/B;AACAA,IAAAA,aAAa,CAACvF,sBAAd;AACA,SAAKolB,gBAAL,GAAwB7f,aAAa,CAACnF,cAAd,CAA6B,KAAK5B,OAAlC,CAAxB;AACH,GAJD;;AAKAimB,EAAAA,OAAO,CAACx7B,SAAR,CAAkBo8B,oBAAlB,GAAyC,YAAY;AACjD,QAAIz9B,KAAK,GAAG,IAAZ;;AACA,SAAKw9B,gBAAL;AACA3qB,IAAAA,QAAQ,CAAC,UAAU/E,IAAV,EAAgB;AAAE,UAAIjN,EAAJ,EAAQsV,EAAR;;AAAY,aAAO,CAACA,EAAE,GAAG,CAACtV,EAAE,GAAGb,KAAK,CAAC+8B,iBAAZ,EAA+BjvB,IAA/B,CAAN,MAAgD,IAAhD,IAAwDqI,EAAE,KAAK,KAAK,CAApE,GAAwE,KAAK,CAA7E,GAAiFA,EAAE,CAAC2B,IAAH,CAAQjX,EAAR,CAAxF;AAAsG,KAArI,CAAR;AACH,GAJD;AAKA;;;;;;;AAKAg8B,EAAAA,OAAO,CAACx7B,SAAR,CAAkBg8B,WAAlB,GAAgC,UAAUvvB,IAAV,EAAgBiE,MAAhB,EAAwB9K,MAAxB,EAAgCpG,EAAhC,EAAoC;AAChE,QAAIsV,EAAJ,EAAQoF,EAAR;;AACA,QAAIoL,EAAE,GAAG9lB,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9B;AAAA,QAAkC4U,UAAU,GAAGkR,EAAE,CAAClR,UAAlD;AAAA,QAA8DioB,gBAAgB,GAAG/W,EAAE,CAAC+W,gBAApF;;AACA,KAACniB,EAAE,GAAG,CAACpF,EAAE,GAAG,KAAK4mB,iBAAX,EAA8BjvB,IAA9B,CAAN,MAA+C,IAA/C,IAAuDyN,EAAE,KAAK,KAAK,CAAnE,GAAuE,KAAK,CAA5E,GAAgFA,EAAE,CAACzD,IAAH,CAAQ3B,EAAR,CAAhF;AACA,QAAIwH,aAAa,GAAG,KAAKF,KAAL,CAAWE,aAA/B;AACA,QAAImf,WAAW,GAAG,KAAKA,WAAL,CAAiBhvB,IAAjB,CAAlB;AACA,QAAI6vB,cAAc,GAAGhgB,aAAa,CAAChG,YAAd,CAA2B7J,IAA3B,CAArB;AACA;;;;;AAIA6vB,IAAAA,cAAc,CAAC77B,cAAf;AACA67B,IAAAA,cAAc,CAACv8B,GAAf,CAAmB,CAAnB;AACAu8B,IAAAA,cAAc,CAACv8B,GAAf,CAAmB,CAAnB;AACA;;;;;AAIA,QAAIw8B,SAAS,GAAGF,gBAAgB,IAAI,KAAKG,wBAAL,CAA8BH,gBAA9B,CAApC;AACA;;;;;AAIA,QAAII,KAAK,GAAG,YAAY;AACpB;AACA,UAAI/X,CAAC,GAAG4X,cAAc,CAACx7B,GAAf,KAAuBy6B,cAA/B,CAFoB,CAGpB;;AACAD,MAAAA,SAAS,CAACG,WAAD,EAAc71B,MAAd,EAAsB8K,MAAtB,EAA8BgU,CAA9B,CAAT;AACApI,MAAAA,aAAa,CAACpE,aAAd,CAA4BzL,IAA5B,EAAkCgvB,WAAW,CAAC12B,GAA9C,EAAmD02B,WAAW,CAACz2B,GAA/D,EALoB,CAMpB;;AACAu3B,MAAAA,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAAC7X,CAAD,CAA/D;AACH,KARD,CAvBgE,CAgChE;;;AACA+X,IAAAA,KAAK,GAjC2D,CAkChE;;AACA,QAAIv7B,SAAS,GAAG+T,cAAc,CAACxI,IAAI,KAAK,GAAT,GAAe,SAAf,GAA2B,SAA5B,EAAuC6vB,cAAvC,EAAuDf,cAAvD,EAAuEnnB,UAAU,IAAI,KAAKgI,KAAL,CAAWhI,UAAzB,IAAuCoN,iBAA9G,CAA9B,CAnCgE,CAoChE;;AACA,QAAIkb,mBAAmB,GAAGJ,cAAc,CAAC/7B,QAAf,CAAwBk8B,KAAxB,CAA1B;;AACA,SAAKf,iBAAL,CAAuBjvB,IAAvB,IAA+B,YAAY;AACvC6vB,MAAAA,cAAc,CAACn7B,IAAf;AACAu7B,MAAAA,mBAAmB;AACtB,KAHD;;AAIA,WAAOx7B,SAAP;AACH,GA3CD;;AA4CAs6B,EAAAA,OAAO,CAACx7B,SAAR,CAAkBw8B,wBAAlB,GAA6C,UAAUH,gBAAV,EAA4B;AACrE,QAAI/f,aAAa,GAAG,KAAKF,KAAL,CAAWE,aAA/B;AACA,QAAI9S,OAAO,GAAG8S,aAAa,CAAC9Y,QAAd,CAAuB,SAAvB,EAAkC,CAAlC,CAAd;AACA,WAAO,UAAUkhB,CAAV,EAAa;AAChBlb,MAAAA,OAAO,CAACzJ,GAAR,CAAY48B,eAAe,CAACxhC,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAOupB,CAAP,CAAJ,CAA3B;AACA2X,MAAAA,gBAAgB,CAACt8B,GAAjB,CAAqB68B,gBAAgB,CAACzhC,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAOupB,CAAP,CAAJ,CAArC;AACH,KAHD;AAIH,GAPD;;AAQA8W,EAAAA,OAAO,CAACx7B,SAAR,CAAkB+b,YAAlB,GAAiC,YAAY;AACzC,QAAIvc,EAAJ,EAAQsV,EAAR;;AACA,KAACA,EAAE,GAAG,CAACtV,EAAE,GAAG,KAAK4c,KAAX,EAAkBL,YAAxB,MAA0C,IAA1C,IAAkDjH,EAAE,KAAK,KAAK,CAA9D,GAAkE,KAAK,CAAvE,GAA2EA,EAAE,CAAC2B,IAAH,CAAQjX,EAAR,CAA3E;AACH,GAHD;;AAIAg8B,EAAAA,OAAO,CAACx7B,SAAR,CAAkBf,MAAlB,GAA2B,YAAY;AACnC,WAAO,IAAP;AACH,GAFD;;AAGA,SAAOu8B,OAAP;AACH,CApJ4B,CAoJ3B79B,SApJ2B,CAA7B;;AAqJA,IAAIk/B,aAAa,GAAG;AAChB35B,EAAAA,GAAG,EAAE,gBADW;AAEhBwpB,EAAAA,YAAY,EAAE,UAAUtQ,KAAV,EAAiB;AAAE,WAAO,CAAC,CAACA,KAAK,CAACwf,MAAR,IAAkB,CAAC,CAACxf,KAAK,CAACI,QAAjC;AAA4C,GAF7D;AAGhB7e,EAAAA,SAAS,EAAE,UAAUye,KAAV,EAAiB;AACxB,QAAI5c,EAAE,GAAGgc,WAAW,EAApB;AAAA,QAAwBO,YAAY,GAAGvc,EAAE,CAAC,CAAD,CAAzC;;AACA,WAAOjC,aAAa,CAACi+B,OAAD,EAAU7gC,QAAQ,CAAC,EAAD,EAAKyhB,KAAL,EAAY;AAAEL,MAAAA,YAAY,EAAEA;AAAhB,KAAZ,CAAlB,CAApB;AACH;AANe,CAApB;;AAQA,SAAS+f,QAAT,CAAkB9wB,CAAlB,EAAqBC,CAArB,EAAwB;AACpB,SAAO6xB,YAAY,CAAC9xB,CAAC,CAAClG,CAAH,EAAMmG,CAAC,CAACnG,CAAR,CAAZ,IAA0Bg4B,YAAY,CAAC9xB,CAAC,CAAC/F,CAAH,EAAMgG,CAAC,CAAChG,CAAR,CAA7C;AACH;;AACD,SAAS63B,YAAT,CAAsB9xB,CAAtB,EAAyBC,CAAzB,EAA4B;AACxB,SAAOD,CAAC,CAACjG,GAAF,KAAUkG,CAAC,CAAClG,GAAZ,IAAmBiG,CAAC,CAAChG,GAAF,KAAUiG,CAAC,CAACjG,GAAtC;AACH;;AACD,IAAIwc,iBAAiB,GAAG;AACpBlP,EAAAA,QAAQ,EAAE,IADU;AAEpBD,EAAAA,IAAI,EAAE,CAAC,GAAD,EAAM,CAAN,EAAS,GAAT,EAAc,CAAd;AAFc,CAAxB;;AAIA,SAAS0qB,QAAT,CAAkBh4B,GAAlB,EAAuBC,GAAvB,EAA4Bg4B,MAA5B,EAAoC;AAChC,SAAO,UAAUtY,CAAV,EAAa;AAChB;AACA,QAAIA,CAAC,GAAG3f,GAAR,EACI,OAAO,CAAP;AACJ,QAAI2f,CAAC,GAAG1f,GAAR,EACI,OAAO,CAAP;AACJ,WAAOg4B,MAAM,CAAC1hC,QAAQ,CAACyJ,GAAD,EAAMC,GAAN,EAAW0f,CAAX,CAAT,CAAb;AACH,GAPD;AAQH;;AACD,IAAIiY,eAAe,GAAGI,QAAQ,CAAC,CAAD,EAAI,GAAJ,EAASthC,OAAT,CAA9B;AACA,IAAImhC,gBAAgB,GAAGG,QAAQ,CAAC,GAAD,EAAM,IAAN,EAAYvhC,QAAZ,CAA/B;AAEA;;;;AAGA,IAAIyhC,OAAO;AAAG;AAAe,UAAUrnB,MAAV,EAAkB;AAC3C9a,EAAAA,SAAS,CAACmiC,OAAD,EAAUrnB,MAAV,CAAT;;AACA,WAASqnB,OAAT,CAAiB7gB,KAAjB,EAAwB;AACpB,QAAIzd,KAAK,GAAGiX,MAAM,CAACa,IAAP,CAAY,IAAZ,EAAkB2F,KAAlB,KAA4B,IAAxC;AACA;;;;;;AAIA,QAAIsR,UAAU,GAAGtR,KAAK,CAACsR,UAAvB;;AACA,QAAI,CAACL,cAAc,CAACK,UAAD,CAAnB,EAAiC;AAC7B/uB,MAAAA,KAAK,CAACu+B,kBAAN,GAA2B,YAAY;AAAE,eAAOxP,UAAU,CAACR,KAAX,EAAP;AAA4B,OAArE;AACH;;AACD,WAAOvuB,KAAP;AACH;AACD;;;;;AAGAs+B,EAAAA,OAAO,CAACj9B,SAAR,CAAkBk8B,iBAAlB,GAAsC,YAAY;AAC9C,QAAI18B,EAAE,GAAG,KAAK4c,KAAd;AAAA,QAAqBsR,UAAU,GAAGluB,EAAE,CAACkuB,UAArC;AAAA,QAAiDpR,aAAa,GAAG9c,EAAE,CAAC8c,aAApE;AACA+Q,IAAAA,cAAc,CAACK,UAAD,CAAd,IAA8BA,UAAU,CAAC9R,QAAX,CAAoBU,aAApB,CAA9B;AACH,GAHD;AAIA;;;;;;;;AAMA2gB,EAAAA,OAAO,CAACj9B,SAAR,CAAkBm9B,uBAAlB,GAA4C,YAAY;AACpD,QAAI39B,EAAE,GAAG,KAAK4c,KAAd;AAAA,QAAqBsR,UAAU,GAAGluB,EAAE,CAACkuB,UAArC;AAAA,QAAiDpR,aAAa,GAAG9c,EAAE,CAAC8c,aAApE;;AACA,QAAI+Q,cAAc,CAACK,UAAD,CAAlB,EAAgC;AAC5BA,MAAAA,UAAU,CAAC0P,UAAX;AACH,KAFD,MAGK;AACD9gB,MAAAA,aAAa,CAAC5E,mBAAd;AACAgW,MAAAA,UAAU,CAACrtB,GAAX,CAAeic,aAAf;AACH;;AACD,WAAO,IAAP;AACH,GAVD;;AAWA2gB,EAAAA,OAAO,CAACj9B,SAAR,CAAkBk9B,kBAAlB,GAAuC,YAAY,CAAG,CAAtD;;AACAD,EAAAA,OAAO,CAACj9B,SAAR,CAAkBf,MAAlB,GAA2B,YAAY;AACnC,WAAO,IAAP;AACH,GAFD;;AAGA,SAAOg+B,OAAP;AACH,CA3C4B,CA2C3B//B,cAAc,CAACS,SA3CY,CAA7B;;AA4CA,IAAI0/B,aAAa,GAAG;AAChBn6B,EAAAA,GAAG,EAAE,gBADW;AAEhBwpB,EAAAA,YAAY,EAAE,UAAUtQ,KAAV,EAAiB;AAC3B,WAAO,CAAC,CAACA,KAAK,CAACa,IAAR,IAAgB,CAAC,CAACb,KAAK,CAACwf,MAAxB,IAAkC,CAAC,CAACxf,KAAK,CAACI,QAAjD;AACH,GAJe;AAKhB7e,EAAAA,SAAS,EAAE,UAAUye,KAAV,EAAiB;AACxB,QAAIsR,UAAU,GAAGrwB,UAAU,CAACkwB,mBAAD,CAA3B;AACA,WAAOrwB,cAAc,CAACK,aAAf,CAA6B0/B,OAA7B,EAAsCtiC,QAAQ,CAAC,EAAD,EAAKyhB,KAAL,EAAY;AAAEsR,MAAAA,UAAU,EAAEA;AAAd,KAAZ,CAA9C,CAAP;AACH;AARe,CAApB;AAWA;;;;;;;;;;;;;;;AAcA,SAAS4P,iBAAT,CAA2BlR,eAA3B,EAA4C;AACxC,MAAIjqB,MAAM,GAAG;AACTiqB,IAAAA,eAAe,EAAEA,eADR;AAETyB,IAAAA,gBAAgB,EAAE1R,mBAFT;AAGTld,IAAAA,MAAM,EAAEA,MAHC;AAIT6uB,IAAAA,uBAAuB,EAAE;AACrBjJ,MAAAA,oBAAoB,EAAEjE;AADD;AAJhB,GAAb;;AAQA,WAASmF,MAAT,CAAgBpoB,SAAhB,EAA2B;AACvB,WAAOiwB,qBAAqB,CAACjwB,SAAD,EAAYwE,MAAZ,CAA5B;AACH;;AACD,MAAIo7B,cAAc,GAAG,IAAIt7B,GAAJ,EAArB;;AACA,WAASnB,GAAT,CAAa4P,MAAb,EAAqBxN,GAArB,EAA0B;AACtB,QAAIA,GAAG,KAAK,QAAZ,EACI,OAAOwN,MAAM,CAACqV,MAAd;;AACJ,QAAI,CAACwX,cAAc,CAACp6B,GAAf,CAAmBD,GAAnB,CAAL,EAA8B;AAC1Bq6B,MAAAA,cAAc,CAACx9B,GAAf,CAAmBmD,GAAnB,EAAwB0qB,qBAAqB,CAAC1qB,GAAD,EAAMf,MAAN,CAA7C;AACH;;AACD,WAAOo7B,cAAc,CAACz8B,GAAf,CAAmBoC,GAAnB,CAAP;AACH;;AACD,SAAO,IAAIs6B,KAAJ,CAAU;AAAEzX,IAAAA,MAAM,EAAEA;AAAV,GAAV,EAA8B;AAAEjlB,IAAAA,GAAG,EAAEA;AAAP,GAA9B,CAAP;AACH;AACD;;;;;;;;AAMA,IAAIojB,MAAM,GAAG,aAAcoZ,iBAAiB,CAAC,CACzCD,aADyC,EAEzClE,IAFyC,EAGzC+B,QAHyC,EAIzCC,IAJyC,EAKzC0B,aALyC,CAAD,CAA5C;AAOA;;;;AAGA,IAAIY,CAAC,GAAG,aAAcH,iBAAiB,CAAC,EAAD,CAAvC;;AAEA,SAASI,cAAT,GAA0B;AACtB,MAAIl+B,EAAE,GAAG3B,QAAQ,CAAC,CAAD,CAAjB;AAAA,MAAsB8/B,iBAAiB,GAAGn+B,EAAE,CAAC,CAAD,CAA5C;AAAA,MAAiDo+B,oBAAoB,GAAGp+B,EAAE,CAAC,CAAD,CAA1E;;AACA,SAAO5B,WAAW,CAAC,YAAY;AAAE,WAAOggC,oBAAoB,CAACD,iBAAiB,GAAG,CAArB,CAA3B;AAAqD,GAApE,EAAsE,CACpFA,iBADoF,CAAtE,CAAlB;AAGH;;AAED,IAAIpb,UAAU,GAAG,CAAjB;;AACA,SAASsb,aAAT,GAAyB;AACrB,MAAIhiB,EAAE,GAAG0G,UAAT;AACAA,EAAAA,UAAU;AACV,SAAO1G,EAAP;AACH;;AACD,IAAIiiB,aAAa,GAAG,UAAUt+B,EAAV,EAAc;AAC9B,MAAIsC,QAAQ,GAAGtC,EAAE,CAACsC,QAAlB;AAAA,MAA4BqgB,OAAO,GAAG3iB,EAAE,CAAC2iB,OAAzC;AAAA,MAAkDzG,SAAS,GAAGlc,EAAE,CAACkc,SAAjE;AAAA,MAA4EC,cAAc,GAAGnc,EAAE,CAACmc,cAAhG;AAAA,MAAgHoK,MAAM,GAAGvmB,EAAE,CAACumB,MAA5H;AACA,MAAIgY,gBAAgB,GAAGplB,WAAW,CAACqlB,cAAD,CAAlC;AACA,MAAIviB,OAAO,GAAG;AACVI,IAAAA,EAAE,EAAElD,WAAW,CAACklB,aAAD,CADL;AAEV1b,IAAAA,OAAO,EAAEA,OAFC;AAGVzG,IAAAA,SAAS,EAAEA,SAHD;AAIVqK,IAAAA,MAAM,EAAEA,MAJE;AAKVpK,IAAAA,cAAc,EAAE,UAAUsiB,OAAV,EAAmB;AAC/BF,MAAAA,gBAAgB,CAACh+B,GAAjB,CAAqBk+B,OAArB,EAA8B,IAA9B;AACA,UAAIC,WAAW,GAAG,IAAlB;AACAH,MAAAA,gBAAgB,CAAC1+B,OAAjB,CAAyB,UAAU8+B,UAAV,EAAsB;AAC3C,YAAI,CAACA,UAAL,EACID,WAAW,GAAG,KAAd;AACP,OAHD;AAIAA,MAAAA,WAAW,KAAKviB,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,EAAnF,CAAX;AACH,KAbS;AAcVC,IAAAA,QAAQ,EAAE,UAAUqiB,OAAV,EAAmB;AACzBF,MAAAA,gBAAgB,CAACh+B,GAAjB,CAAqBk+B,OAArB,EAA8B,KAA9B;AACA,aAAO,YAAY;AAAE,eAAOF,gBAAgB,CAACz9B,MAAjB,CAAwB29B,OAAxB,CAAP;AAA0C,OAA/D;AACH;AAjBS,GAAd;AAmBAzgC,EAAAA,OAAO,CAAC,YAAY;AAChBugC,IAAAA,gBAAgB,CAAC1+B,OAAjB,CAAyB,UAAUiF,CAAV,EAAapB,GAAb,EAAkB;AAAE,aAAO66B,gBAAgB,CAACh+B,GAAjB,CAAqBmD,GAArB,EAA0B,KAA1B,CAAP;AAA0C,KAAvF;AACH,GAFM,EAEJ,CAACwY,SAAD,CAFI,CAAP;AAGA,SAAQne,aAAa,CAACge,eAAe,CAACgO,QAAjB,EAA2B;AAAEjrB,IAAAA,KAAK,EAAEmd;AAAT,GAA3B,EAA+C3Z,QAA/C,CAArB;AACH,CA1BD;;AA2BA,SAASk8B,cAAT,GAA0B;AACtB,SAAO,IAAI/7B,GAAJ,EAAP;AACH;;AAED,SAASm8B,WAAT,CAAqBp7B,KAArB,EAA4B;AACxB,SAAOA,KAAK,CAACE,GAAN,IAAa,EAApB;AACH;;AACD,SAASm7B,iBAAT,CAA2Bv8B,QAA3B,EAAqCw8B,WAArC,EAAkD;AAC9C,MAAIC,YAAY,GAAGjxB,OAAO,CAACkxB,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC,IAAIj+B,GAAJ,EAAxC,GAAoD,IAAvE;AACAsB,EAAAA,QAAQ,CAACzC,OAAT,CAAiB,UAAU2D,KAAV,EAAiB;AAC9B,QAAIE,GAAG,GAAGk7B,WAAW,CAACp7B,KAAD,CAArB;;AACA,QAAIsK,OAAO,CAACkxB,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyCF,YAA7C,EAA2D;AACvD,UAAIA,YAAY,CAACp7B,GAAb,CAAiBD,GAAjB,CAAJ,EAA2B;AACvBw7B,QAAAA,OAAO,CAACC,IAAR,CAAa,wDAAwDz7B,GAAxD,GAA8D,oBAA3E;AACH;;AACDq7B,MAAAA,YAAY,CAACl+B,GAAb,CAAiB6C,GAAjB;AACH;;AACDo7B,IAAAA,WAAW,CAACv+B,GAAZ,CAAgBmD,GAAhB,EAAqBF,KAArB;AACH,GATD;AAUH;;AACD,SAAS47B,YAAT,CAAsB98B,QAAtB,EAAgC;AAC5B,MAAI+8B,QAAQ,GAAG,EAAf,CAD4B,CAE5B;;AACA9gC,EAAAA,QAAQ,CAACsB,OAAT,CAAiByC,QAAjB,EAA2B,UAAUkB,KAAV,EAAiB;AACxC,QAAIhF,cAAc,CAACgF,KAAD,CAAlB,EACI67B,QAAQ,CAAC/zB,IAAT,CAAc9H,KAAd;AACP,GAHD;AAIA,SAAO67B,QAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA,IAAIC,eAAe,GAAG,UAAUt/B,EAAV,EAAc;AAChC,MAAIsC,QAAQ,GAAGtC,EAAE,CAACsC,QAAlB;AAAA,MAA4BikB,MAAM,GAAGvmB,EAAE,CAACumB,MAAxC;AAAA,MAAgDjR,EAAE,GAAGtV,EAAE,CAAC2iB,OAAxD;AAAA,MAAiEA,OAAO,GAAGrN,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAAlG;AAAA,MAAsG6G,cAAc,GAAGnc,EAAE,CAACmc,cAA1H;AAAA,MAA0IojB,eAAe,GAAGv/B,EAAE,CAACu/B,eAA/J,CADgC,CAEhC;AACA;;AACA,MAAIC,WAAW,GAAGtB,cAAc,EAAhC;AACA,MAAIuB,aAAa,GAAG5hC,UAAU,CAACkwB,mBAAD,CAA9B;;AACA,MAAIF,cAAc,CAAC4R,aAAD,CAAlB,EAAmC;AAC/BD,IAAAA,WAAW,GAAGC,aAAa,CAAC3R,WAA5B;AACH;;AACD,MAAIvM,eAAe,GAAG5jB,MAAM,CAAC,IAAD,CAA5B,CATgC,CAUhC;;AACA,MAAI+hC,gBAAgB,GAAGN,YAAY,CAAC98B,QAAD,CAAnC,CAXgC,CAYhC;AACA;;AACA,MAAIq9B,eAAe,GAAGhiC,MAAM,CAAC+hC,gBAAD,CAA5B,CAdgC,CAehC;;AACA,MAAIZ,WAAW,GAAGnhC,MAAM,CAAC,IAAI8E,GAAJ,EAAD,CAAN,CACb9C,OADL,CAhBgC,CAkBhC;;AACA,MAAIigC,OAAO,GAAGjiC,MAAM,CAAC,IAAIqD,GAAJ,EAAD,CAAN,CAAkBrB,OAAhC;AACAk/B,EAAAA,iBAAiB,CAACa,gBAAD,EAAmBZ,WAAnB,CAAjB,CApBgC,CAqBhC;AACA;;AACA,MAAIvd,eAAe,CAAC5hB,OAApB,EAA6B;AACzB4hB,IAAAA,eAAe,CAAC5hB,OAAhB,GAA0B,KAA1B;AACA,WAAQ5B,aAAa,CAACG,QAAD,EAAW,IAAX,EAAiBwhC,gBAAgB,CAACprB,GAAjB,CAAqB,UAAU9Q,KAAV,EAAiB;AAAE,aAAQzF,aAAa,CAACugC,aAAD,EAAgB;AAAE56B,QAAAA,GAAG,EAAEk7B,WAAW,CAACp7B,KAAD,CAAlB;AAA2B0Y,QAAAA,SAAS,EAAE,IAAtC;AAA4CyG,QAAAA,OAAO,EAAEA,OAAO,GAAGze,SAAH,GAAe;AAA3E,OAAhB,EAAoGV,KAApG,CAArB;AAAmI,KAA3K,CAAjB,CAArB;AACH,GA1B+B,CA2BhC;;;AACA,MAAIq8B,gBAAgB,GAAGzkC,cAAc,CAACskC,gBAAD,CAArC,CA5BgC,CA6BhC;AACA;;;AACA,MAAII,WAAW,GAAGH,eAAe,CAAChgC,OAAhB,CAAwB2U,GAAxB,CAA4BsqB,WAA5B,CAAlB;AACA,MAAImB,UAAU,GAAGL,gBAAgB,CAACprB,GAAjB,CAAqBsqB,WAArB,CAAjB,CAhCgC,CAiChC;;AACA,MAAIoB,UAAU,GAAGF,WAAW,CAACpzB,MAA7B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqzB,UAApB,EAAgCrzB,CAAC,EAAjC,EAAqC;AACjC,QAAIjJ,GAAG,GAAGo8B,WAAW,CAACnzB,CAAD,CAArB;;AACA,QAAIozB,UAAU,CAACr0B,OAAX,CAAmBhI,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;AAChCk8B,MAAAA,OAAO,CAAC/+B,GAAR,CAAY6C,GAAZ;AACH,KAFD,MAGK;AACD;AACAk8B,MAAAA,OAAO,CAAC9+B,MAAR,CAAe4C,GAAf;AACH;AACJ,GA5C+B,CA6ChC;AACA;;;AACA,MAAI67B,eAAe,IAAIK,OAAO,CAACt3B,IAA/B,EAAqC;AACjCu3B,IAAAA,gBAAgB,GAAG,EAAnB;AACH,GAjD+B,CAkDhC;AACA;;;AACAD,EAAAA,OAAO,CAAC//B,OAAR,CAAgB,UAAU6D,GAAV,EAAe;AAC3B;AACA,QAAIq8B,UAAU,CAACr0B,OAAX,CAAmBhI,GAAnB,MAA4B,CAAC,CAAjC,EACI;AACJ,QAAIF,KAAK,GAAGs7B,WAAW,CAACx9B,GAAZ,CAAgBoC,GAAhB,CAAZ;AACA,QAAI,CAACF,KAAL,EACI;AACJ,QAAIy8B,cAAc,GAAGH,WAAW,CAACp0B,OAAZ,CAAoBhI,GAApB,CAArB;;AACA,QAAIw8B,MAAM,GAAG,YAAY;AACrBpB,MAAAA,WAAW,CAACh+B,MAAZ,CAAmB4C,GAAnB;AACAk8B,MAAAA,OAAO,CAAC9+B,MAAR,CAAe4C,GAAf,EAFqB,CAGrB;;AACA,UAAIy8B,WAAW,GAAGR,eAAe,CAAChgC,OAAhB,CAAwBygC,SAAxB,CAAkC,UAAUC,YAAV,EAAwB;AAAE,eAAOA,YAAY,CAAC38B,GAAb,KAAqBA,GAA5B;AAAkC,OAA9F,CAAlB;AACAi8B,MAAAA,eAAe,CAAChgC,OAAhB,CAAwB2gC,MAAxB,CAA+BH,WAA/B,EAA4C,CAA5C,EALqB,CAMrB;;AACA,UAAI,CAACP,OAAO,CAACt3B,IAAb,EAAmB;AACfq3B,QAAAA,eAAe,CAAChgC,OAAhB,GAA0B+/B,gBAA1B;AACAF,QAAAA,WAAW;AACXrjB,QAAAA,cAAc,IAAIA,cAAc,EAAhC;AACH;AACJ,KAZD;;AAaA0jB,IAAAA,gBAAgB,CAACS,MAAjB,CAAwBL,cAAxB,EAAwC,CAAxC,EAA2CliC,aAAa,CAACugC,aAAD,EAAgB;AAAE56B,MAAAA,GAAG,EAAEk7B,WAAW,CAACp7B,KAAD,CAAlB;AAA2B0Y,MAAAA,SAAS,EAAE,KAAtC;AAA6CC,MAAAA,cAAc,EAAE+jB,MAA7D;AAAqE3Z,MAAAA,MAAM,EAAEA;AAA7E,KAAhB,EAAuG/iB,KAAvG,CAAxD;AACH,GAtBD,EApDgC,CA2EhC;AACA;;AACAq8B,EAAAA,gBAAgB,GAAGA,gBAAgB,CAACvrB,GAAjB,CAAqB,UAAU9Q,KAAV,EAAiB;AACrD,QAAIE,GAAG,GAAGF,KAAK,CAACE,GAAhB;AACA,WAAOk8B,OAAO,CAACj8B,GAAR,CAAYD,GAAZ,IAAoBF,KAApB,GAA8BzF,aAAa,CAACugC,aAAD,EAAgB;AAAE56B,MAAAA,GAAG,EAAEk7B,WAAW,CAACp7B,KAAD,CAAlB;AAA2B0Y,MAAAA,SAAS,EAAE;AAAtC,KAAhB,EAA8D1Y,KAA9D,CAAlD;AACH,GAHkB,CAAnB;AAIAm8B,EAAAA,eAAe,CAAChgC,OAAhB,GAA0BkgC,gBAA1B;;AACA,MAAI/xB,OAAO,CAACkxB,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IACAM,eADA,IAEAM,gBAAgB,CAACnzB,MAAjB,GAA0B,CAF9B,EAEiC;AAC7BwyB,IAAAA,OAAO,CAACC,IAAR,CAAa,6JAAb;AACH;;AACD,SAAQphC,aAAa,CAACG,QAAD,EAAW,IAAX,EAAiB0hC,OAAO,CAACt3B,IAAR,GAChCu3B,gBADgC,GAEhCA,gBAAgB,CAACvrB,GAAjB,CAAqB,UAAU9Q,KAAV,EAAiB;AAAE,WAAOlF,YAAY,CAACkF,KAAD,CAAnB;AAA6B,GAArE,CAFe,CAArB;AAGH,CA1FD;;AA4FA,SAAS+8B,qBAAT,CAA+B/8B,KAA/B,EAAsCg9B,KAAtC,EAA6C;AACzC,MAAIA,KAAK,IAAIh9B,KAAK,KAAKg9B,KAAK,CAACC,IAA7B,EAAmC;AAC/B,WAAO;AAAEtE,MAAAA,gBAAgB,EAAE9O,gBAAgB,CAACkP;AAArC,KAAP;AACH,GAFD,MAGK,IAAIiE,KAAK,IACVh9B,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAACsT,QADvB,IAELl9B,KAAK,KAAKg9B,KAAK,CAACC,IAFX,IAGLD,KAAK,CAACC,IAAN,KAAeD,KAAK,CAACG,QAHpB,EAG8B;AAC/B,WAAO;AAAExE,MAAAA,gBAAgB,EAAE9O,gBAAgB,CAACuT;AAArC,KAAP;AACH;;AACD,MAAIpxB,SAAJ;AACA,MAAIb,SAAJ;;AACA,MAAInL,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAACsT,QAAhC,EAA0C;AACtClxB,IAAAA,SAAS,GAAGgxB,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACK,eAAN,EAA1D;AACH,GAFD,MAGK,IAAIr9B,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAAC0T,OAAhC,EAAyC;AAC1CnyB,IAAAA,SAAS,GAAG6xB,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACO,eAAN,EAA1D;AACH;;AACD,SAAO;AAAEvxB,IAAAA,SAAS,EAAEA,SAAb;AAAwBb,IAAAA,SAAS,EAAEA;AAAnC,GAAP;AACH;;AACD,SAASquB,wBAAT,CAAkCx5B,KAAlC,EAAyCg9B,KAAzC,EAAgD;AAC5C,MAAIxgC,EAAJ,EAAQsV,EAAR,EAAYoF,EAAZ;;AACA,MAAI/X,MAAM,GAAG,EAAb;AACA,MAAIq+B,SAAS,GAAGR,KAAK,IAAIA,KAAK,CAACC,IAA/B;AACA,MAAIQ,iBAAiB,GAAGD,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACrT,QAAxF;;AACA,MAAI6S,KAAK,IAAIh9B,KAAK,KAAKw9B,SAAvB,EAAkC;AAC9B,QAAIx9B,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAACsT,QAAhC,EAA0C;AACtC/9B,MAAAA,MAAM,CAAC6M,SAAP,GAAmBgxB,KAAK,CAACK,eAAN,EAAnB;AACH,KAFD,MAGK,IAAIr9B,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAAC0T,OAAhC,EAAyC;AAC1Cn+B,MAAAA,MAAM,CAACgM,SAAP,GAAmB6xB,KAAK,CAACO,eAAN,EAAnB;AACH;AACJ,GAPD,MAQK,IAAIP,KAAK,IAAIh9B,KAAK,KAAKg9B,KAAK,CAACU,MAA7B,EAAqC;AACtCv+B,IAAAA,MAAM,CAACiS,UAAP,GAAoB4rB,KAAK,CAACW,iBAAN,EAApB;;AACA,QAAIF,iBAAiB,KAAK7T,QAAQ,CAACsT,QAAnC,EAA6C;AACzC/9B,MAAAA,MAAM,CAACgM,SAAP,GAAmB6xB,KAAK,CAACY,aAAN,EAAnB;AACH,KAFD,MAGK,IAAIH,iBAAiB,KAAK7T,QAAQ,CAAC0T,OAAnC,EAA4C;AAC7Cn+B,MAAAA,MAAM,CAAC6M,SAAP,GAAmBgxB,KAAK,CAACa,aAAN,EAAnB;AACH;AACJ,GArB2C,CAsB5C;AACA;;;AACA,MAAI,EAAE,CAACrhC,EAAE,GAAGwgC,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACU,MAA1D,MAAsE,IAAtE,IAA8ElhC,EAAE,KAAK,KAAK,CAA1F,GAA8F,KAAK,CAAnG,GAAuGA,EAAE,CAACgjB,cAA5G,KAA+H,EAAEge,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAAChe,cAAlE,CAAnI,EAAsN;AAClN,WAAOrgB,MAAP;AACH;;AACD,MAAI,CAAC69B,KAAD,IAAUh9B,KAAK,KAAKw9B,SAAxB,EAAmC;AAC/B,QAAIx9B,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAACsT,QAAhC,EAA0C;AACtC/9B,MAAAA,MAAM,CAACk6B,gBAAP,GAA0B,CAACvnB,EAAE,GAAGkrB,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACU,MAA1D,MAAsE,IAAtE,IAA8E5rB,EAAE,KAAK,KAAK,CAA1F,GAA8F,KAAK,CAAnG,GAAuGA,EAAE,CAACtR,QAAH,CAAY,SAAZ,EAAuB,CAAvB,CAAjI;AACH;AACJ,GAJD,MAKK,IAAIw8B,KAAK,IAAIh9B,KAAK,KAAKg9B,KAAK,CAACU,MAA7B,EAAqC;AACtC,QAAI,CAACF,SAAD,IAAcC,iBAAiB,KAAK7T,QAAQ,CAACsT,QAAjD,EAA2D,CAA3D,KACK,IAAIO,iBAAiB,KAAK7T,QAAQ,CAAC0T,OAAnC,EAA4C;AAC7Cn+B,MAAAA,MAAM,CAACk6B,gBAAP,GAA0B,CAACniB,EAAE,GAAG8lB,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACC,IAA1D,MAAoE,IAApE,IAA4E/lB,EAAE,KAAK,KAAK,CAAxF,GAA4F,KAAK,CAAjG,GAAqGA,EAAE,CAAC1W,QAAH,CAAY,SAAZ,EAAuB,CAAvB,CAA/H;AACH;AACJ,GALI,MAMA;AACDrB,IAAAA,MAAM,CAACw5B,gBAAP,GAA0B9O,gBAAgB,CAACkP,IAA3C;AACH;;AACD,SAAO55B,MAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;AAiBA,SAAS2+B,iBAAT,CAA2Bd,KAA3B,EAAkCxgC,EAAlC,EAAsC;AAClC,MAAI2gC,QAAQ,GAAG3gC,EAAE,CAAC,CAAD,CAAjB;AAAA,MAAsBuhC,UAAU,GAAGvhC,EAAE,CAAC,CAAD,CAArC;AACA,MAAIygC,IAAI,GAAGv8B,SAAX;AACA,MAAIs9B,SAAS,GAAG,CAAhB;AACA,MAAIN,MAAM,GAAGh9B,SAAb,CAJkC,CAKlC;;AACA,MAAIu9B,UAAU,GAAGjB,KAAK,CAAC9zB,MAAvB;AACA,MAAIg1B,aAAa,GAAG,KAApB;;AACA,OAAK,IAAI/0B,CAAC,GAAG80B,UAAU,GAAG,CAA1B,EAA6B90B,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACtC,QAAInJ,KAAK,GAAGg9B,KAAK,CAAC7zB,CAAD,CAAjB;AACA,QAAIg1B,aAAa,GAAGh1B,CAAC,KAAK80B,UAAU,GAAG,CAAvC;AACA,QAAIE,aAAJ,EACID,aAAa,GAAGl+B,KAAK,CAAC0Y,SAAtB;;AACJ,QAAIwlB,aAAJ,EAAmB;AACfjB,MAAAA,IAAI,GAAGj9B,KAAP;AACH,KAFD,MAGK;AACD;AACA;AACA,UAAI9D,IAAI,GAAG8gC,KAAK,CAAC7zB,CAAC,GAAG,CAAL,CAAhB;AACA,UAAIjN,IAAI,IAAIA,IAAI,CAACwc,SAAjB,EACIukB,IAAI,GAAGj9B,KAAP;AACP;;AACD,QAAIi9B,IAAJ,EAAU;AACNe,MAAAA,SAAS,GAAG70B,CAAZ;AACA;AACH;AACJ;;AACD,MAAI,CAAC8zB,IAAL,EACIA,IAAI,GAAGD,KAAK,CAAC,CAAD,CAAZ,CA7B8B,CA8BlC;;AACAU,EAAAA,MAAM,GAAGV,KAAK,CAACgB,SAAS,GAAG,CAAb,CAAd,CA/BkC,CAgClC;AACA;;AACA,MAAIf,IAAJ,EAAU;AACN,SAAK,IAAI9zB,CAAC,GAAG60B,SAAS,GAAG,CAAzB,EAA4B70B,CAAC,IAAI,CAAjC,EAAoCA,CAAC,EAArC,EAAyC;AACrC,UAAInJ,KAAK,GAAGg9B,KAAK,CAAC7zB,CAAD,CAAjB;;AACA,UAAInJ,KAAK,CAAC0Y,SAAV,EAAqB;AACjBglB,QAAAA,MAAM,GAAG19B,KAAT;AACA;AACH;AACJ;AACJ,GA1CiC,CA2ClC;AACA;AACA;AACA;AACA;;;AACA,MAAIi9B,IAAI,KAAKE,QAAT,IACA,CAACe,aADD,IAEAR,MAAM,KAAKK,UAFX,IAGAf,KAAK,CAAC51B,IAAN,CAAW,UAAUg3B,UAAV,EAAsB;AAAE,WAAOA,UAAU,KAAKjB,QAAtB;AAAiC,GAApE,CAHJ,EAG2E;AACvEF,IAAAA,IAAI,GAAGE,QAAP;AACH;;AACD,SAAO,CAACF,IAAD,EAAOS,MAAP,CAAP;AACH;;AACD,IAAIW,WAAW;AAAG;AAAe,YAAY;AACzC,WAASA,WAAT,GAAuB;AACnB,SAAK32B,KAAL,GAAa,EAAb,CADmB,CAEnB;;AACA,SAAK42B,WAAL,GAAmB,KAAnB;AACH;;AACDD,EAAAA,WAAW,CAACrhC,SAAZ,CAAsBK,GAAtB,GAA4B,UAAU2C,KAAV,EAAiB;AACzC,QAAIxD,EAAJ;;AACA,QAAI+hC,WAAW,GAAGv+B,KAAK,CAACb,MAAN,CAAao/B,WAA/B;;AACA,QAAIA,WAAW,KAAK79B,SAApB,EAA+B;AAC3B,WAAKgH,KAAL,CAAWI,IAAX,CAAgB9H,KAAhB;AACH,KAFD,MAGK;AACD,UAAIw+B,KAAK,GAAG,KAAK92B,KAAL,CAAWk1B,SAAX,CAAqB,UAAUwB,UAAV,EAAsB;AACnD,eAAOG,WAAW,KAAKH,UAAU,CAACj/B,MAAX,CAAkBo/B,WAAlB,IAAiC,CAAtC,CAAlB;AACH,OAFW,CAAZ;;AAGA,UAAIC,KAAK,KAAK,CAAC,CAAf,EAAkB;AACdx+B,QAAAA,KAAK,CAACmqB,QAAN,GAAiB,KAAKmU,WAAL,GACX1U,QAAQ,CAACsT,QADE,GAEXtT,QAAQ,CAACQ,OAFf;AAGAoU,QAAAA,KAAK,GAAG,KAAK92B,KAAL,CAAWwB,MAAnB;AACH;;AACD,WAAKxB,KAAL,CAAWo1B,MAAX,CAAkB0B,KAAlB,EAAyB,CAAzB,EAA4Bx+B,KAA5B;AACH;AACD;;;AAGA;AACA;AACA;AACA;;;AACA,QAAI,KAAKy+B,QAAT,EAAmB;AACfz+B,MAAAA,KAAK,CAAC41B,YAAN,GAAqB,KAAK6I,QAA1B,CADe,CAEf;;AACAz+B,MAAAA,KAAK,CAACsU,eAAN,GAAwB,KAAKmqB,QAAL,CAAcC,WAAtC;AACA,UAAI3/B,MAAM,GAAG,KAAK0/B,QAAL,CAAcE,kBAA3B;;AACA,WAAK,IAAIz+B,GAAT,IAAgBnB,MAAhB,EAAwB;AACpB,YAAI,CAACiB,KAAK,CAACC,QAAN,CAAeC,GAAf,CAAL,EAA0B;AACtBF,UAAAA,KAAK,CAACI,QAAN,CAAeF,GAAf,EAAoBvB,WAAW,CAACI,MAAM,CAACmB,GAAD,CAAP,CAA/B;AACH,SAFD,MAGK;AACD,WAAC1D,EAAE,GAAGwD,KAAK,CAACQ,QAAN,CAAeN,GAAf,CAAN,MAA+B,IAA/B,IAAuC1D,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACO,GAAH,CAAOgC,MAAM,CAACmB,GAAD,CAAb,CAAhE;AACH;AACJ;AACJ;;AACD,SAAKo+B,WAAL,GAAmB,IAAnB;AACH,GAxCD;;AAyCAD,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB2tB,MAAtB,GAA+B,UAAU3qB,KAAV,EAAiB;AAC5C,QAAIw+B,KAAK,GAAG,KAAK92B,KAAL,CAAWk1B,SAAX,CAAqB,UAAUwB,UAAV,EAAsB;AAAE,aAAOp+B,KAAK,KAAKo+B,UAAjB;AAA8B,KAA3E,CAAZ;AACA,QAAII,KAAK,KAAK,CAAC,CAAf,EACI,KAAK92B,KAAL,CAAWo1B,MAAX,CAAkB0B,KAAlB,EAAyB,CAAzB;AACP,GAJD;;AAKAH,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB4hC,mBAAtB,GAA4C,YAAY;AACpD,SAAKzB,QAAL,GAAgB,KAAKF,IAArB;AACA,SAAKc,UAAL,GAAkB,KAAKL,MAAvB;;AACA,QAAIlhC,EAAE,GAAGshC,iBAAiB,CAAC,KAAKp2B,KAAN,EAAa,CACnC,KAAKu1B,IAD8B,EAEnC,KAAKS,MAF8B,CAAb,CAA1B;AAAA,QAGIT,IAAI,GAAGzgC,EAAE,CAAC,CAAD,CAHb;AAAA,QAGkBkhC,MAAM,GAAGlhC,EAAE,CAAC,CAAD,CAH7B;;AAIA,SAAKygC,IAAL,GAAYA,IAAZ;AACA,SAAKS,MAAL,GAAcA,MAAd;AACH,GATD;;AAUAW,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB6hC,cAAtB,GAAuC,YAAY;AAC/C,QAAI,CAAC,KAAK5B,IAAV,EACI;AACJ,QAAIwB,QAAQ,GAAG;AACXC,MAAAA,WAAW,EAAE,KAAKzB,IAAL,CAAU3oB,eADZ;AAEXqqB,MAAAA,kBAAkB,EAAE;AAFT,KAAf;AAIA,SAAK1B,IAAL,CAAUt8B,YAAV,CAAuB,UAAUrF,KAAV,EAAiB4E,GAAjB,EAAsB;AACzC,UAAInB,MAAM,GAAGzD,KAAK,CAACwC,GAAN,EAAb;;AACA,UAAI,CAACsK,eAAe,CAACrJ,MAAD,CAApB,EAA8B;AAC1B0/B,QAAAA,QAAQ,CAACE,kBAAT,CAA4Bz+B,GAA5B,IAAmCnB,MAAnC;AACH;AACJ,KALD;AAMA,QAAIm3B,YAAY,GAAGvD,mBAAmB,CAAC70B,GAApB,CAAwB,KAAKm/B,IAA7B,CAAnB;;AACA,QAAI/G,YAAY,IAAIA,YAAY,CAACnD,UAAjC,EAA6C;AACzC0L,MAAAA,QAAQ,CAAC1L,UAAT,GAAsB,IAAtB;AACA0L,MAAAA,QAAQ,CAACxL,cAAT,GAA0BiD,YAAY,CAACjD,cAAvC;AACH;;AACD,SAAKwL,QAAL,GAAgBA,QAAhB;AACH,GAnBD;;AAoBAJ,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB8hC,aAAtB,GAAsC,YAAY;AAC9C,QAAItiC,EAAJ;;AACA,WAAO,KAAKygC,IAAL,IAAa,CAAC,CAACzgC,EAAE,GAAG,KAAKygC,IAAX,MAAqB,IAArB,IAA6BzgC,EAAE,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,EAAE,CAAC2tB,QAA1D,MAAwEP,QAAQ,CAAC0T,OAArG;AACH,GAHD;;AAIAe,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB+hC,kBAAtB,GAA2C,YAAY;AACnD,WAAO,IAAP,CADmD,CAEnD;AACA;AACA;AACH,GALD;;AAMAV,EAAAA,WAAW,CAACrhC,SAAZ,CAAsBqgC,eAAtB,GAAwC,YAAY;AAChD,QAAI7gC,EAAJ,CADgD,CAEhD;AACA;;;AACA,WAAO,KAAKkhC,MAAL,CAAY;AAAZ,MACD,KAAKA,MAAL,CAAYppB,eADX,GAED,CAAC9X,EAAE,GAAG,KAAKiiC,QAAX,MAAyB,IAAzB,IAAiCjiC,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACkiC,WAFnE;AAGH,GAPD;;AAQAL,EAAAA,WAAW,CAACrhC,SAAZ,CAAsBugC,eAAtB,GAAwC,YAAY;AAChD,QAAI/gC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAG,KAAKkhC,MAAX,MAAuB,IAAvB,IAA+BlhC,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACiG,GAAlE;AACH,GAHD;;AAIA47B,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB6gC,aAAtB,GAAsC,YAAY;AAC9C,QAAIrhC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAG,KAAKygC,IAAX,MAAqB,IAArB,IAA6BzgC,EAAE,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,EAAE,CAAC8X,eAAhE;AACH,GAHD;;AAIA+pB,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB4gC,aAAtB,GAAsC,YAAY;AAC9C,QAAIphC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAG,KAAKygC,IAAX,MAAqB,IAArB,IAA6BzgC,EAAE,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,EAAE,CAACiG,GAAhE;AACH,GAHD;;AAIA47B,EAAAA,WAAW,CAACrhC,SAAZ,CAAsB2gC,iBAAtB,GAA0C,YAAY;AAClD,QAAInhC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAG,KAAKygC,IAAX,MAAqB,IAArB,IAA6BzgC,EAAE,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,EAAE,CAAC2C,MAAH,CAAUiS,UAAvE;AACH,GAHD;;AAIA,SAAOitB,WAAP;AACH,CArHgC,EAAjC;AAuHA;;;;;AAGA,IAAIW,mBAAmB;AAAG;AAAe,UAAUpsB,MAAV,EAAkB;AACvD9a,EAAAA,SAAS,CAACknC,mBAAD,EAAsBpsB,MAAtB,CAAT;;AACA,WAASosB,mBAAT,GAA+B;AAC3B,QAAIrjC,KAAK,GAAGiX,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACC,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;AACA;;;;;AAGAnX,IAAAA,KAAK,CAACmD,QAAN,GAAiB,IAAItB,GAAJ,EAAjB;AACA;;;;;;AAKA7B,IAAAA,KAAK,CAACsjC,MAAN,GAAe,IAAIhgC,GAAJ,EAAf;AACA;;;;;AAIAtD,IAAAA,KAAK,CAACsiB,UAAN,GAAmB,KAAnB;AACA;;;;;AAIAtiB,IAAAA,KAAK,CAACujC,eAAN,GAAwB,KAAxB;AACA;;;;AAGAvjC,IAAAA,KAAK,CAACwjC,eAAN,GAAwB,KAAxB;AACA;;;;AAGAxjC,IAAAA,KAAK,CAACyjC,WAAN,GAAoBznC,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKqyB,aAAa,EAAlB,CAAT,EAAgC;AAAEoQ,MAAAA,UAAU,EAAE,UAAUiF,KAAV,EAAiB;AAAE,eAAO1jC,KAAK,CAAC2jC,cAAN,CAAqBD,KAArB,CAAP;AAAqC,OAAtE;AAAwE/U,MAAAA,WAAW,EAAE,YAAY;AACrJ;AACA;AACA3uB,QAAAA,KAAK,CAACyjC,WAAN,GAAoBznC,QAAQ,CAAC,EAAD,EAAKgE,KAAK,CAACyjC,WAAX,CAA5B;;AACAzjC,QAAAA,KAAK,CAAC2jC,cAAN,CAAqB,IAArB;AACH,OALuD;AAKrD1mB,MAAAA,QAAQ,EAAE,UAAU5Y,KAAV,EAAiB;AAAE,eAAOrE,KAAK,CAAC+pB,QAAN,CAAe1lB,KAAf,CAAP;AAA+B,OALP;AAKS2qB,MAAAA,MAAM,EAAE,UAAU3qB,KAAV,EAAiB;AAAE,eAAOrE,KAAK,CAACgqB,WAAN,CAAkB3lB,KAAlB,CAAP;AAAkC;AALtE,KAAhC,CAA5B;AAMA,WAAOrE,KAAP;AACH;;AACDqjC,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8Bk8B,iBAA9B,GAAkD,YAAY;AAC1D,SAAKjb,UAAL,GAAkB,IAAlB;AACA,SAAKshB,YAAL;AACH,GAHD;;AAIAP,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8Bk9B,kBAA9B,GAAmD,YAAY;AAC3D,SAAKsF,oBAAL;AACH,GAFD;;AAGAR,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8ByiC,qBAA9B,GAAsD,YAAY;AAC9D,SAAKN,eAAL,GAAuB,IAAvB;AACA,WAAO,IAAP;AACH,GAHD;;AAIAH,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8BwiC,oBAA9B,GAAqD,YAAY;AAC7D,QAAI7jC,KAAK,GAAG,IAAZ;AACA;;;;;AAGA,SAAKwjC,eAAL,GAAuB,KAAKD,eAAL,GAAuB,KAA9C;AACA,QAAIh4B,IAAI,GAAG,KAAKkS,KAAL,CAAWlS,IAAtB;AACA;;;;;AAIA,SAAKpI,QAAL,CAAczC,OAAd,CAAsB,UAAU2D,KAAV,EAAiB;AACnC,UAAI,CAACA,KAAK,CAAC0Y,SAAX,EAAsB;AAClB1Y,QAAAA,KAAK,CAACmqB,QAAN,GAAiBP,QAAQ,CAAC0T,OAA1B;AACH,OAFD,MAGK,IAAIt9B,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAACsT,QAAhC,EAA0C;AAC3Cl9B,QAAAA,KAAK,CAACmqB,QAAN,GACInqB,KAAK,CAACmqB,QAAN,KAAmBP,QAAQ,CAAC0T,OAA5B,GACM1T,QAAQ,CAACsT,QADf,GAEMtT,QAAQ,CAACQ,OAHnB;AAIH;AACJ,KAVD;AAWA;;;;;AAIA,SAAKmV,YAAL;AACA;;;;AAGA,QAAIG,eAAe,GAAGx4B,IAAI,KAAK,WAAT,GAChBsyB,wBADgB,GAEhBuD,qBAFN;AAGA;;;;AAGA,QAAItuB,OAAO,GAAG;AACVkG,MAAAA,aAAa,EAAE,UAAU3U,KAAV,EAAiB;AAAE,eAAOA,KAAK,CAAC2U,aAAN,EAAP;AAA+B,OADvD;AAEVP,MAAAA,WAAW,EAAE,UAAUpU,KAAV,EAAiB;AAC1B,YAAIwZ,QAAQ,GAAGxZ,KAAK,CAACwZ,QAArB;AACAxZ,QAAAA,KAAK,CAACoU,WAAN,CAAkBsrB,eAAe,CAAC1/B,KAAD,EAAQrE,KAAK,CAACgkC,QAAN,CAAenmB,QAAf,CAAR,CAAjC;AACH;AALS,KAAd;AAOA;;;;;;;;AAOA,SAAK1a,QAAL,CAAczC,OAAd,CAAsB,UAAU2D,KAAV,EAAiB;AAAE,aAAOrE,KAAK,CAACyjC,WAAN,CAAkB/hC,GAAlB,CAAsB2C,KAAtB,CAAP;AAAsC,KAA/E;AACA,SAAKo/B,WAAL,CAAiBlV,KAAjB,CAAuBzb,OAAvB;AACA;;;;AAGA,SAAKwwB,MAAL,CAAY5iC,OAAZ,CAAoB,UAAU2gC,KAAV,EAAiB;AAAE,aAAQA,KAAK,CAACyB,QAAN,GAAiB/9B,SAAzB;AAAsC,KAA7E;AACH,GAxDD;;AAyDAs+B,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8BuiC,YAA9B,GAA6C,YAAY;AACrD,SAAKN,MAAL,CAAY5iC,OAAZ,CAAoB,UAAU2gC,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAAC4B,mBAAN,EAAP;AAAqC,KAA5E;AACH,GAFD;;AAGAI,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8BsiC,cAA9B,GAA+C,UAAUD,KAAV,EAAiB;AAC5D,QAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,MAAAA,KAAK,GAAG,KAAR;AAAgB;;AACxC,QAAI,EAAEA,KAAK,IAAI,CAAC,KAAKH,eAAjB,CAAJ,EACI;AACJ;;;;AAGA,SAAKA,eAAL,GAAuB,IAAvB;AACA;;;;AAGA,SAAKpgC,QAAL,CAAczC,OAAd,CAAsB,UAAU2D,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAAC0U,mBAAN,EAAP;AAAqC,KAA9E;AACA;;;;;;AAKA,SAAKuqB,MAAL,CAAY5iC,OAAZ,CAAoB,UAAU2gC,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAAC6B,cAAN,EAAP;AAAgC,KAAvE;AACA;;;;AAGA,QAAIQ,KAAK,IAAI,CAAC,KAAKF,eAAnB,EAAoC;AAChC,WAAKA,eAAL,GAAuB,IAAvB;AACA,WAAK7U,WAAL;AACH;AACJ,GAzBD;;AA0BA0U,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8B0oB,QAA9B,GAAyC,UAAU1lB,KAAV,EAAiB;AACtD,SAAKlB,QAAL,CAAczB,GAAd,CAAkB2C,KAAlB;AACA,SAAK4/B,UAAL,CAAgB5/B,KAAhB;AACAA,IAAAA,KAAK,CAACmqB,QAAN,GAAiB,KAAKlM,UAAL,GAAkB2L,QAAQ,CAACsT,QAA3B,GAAsCtT,QAAQ,CAACQ,OAAhE;AACH,GAJD;;AAKA4U,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8B2oB,WAA9B,GAA4C,UAAU3lB,KAAV,EAAiB;AACzD,SAAKs/B,cAAL;AACA,SAAKxgC,QAAL,CAAcxB,MAAd,CAAqB0C,KAArB;AACA,SAAK6/B,eAAL,CAAqB7/B,KAArB;AACH,GAJD;;AAKAg/B,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8B4iC,UAA9B,GAA2C,UAAU5/B,KAAV,EAAiB;AACxD,QAAIg9B,KAAK,GAAG,KAAK2C,QAAL,CAAc3/B,KAAK,CAACwZ,QAApB,CAAZ;AACAwjB,IAAAA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAAC3/B,GAAN,CAAU2C,KAAV,CAA9C;AACH,GAHD;;AAIAg/B,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8B6iC,eAA9B,GAAgD,UAAU7/B,KAAV,EAAiB;AAC7D,QAAIg9B,KAAK,GAAG,KAAK2C,QAAL,CAAc3/B,KAAK,CAACwZ,QAApB,CAAZ;AACAwjB,IAAAA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACrS,MAAN,CAAa3qB,KAAb,CAA9C;AACH,GAHD;AAIA;;;;;;AAIAg/B,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8B2iC,QAA9B,GAAyC,UAAU9mB,EAAV,EAAc;AACnD,QAAIA,EAAE,KAAKnY,SAAX,EACI,OAF+C,CAGnD;;AACA,KAAC,KAAKu+B,MAAL,CAAY9+B,GAAZ,CAAgB0Y,EAAhB,CAAD,IAAwB,KAAKomB,MAAL,CAAYliC,GAAZ,CAAgB8b,EAAhB,EAAoB,IAAIwlB,WAAJ,EAApB,CAAxB;AACA,WAAO,KAAKY,MAAL,CAAYnhC,GAAZ,CAAgB+a,EAAhB,CAAP;AACH,GAND;;AAOAmmB,EAAAA,mBAAmB,CAAChiC,SAApB,CAA8Bf,MAA9B,GAAuC,YAAY;AAC/C,WAAQ1B,aAAa,CAACgwB,mBAAmB,CAAChE,QAArB,EAA+B;AAAEjrB,MAAAA,KAAK,EAAE,KAAK8jC;AAAd,KAA/B,EAA4D,KAAKhmB,KAAL,CAAWta,QAAvE,CAArB;AACH,GAFD;;AAGA,SAAOkgC,mBAAP;AACH,CAzKwC,CAyKvCrkC,SAzKuC,CAAzC;AA2KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAASmlC,cAAT,CAAwB3gB,OAAxB,EAAiC;AAC7B,SAAOxJ,WAAW,CAAC,YAAY;AAAE,WAAOhX,WAAW,CAACwgB,OAAD,CAAlB;AAA8B,GAA7C,CAAlB;AACH;AAED;;;;;;;;;AAOA,SAAS4gB,kBAAT,CAA4BzkC,KAA5B,EAAmC;AAC/B,MAAI0kC,cAAc,GAAG1kC,KAAK,YAAYG,WAAjB,GAA+BH,KAAK,CAACwC,GAAN,EAA/B,GAA6CxC,KAAlE;AACA,SAAO6lB,aAAa,CAAC6e,cAAD,CAAb,GACDA,cAAc,CAAC3e,OAAf,EADC,GAED2e,cAFN;AAGH;;AAED,IAAIC,iBAAiB,GAAG,UAAUjkC,CAAV,EAAa;AACjC,SAAO,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,CAAC7D,GAAlC;AACH,CAFD;;AAGA,IAAI+nC,QAAQ,GAAG,UAAUlkC,CAAV,EAAa;AAAE,SAAQikC,iBAAiB,CAACjkC,CAAD,CAAjB,GAAuBA,CAAC,CAAC7D,GAAzB,GAA+BuI,SAAvC;AAAoD,CAAlF;;AACA,SAASwC,SAAT,GAAqB;AACjB,MAAIi9B,IAAI,GAAG,EAAX;;AACA,OAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGttB,SAAS,CAAC5J,MAAhC,EAAwCk3B,EAAE,EAA1C,EAA8C;AAC1CD,IAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWttB,SAAS,CAACstB,EAAD,CAApB;AACH;;AACD,MAAIC,YAAY,GAAG,CAAC1xB,KAAK,CAACC,OAAN,CAAcuxB,IAAI,CAAC,CAAD,CAAlB,CAApB;AACA,MAAIG,SAAS,GAAGD,YAAY,GAAG,CAAH,GAAO,CAAC,CAApC;AACA,MAAIE,UAAU,GAAGJ,IAAI,CAAC,IAAIG,SAAL,CAArB;AACA,MAAIE,UAAU,GAAGL,IAAI,CAAC,IAAIG,SAAL,CAArB;AACA,MAAIG,WAAW,GAAGN,IAAI,CAAC,IAAIG,SAAL,CAAtB;AACA,MAAIhuB,OAAO,GAAG6tB,IAAI,CAAC,IAAIG,SAAL,CAAlB;AACA,MAAII,YAAY,GAAGhoC,WAAW,CAAC8nC,UAAD,EAAaC,WAAb,EAA0B9oC,QAAQ,CAAC;AAAEgpC,IAAAA,KAAK,EAAET,QAAQ,CAACO,WAAW,CAAC,CAAD,CAAZ;AAAjB,GAAD,EAAsCnuB,OAAtC,CAAlC,CAA9B;AACA,SAAO+tB,YAAY,GAAGK,YAAY,CAACH,UAAD,CAAf,GAA8BG,YAAjD;AACH;;AAED,IAAIE,aAAa,GAAG,UAAU5kC,CAAV,EAAa;AAC7B,SAAO,OAAOA,CAAP,KAAa,UAApB;AACH,CAFD;;AAGA,SAAS6kC,YAAT,CAAsBhiC,MAAtB,EAA8BiiC,eAA9B,EAA+C3xB,EAA/C,EAAmDmD,OAAnD,EAA4D;AACxD,MAAIyuB,UAAU,GAAGH,aAAa,CAACE,eAAD,CAAb,GACX,CAACjiC,MAAD,CADW,GAEX,CAACA,MAAD,EAASiiC,eAAe,CAAC/Y,IAAhB,CAAqB,GAArB,CAAT,EAAoC5Y,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,KAAK,CAA3B,GAA+B,KAAK,CAApC,GAAwCA,EAAE,CAAC4Y,IAAH,CAAQ,GAAR,CAA5E,CAFN;AAGA,MAAIiZ,WAAW,GAAGxmC,OAAO,CAAC,YAAY;AAClC,WAAOomC,aAAa,CAACE,eAAD,CAAb,GACDA,eADC,GAED59B,SAAS,CAAC49B,eAAD,EAAkB3xB,EAAlB,EAAsBmD,OAAtB,CAFf;AAGH,GAJwB,EAItByuB,UAJsB,CAAzB;AAKA,MAAIE,YAAY,GAAGD,WAAW,CAACniC,MAAM,CAACf,GAAP,EAAD,CAA9B;AACA,MAAIxC,KAAK,GAAGwkC,cAAc,CAACmB,YAAD,CAA1B,CAVwD,CAWxD;;AACA,MAAI1gC,WAAW,GAAGpG,MAAM,EAAxB;AACAK,EAAAA,OAAO,CAAC,YAAY;AAChB+F,IAAAA,WAAW,CAACpE,OAAZ,IAAuBoE,WAAW,CAACpE,OAAZ,EAAvB;AACAoE,IAAAA,WAAW,CAACpE,OAAZ,GAAsB0C,MAAM,CAACtB,QAAP,CAAgB,UAAUvB,CAAV,EAAa;AAAE,aAAOV,KAAK,CAACyB,GAAN,CAAUikC,WAAW,CAAChlC,CAAD,CAArB,CAAP;AAAmC,KAAlE,CAAtB,CAFgB,CAGhB;;AACAV,IAAAA,KAAK,CAACyB,GAAN,CAAUkkC,YAAV;AACH,GALM,EAKJ,CAACpiC,MAAD,EAASvD,KAAT,EAAgB0lC,WAAhB,CALI,CAAP;AAMAxW,EAAAA,gBAAgB,CAAC,YAAY;AAAE,WAAOjqB,WAAW,CAACpE,OAAZ,IAAuBoE,WAAW,CAACpE,OAAZ,EAA9B;AAAsD,GAArE,CAAhB;AACA,SAAOb,KAAP;AACH,C,CAED;AACA;AACA;;;AACA,IAAI4lC,QAAQ,GAAG,MAAf;;AACA,IAAIC,WAAW,GAAG,UAAU7nC,KAAV,EAAiB;AAC/B,SAAOA,KAAK,GAAG,KAAR,GAAgB,IAAIA,KAApB,GAA4B4nC,QAAnC;AACH,CAFD;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,SAASE,gBAAT,CAA0B9nC,KAA1B,EAAiC;AAC7B,MAAI+nC,YAAY,GAAGvB,cAAc,CAAC,CAAD,CAAjC;AACA,MAAIwB,YAAY,GAAGxB,cAAc,CAAC,CAAD,CAAjC;AACA,MAAIxmB,aAAa,GAAGjf,UAAU,CAACwkB,aAAD,CAAV,CAA0BvF,aAA9C;AACA1gB,EAAAA,SAAS,CAAC,CAAC,EAAEU,KAAK,IAAIggB,aAAX,CAAF,EAA6B,4GAA7B,CAAT;;AACA,MAAIhgB,KAAJ,EAAW;AACP+nC,IAAAA,YAAY,GAAG/nC,KAAK,CAACuM,MAAN,IAAgBw7B,YAA/B;AACAC,IAAAA,YAAY,GAAGhoC,KAAK,CAACwM,MAAN,IAAgBw7B,YAA/B;AACH,GAHD,MAIK,IAAIhoB,aAAJ,EAAmB;AACpB+nB,IAAAA,YAAY,GAAG/nB,aAAa,CAAC9Y,QAAd,CAAuB,QAAvB,EAAiC,CAAjC,CAAf;AACA8gC,IAAAA,YAAY,GAAGhoB,aAAa,CAAC9Y,QAAd,CAAuB,QAAvB,EAAiC,CAAjC,CAAf;AACH;;AACD,MAAIqF,MAAM,GAAGg7B,YAAY,CAACQ,YAAD,EAAeF,WAAf,CAAzB;AACA,MAAIr7B,MAAM,GAAG+6B,YAAY,CAACS,YAAD,EAAeH,WAAf,CAAzB;AACA,SAAO;AAAEt7B,IAAAA,MAAM,EAAEA,MAAV;AAAkBC,IAAAA,MAAM,EAAEA;AAA1B,GAAP;AACH;;AAED,SAASy7B,WAAT,CAAqBjmC,KAArB,EAA4BsF,QAA5B,EAAsC;AAClCtG,EAAAA,SAAS,CAAC,YAAY;AAAE,WAAQ6lB,aAAa,CAAC7kB,KAAD,CAAb,GAAuBA,KAAK,CAACiC,QAAN,CAAeqD,QAAf,CAAvB,GAAkDF,SAA1D;AAAuE,GAAtF,EAAwF,CAACpF,KAAD,CAAxF,CAAT;AACH;AAED;;;;;;;;;;;;;;;;;;;;;AAmBA,SAASkmC,SAAT,CAAmB3zB,MAAnB,EAA2B1O,MAA3B,EAAmC;AAC/B,MAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,MAAIsiC,qBAAqB,GAAGtnC,MAAM,CAAC,IAAD,CAAlC;AACA,MAAImB,KAAK,GAAGwkC,cAAc,CAAC3f,aAAa,CAACtS,MAAD,CAAb,GAAwBA,MAAM,CAAC/P,GAAP,EAAxB,GAAuC+P,MAAxC,CAA1B;AACArT,EAAAA,OAAO,CAAC,YAAY;AAChB,WAAOc,KAAK,CAACsC,MAAN,CAAa,UAAU5B,CAAV,EAAae,GAAb,EAAkB;AAClC,UAAI0kC,qBAAqB,CAACtlC,OAA1B,EAAmC;AAC/BslC,QAAAA,qBAAqB,CAACtlC,OAAtB,CAA8BgC,IAA9B;AACH;;AACDsjC,MAAAA,qBAAqB,CAACtlC,OAAtB,GAAgCvC,MAAM,CAACjC,QAAQ,CAAC;AAAEgZ,QAAAA,IAAI,EAAErV,KAAK,CAACwC,GAAN,EAAR;AAAqBqR,QAAAA,EAAE,EAAEnT,CAAzB;AAA4B4U,QAAAA,QAAQ,EAAEtV,KAAK,CAAC0C,WAAN;AAAtC,OAAD,EAA8DmB,MAA9D,CAAT,CAAN,CAAsFlB,KAAtF,CAA4FlB,GAA5F,CAAhC;AACA,aAAOzB,KAAK,CAACwC,GAAN,EAAP;AACH,KANM,CAAP;AAOH,GARM,EAQJuT,MAAM,CAACrS,MAAP,CAAcG,MAAd,CARI,CAAP;AASAoiC,EAAAA,WAAW,CAAC1zB,MAAD,EAAS,UAAU7R,CAAV,EAAa;AAAE,WAAOV,KAAK,CAACyB,GAAN,CAAUvB,UAAU,CAACQ,CAAD,CAApB,CAAP;AAAkC,GAA1D,CAAX;AACA,SAAOV,KAAP;AACH;;AAED,SAASomC,wBAAT,GAAoC;AAChC,SAAO;AACH/R,IAAAA,OAAO,EAAEhxB,WAAW,CAAC,CAAD,CADjB;AAEHixB,IAAAA,OAAO,EAAEjxB,WAAW,CAAC,CAAD,CAFjB;AAGHgjC,IAAAA,eAAe,EAAEhjC,WAAW,CAAC,CAAD,CAHzB;AAIHijC,IAAAA,eAAe,EAAEjjC,WAAW,CAAC,CAAD;AAJzB,GAAP;AAMH;;AACD,SAASkjC,WAAT,CAAqBhsB,MAArB,EAA6BisB,SAA7B,EAAwCxmC,KAAxC,EAA+C;AAC3CA,EAAAA,KAAK,CAACyB,GAAN,CAAU,CAAC8Y,MAAD,IAAW,CAACisB,SAAZ,GAAwB,CAAxB,GAA4BjsB,MAAM,GAAGisB,SAA/C;AACH;;AACD,SAASC,mBAAT,CAA6B/iC,MAA7B,EAAqCgjC,UAArC,EAAiD;AAC7C,MAAI5iC,MAAM,GAAG,YAAY;AACrB,QAAI5C,EAAE,GAAGwlC,UAAU,EAAnB;AAAA,QAAuBC,OAAO,GAAGzlC,EAAE,CAACylC,OAApC;AAAA,QAA6CC,OAAO,GAAG1lC,EAAE,CAAC0lC,OAA1D;AAAA,QAAmEC,UAAU,GAAG3lC,EAAE,CAAC2lC,UAAnF;AAAA,QAA+FC,UAAU,GAAG5lC,EAAE,CAAC4lC,UAA/G,CADqB,CAErB;;;AACApjC,IAAAA,MAAM,CAAC2wB,OAAP,CAAe5yB,GAAf,CAAmBklC,OAAnB;AACAjjC,IAAAA,MAAM,CAAC4wB,OAAP,CAAe7yB,GAAf,CAAmBmlC,OAAnB,EAJqB,CAKrB;;AACAL,IAAAA,WAAW,CAACI,OAAD,EAAUE,UAAV,EAAsBnjC,MAAM,CAAC2iC,eAA7B,CAAX;AACAE,IAAAA,WAAW,CAACK,OAAD,EAAUE,UAAV,EAAsBpjC,MAAM,CAAC4iC,eAA7B,CAAX;AACH,GARD;;AASAxiC,EAAAA,MAAM;AACN,SAAOA,MAAP;AACH;;AAED,IAAIijC,WAAW,GAAG,OAAO5tB,MAAP,KAAkB,WAApC;AACA,IAAI6tB,yBAAyB,GAAGD,WAAW,GAAGpnC,eAAH,GAAqBX,SAAhE;;AAEA,IAAIioC,uBAAuB,GAAG,UAAU/iC,OAAV,EAAmB;AAAE,SAAO,YAAY;AAClE,WAAO;AACHyiC,MAAAA,OAAO,EAAEziC,OAAO,CAACgjC,UADd;AAEHN,MAAAA,OAAO,EAAE1iC,OAAO,CAACijC,SAFd;AAGHN,MAAAA,UAAU,EAAE3iC,OAAO,CAACkjC,WAAR,GAAsBljC,OAAO,CAACmjC,WAHvC;AAIHP,MAAAA,UAAU,EAAE5iC,OAAO,CAACojC,YAAR,GAAuBpjC,OAAO,CAACqjC;AAJxC,KAAP;AAMH,GAPkD;AAO/C,CAPJ;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA,SAASC,gBAAT,CAA0B3nC,GAA1B,EAA+B;AAC3B,MAAI6D,MAAM,GAAG2W,WAAW,CAAC+rB,wBAAD,CAAxB;AACAY,EAAAA,yBAAyB,CAAC,YAAY;AAClC,QAAI9iC,OAAO,GAAGrE,GAAG,CAACgB,OAAlB;AACAvD,IAAAA,SAAS,CAAC,CAAC,CAAC4G,OAAH,EAAY,+DAAZ,CAAT;AACA,QAAI,CAACA,OAAL,EACI;AACJ,QAAIujC,kBAAkB,GAAGhB,mBAAmB,CAAC/iC,MAAD,EAASujC,uBAAuB,CAAC/iC,OAAD,CAAhC,CAA5C;AACA,QAAIwjC,cAAc,GAAG7W,WAAW,CAAC3sB,OAAD,EAAU,QAAV,EAAoBujC,kBAApB,EAAwC;AAAE/W,MAAAA,OAAO,EAAE;AAAX,KAAxC,CAAhC;AACA,QAAIiX,cAAc,GAAG9W,WAAW,CAAC3sB,OAAD,EAAU,QAAV,EAAoBujC,kBAApB,CAAhC;AACA,WAAO,YAAY;AACfC,MAAAA,cAAc,IAAIA,cAAc,EAAhC;AACAC,MAAAA,cAAc,IAAIA,cAAc,EAAhC;AACH,KAHD;AAIH,GAZwB,EAYtB,EAZsB,CAAzB;AAaA,SAAOjkC,MAAP;AACH;;AAED,IAAIkkC,oBAAoB,GAAGxB,wBAAwB,EAAnD;;AACA,SAASyB,wBAAT,GAAoC;AAChC,SAAO;AACHlB,IAAAA,OAAO,EAAExtB,MAAM,CAAC2uB,WADb;AAEHlB,IAAAA,OAAO,EAAEztB,MAAM,CAAC4uB,WAFb;AAGHlB,IAAAA,UAAU,EAAEvW,QAAQ,CAAC0X,IAAT,CAAcC,WAAd,GAA4B9uB,MAAM,CAAC+uB,UAH5C;AAIHpB,IAAAA,UAAU,EAAExW,QAAQ,CAAC0X,IAAT,CAAcG,YAAd,GAA6BhvB,MAAM,CAACivB;AAJ7C,GAAP;AAMH;;AACD,IAAIC,YAAY,GAAG,KAAnB;;AACA,SAASC,iBAAT,GAA6B;AACzBD,EAAAA,YAAY,GAAG,IAAf;AACA,MAAI,OAAOlvB,MAAP,KAAkB,WAAtB,EACI;AACJ,MAAIsuB,kBAAkB,GAAGhB,mBAAmB,CAACmB,oBAAD,EAAuBC,wBAAvB,CAA5C;AACAhX,EAAAA,WAAW,CAAC1X,MAAD,EAAS,QAAT,EAAmBsuB,kBAAnB,EAAuC;AAAE/W,IAAAA,OAAO,EAAE;AAAX,GAAvC,CAAX;AACAG,EAAAA,WAAW,CAAC1X,MAAD,EAAS,QAAT,EAAmBsuB,kBAAnB,CAAX;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,SAASc,iBAAT,GAA6B;AACzBvB,EAAAA,yBAAyB,CAAC,YAAY;AAClC,KAACqB,YAAD,IAAiBC,iBAAiB,EAAlC;AACH,GAFwB,EAEtB,EAFsB,CAAzB;AAGA,SAAOV,oBAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA,SAASY,YAAT,GAAwB;AACpB,MAAIllB,iBAAiB,GAAGjJ,WAAW,CAAC,YAAY;AAAE,WAAO,IAAIqI,iBAAJ,EAAP;AAAiC,GAAhD,CAAnC;AACA1jB,EAAAA,SAAS,CAAC,YAAY;AAClBskB,IAAAA,iBAAiB,CAACnf,KAAlB;AACA,WAAO,YAAY;AAAE,aAAOmf,iBAAiB,CAAClf,OAAlB,EAAP;AAAqC,KAA1D;AACH,GAHQ,EAGN,EAHM,CAAT;AAIA,SAAOkf,iBAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA,SAASmlB,QAAT,GAAoB;AAChB,MAAIC,KAAK,GAAG,EAAZ;;AACA,OAAK,IAAI5D,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGttB,SAAS,CAAC5J,MAAhC,EAAwCk3B,EAAE,EAA1C,EAA8C;AAC1C4D,IAAAA,KAAK,CAAC5D,EAAD,CAAL,GAAYttB,SAAS,CAACstB,EAAD,CAArB;AACH,GAJe,CAKhB;;;AACAvnC,EAAAA,OAAO,CAACmrC,KAAK,CAAC96B,MAAN,GAAe,CAAhB,EAAmB,gFAAnB,CAAP;AACA,MAAIs1B,KAAK,GAAGrkC,MAAM,CAAC,CAAD,CAAlB;;AACA,MAAIqC,EAAE,GAAG3B,QAAQ,CAACmpC,KAAK,CAACxF,KAAK,CAACriC,OAAP,CAAN,CAAjB;AAAA,MAAyC8nC,IAAI,GAAGznC,EAAE,CAAC,CAAD,CAAlD;AAAA,MAAuD0nC,OAAO,GAAG1nC,EAAE,CAAC,CAAD,CAAnE;;AACA,SAAO,CACHynC,IADG,EAEH,UAAUrd,IAAV,EAAgB;AACZ4X,IAAAA,KAAK,CAACriC,OAAN,GACI,OAAOyqB,IAAP,KAAgB,QAAhB,GACMjuB,IAAI,CAAC,CAAD,EAAIqrC,KAAK,CAAC96B,MAAV,EAAkBs1B,KAAK,CAACriC,OAAN,GAAgB,CAAlC,CADV,GAEMyqB,IAHV;AAIAsd,IAAAA,OAAO,CAACF,KAAK,CAACxF,KAAK,CAACriC,OAAP,CAAN,CAAP;AACH,GARE,CAAP;AAUH,C,CAED;;;AACA,IAAIgoC,oBAAoB,GAAGxlC,WAAW,CAAC,IAAD,CAAtC;;AACA,IAAI,OAAO8V,MAAP,KAAkB,WAAtB,EAAmC;AAC/B,MAAIA,MAAM,CAAC2vB,UAAX,EAAuB;AACnB,QAAIC,kBAAkB,GAAG5vB,MAAM,CAAC2vB,UAAP,CAAkB,0BAAlB,CAAzB;;AACA,QAAIE,2BAA2B,GAAG,YAAY;AAC1C,aAAOH,oBAAoB,CAACpnC,GAArB,CAAyBsnC,kBAAkB,CAACE,OAA5C,CAAP;AACH,KAFD;;AAGAF,IAAAA,kBAAkB,CAACG,WAAnB,CAA+BF,2BAA/B;AACAA,IAAAA,2BAA2B;AAC9B,GAPD,MAQK;AACDH,IAAAA,oBAAoB,CAACpnC,GAArB,CAAyB,KAAzB;AACH;AACJ;;AACD,SAAS0nC,2BAAT,CAAqCC,cAArC,EAAqD3kB,eAArD,EAAsE;AAClE,SAAO,OAAOA,eAAP,KAA2B,SAA3B,GACDA,eADC,GAEDqB,OAAO,CAACsjB,cAAD,CAFb;AAGH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAASC,gBAAT,GAA4B;AACxB,MAAI5kB,eAAe,GAAG1lB,UAAU,CAACwkB,aAAD,CAAV,CAA0BkB,eAAhD;;AACA,MAAIvjB,EAAE,GAAG3B,QAAQ,CAAC4pC,2BAA2B,CAACN,oBAAoB,CAACrmC,GAArB,EAAD,EAA6BiiB,eAA7B,CAA5B,CAAjB;AAAA,MAA6F6kB,kBAAkB,GAAGpoC,EAAE,CAAC,CAAD,CAApH;AAAA,MAAyHqoC,qBAAqB,GAAGroC,EAAE,CAAC,CAAD,CAAnJ;;AACAlC,EAAAA,SAAS,CAAC,YAAY;AAClB,WAAO6pC,oBAAoB,CAAC5mC,QAArB,CAA8B,UAAUvB,CAAV,EAAa;AAC9C6oC,MAAAA,qBAAqB,CAACJ,2BAA2B,CAACzoC,CAAD,EAAI+jB,eAAJ,CAA5B,CAArB;AACH,KAFM,CAAP;AAGH,GAJQ,EAIN,CAAC8kB,qBAAD,EAAwB9kB,eAAxB,CAJM,CAAT;AAKA,SAAO6kB,kBAAP;AACH;AAED;;;;;;;;AAMA,SAASE,aAAT,CAAuBtoC,EAAvB,EAA2B;AACvB,MAAIsC,QAAQ,GAAGtC,EAAE,CAACsC,QAAlB;AAAA,MAA4BimC,OAAO,GAAGvoC,EAAE,CAACuoC,OAAzC;AACA,MAAItsB,OAAO,GAAGpe,UAAU,CAACwkB,aAAD,CAAxB;AACApG,EAAAA,OAAO,GAAGje,OAAO,CAAC,YAAY;AAAE,WAAQ7C,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK8gB,OAAL,CAAT,EAAwB;AAAEsH,MAAAA,eAAe,EAAEglB;AAAnB,KAAxB,CAAhB;AAAyE,GAAxF,EAA0F,CAACA,OAAD,CAA1F,CAAjB;AACA,SAAQxqC,aAAa,CAACskB,aAAa,CAAC0H,QAAf,EAAyB;AAAEjrB,IAAAA,KAAK,EAAEmd;AAAT,GAAzB,EAA6C3Z,QAA7C,CAArB;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,IAAIkmC,YAAY;AAAG;AAAe,YAAY;AAC1C,WAASA,YAAT,GAAwB;AACpB,SAAK7mB,iBAAL,GAAyB,IAAI3gB,GAAJ,EAAzB;AACH;AACD;;;;;;;AAKAwnC,EAAAA,YAAY,CAAChoC,SAAb,CAAuB+C,SAAvB,GAAmC,UAAUue,QAAV,EAAoB;AACnD,QAAI3iB,KAAK,GAAG,IAAZ;;AACA,SAAKwiB,iBAAL,CAAuB9gB,GAAvB,CAA2BihB,QAA3B;AACA,WAAO,YAAY;AAAE,aAAO3iB,KAAK,CAACwiB,iBAAN,CAAwB7gB,MAAxB,CAA+BghB,QAA/B,CAAP;AAAkD,KAAvE;AACH,GAJD;AAKA;;;;;;;;;;;;;;;;;AAeA0mB,EAAAA,YAAY,CAAChoC,SAAb,CAAuBiB,KAAvB,GAA+B,UAAU6tB,KAAV,EAAiBxZ,OAAjB,EAA0B;AACrD,SAAK6L,iBAAL,CAAuB9hB,OAAvB,CAA+B,UAAUiiB,QAAV,EAAoB;AAC/CA,MAAAA,QAAQ,CAACrgB,KAAT,CAAe6tB,KAAK,CAACmZ,WAAN,IAAqBnZ,KAApC,EAA2CxZ,OAA3C;AACH,KAFD;AAGH,GAJD;;AAKA,SAAO0yB,YAAP;AACH,CAnCiC,EAAlC;;AAoCA,IAAIE,kBAAkB,GAAG,YAAY;AAAE,SAAO,IAAIF,YAAJ,EAAP;AAA4B,CAAnE;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,SAASG,eAAT,GAA2B;AACvB,SAAOxvB,WAAW,CAACuvB,kBAAD,CAAlB;AACH;AAED;;;;;;;AAKA,SAASE,cAAT,CAAwBzlC,WAAxB,EAAqC;AACjC;AACA;AACA;AACA;AACA,MAAIxE,GAAG,GAAG,CAACwE,WAAD,IAAgB,OAAOA,WAAP,KAAuB,UAAvC,GACJxF,MAAM,CAAC,IAAD,CADF,GAEJwF,WAFN,CALiC,CAQjC;AACA;AACA;AACA;AACA;;AACA,MAAIA,WAAW,IAAI,OAAOA,WAAP,KAAuB,UAA1C,EAAsD;AAClDrF,IAAAA,SAAS,CAAC,YAAY;AAClBqF,MAAAA,WAAW,CAACxE,GAAG,CAACgB,OAAL,CAAX;AACA,aAAO,YAAY;AAAE,eAAOwD,WAAW,CAAC,IAAD,CAAlB;AAA2B,OAAhD;AACH,KAHQ,EAGN,EAHM,CAAT;AAIH;;AACD,SAAOxE,GAAP;AACH;AAED;;;;;;AAIA,IAAIkqC,kBAAkB;AAAG;AAAe,UAAUzyB,MAAV,EAAkB;AACtD9a,EAAAA,SAAS,CAACutC,kBAAD,EAAqBzyB,MAArB,CAAT;;AACA,WAASyyB,kBAAT,GAA8B;AAC1B,QAAI1pC,KAAK,GAAGiX,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACC,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AACAnX,IAAAA,KAAK,CAAC8jB,YAAN,GAAqB,EAArB;AACA,WAAO9jB,KAAP;AACH;;AACD0pC,EAAAA,kBAAkB,CAACroC,SAAnB,CAA6BkE,iBAA7B,GAAiD,YAAY,CAAG,CAAhE;;AACAmkC,EAAAA,kBAAkB,CAACroC,SAAnB,CAA6BuY,KAA7B,GAAqC,YAAY,CAAG,CAApD;;AACA8vB,EAAAA,kBAAkB,CAACroC,SAAnB,CAA6B0W,KAA7B,GAAqC,YAAY,CAAG,CAApD;;AACA2xB,EAAAA,kBAAkB,CAACroC,SAAnB,CAA6BwV,cAA7B,GAA8C,YAAY;AACtD,WAAO;AAAE1Q,MAAAA,CAAC,EAAE;AAAEC,QAAAA,GAAG,EAAE,CAAP;AAAUC,QAAAA,GAAG,EAAE;AAAf,OAAL;AAAyBC,MAAAA,CAAC,EAAE;AAAEF,QAAAA,GAAG,EAAE,CAAP;AAAUC,QAAAA,GAAG,EAAE;AAAf;AAA5B,KAAP;AACH,GAFD;;AAGAqjC,EAAAA,kBAAkB,CAACroC,SAAnB,CAA6B6W,eAA7B,GAA+C,UAAU3T,GAAV,EAAe;AAC1D,WAAO,KAAKuf,YAAL,CAAkBvf,GAAlB,KAA0B,CAAjC;AACH,GAFD;;AAGAmlC,EAAAA,kBAAkB,CAACroC,SAAnB,CAA6Bf,MAA7B,GAAsC,YAAY;AAC9C,SAAKsZ,KAAL;AACH,GAFD;;AAGA,SAAO8vB,kBAAP;AACH,CApBuC,CAoBtCzmC,aApBsC,CAAxC;AAqBA;;;;;;;AAKA,SAAS0mC,gBAAT,CAA0B7lB,YAA1B,EAAwC;AACpC,MAAIjjB,EAAE,GAAG3B,QAAQ,CAAC4kB,YAAD,CAAjB;AAAA,MAAiC8lB,cAAc,GAAG/oC,EAAE,CAAC,CAAD,CAApD;AAAA,MAAyDgpC,iBAAiB,GAAGhpC,EAAE,CAAC,CAAD,CAA/E;;AACA,MAAI8c,aAAa,GAAG3D,WAAW,CAAC,YAAY;AAAE,WAAO,IAAI0vB,kBAAJ,EAAP;AAAkC,GAAjD,CAA/B;AACA/rB,EAAAA,aAAa,CAACxY,YAAd,CAA2B;AACvBzB,IAAAA,QAAQ,EAAE,UAAUrD,CAAV,EAAa;AAAE,aAAOwpC,iBAAiB,CAAC7tC,QAAQ,CAAC,EAAD,EAAKqE,CAAL,CAAT,CAAxB;AAA4C;AAD9C,GAA3B;AAGAsd,EAAAA,aAAa,CAACmG,YAAd,GAA6BA,YAA7B;AACA,MAAInB,QAAQ,GAAGyH,yBAAyB,CAACzM,aAAD,EAAgB,EAAhB,EAAoB,EAApB,CAAxC;AACAhf,EAAAA,SAAS,CAAC,YAAY;AAClBgf,IAAAA,aAAa,CAAC7Z,KAAd,CAAoB,EAApB;AACA,WAAO,YAAY;AAAE,aAAO6Z,aAAa,CAAC5Z,OAAd,EAAP;AAAiC,KAAtD;AACH,GAHQ,EAGN,EAHM,CAAT;AAIA,MAAIuS,cAAc,GAAG0D,WAAW,CAAC,YAAY;AAAE,WAAO,UAAUwO,mBAAV,EAA+B;AACjF,aAAO7F,QAAQ,CAACrgB,KAAT,CAAekmB,mBAAf,CAAP;AACH,KAF8C;AAE3C,GAF4B,CAAhC;AAGA,SAAO,CAACohB,cAAD,EAAiBtzB,cAAjB,CAAP;AACH;;AAED,SAAS6pB,eAAT,EAA0BkD,mBAA1B,EAA+ChhB,iBAA/C,EAAkEgnB,YAAlE,EAAgFnmB,aAAhF,EAA+FsH,mBAA/F,EAAoHE,aAApH,EAAmI5qB,WAAnI,EAAgJ8c,eAAhJ,EAAiKusB,aAAjK,EAAgLljB,8BAAhL,EAAgNlX,kBAAhN,EAAoOkU,iBAApO,EAAuPgM,qBAAvP,EAA8QlR,iBAA9Q,EAAiS+gB,CAAjS,EAAoSvZ,MAApS,EAA4SviB,WAA5S,EAAyTohC,kBAAzT,EAA6U78B,SAA7U,EAAwVoiC,gBAAxV,EAA0WxB,YAA1W,EAAwXC,QAAxX,EAAkYzX,WAAlY,EAA+Y6Y,eAA/Y,EAAgarC,gBAAha,EAAkbsC,cAAlb,EAAkcpN,WAAlc,EAA+coJ,gBAA/c,EAAiepoB,YAAje,EAA+e8mB,cAA/e,EAA+f1J,aAA/f,EAA8gB5d,WAA9gB,EAA2hBmsB,gBAA3hB,EAA6iBnD,SAA7iB,EAAwjBvK,aAAxjB,EAAukB4J,YAAvkB,EAAqlBgD,iBAArlB","sourcesContent":["import { __assign, __spreadArrays, __rest, __extends } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, mix, clamp, distance, progress, linear as linear$1, circOut, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\nimport React__default, { useRef, createContext, useContext, useEffect, createElement, useMemo, forwardRef, Fragment, Component, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\n\nvar isRefObject = function (ref) {\n    return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            if (_this.updateSubscribers && _this.prev !== _this.current) {\n                _this.updateSubscribers.forEach(_this.notifySubscriber);\n            }\n            if (render && _this.renderSubscribers) {\n                _this.renderSubscribers.forEach(_this.notifySubscriber);\n            }\n            // Update timestamp\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync.postRender(_this.scheduleVelocityCheck);\n            }\n        };\n        /**\n         * Notify a subscriber with the latest value.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @param subscriber - The subscriber to notify.\n         *\n         * @internal\n         */\n        this.notifySubscriber = function (subscriber) {\n            subscriber(_this.current);\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n            }\n        };\n        this.set(init, false);\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Subscribes a subscriber function to a subscription list.\n     *\n     * @param subscriptions - A `Set` of subscribers.\n     * @param subscription - A subscriber function.\n     */\n    MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n        var _this = this;\n        var updateSubscriber = function () { return subscription(_this.current); };\n        subscriptions.add(updateSubscriber);\n        return function () { return subscriptions.delete(updateSubscriber); };\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @library\n     *\n     * ```jsx\n     * function MyComponent() {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <Frame x={x} />\n     * }\n     * ```\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        if (!this.updateSubscribers)\n            this.updateSubscribers = new Set();\n        return this.subscribeTo(this.updateSubscribers, subscription);\n    };\n    MotionValue.prototype.clearListeners = function () {\n        var _a;\n        (_a = this.updateSubscribers) === null || _a === void 0 ? void 0 : _a.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        if (!this.renderSubscribers)\n            this.renderSubscribers = new Set();\n        // Render immediately\n        this.notifySubscriber(subscription);\n        return this.subscribeTo(this.renderSubscribers, subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers && this.updateSubscribers.clear();\n        this.renderSubscribers && this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n/**\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\n * underlying renderer.\n *\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\n * VisualElement and we can quickly offer all the same features.\n */\nvar VisualElement = /** @class */ (function () {\n    function VisualElement(parent, ref) {\n        var _this = this;\n        // An iterable list of current children\n        this.children = new Set();\n        // The latest resolved MotionValues\n        this.latest = {};\n        // A map of MotionValues used to animate this element\n        this.values = new Map();\n        // Unsubscription callbacks for each MotionValue\n        this.valueSubscriptions = new Map();\n        // A configuration for this VisualElement, each derived class can extend this.\n        this.config = {};\n        // A pre-bound call to the user-provided `onUpdate` callback. This won't\n        // be called more than once per frame.\n        this.update = function () { return _this.config.onUpdate(_this.latest); };\n        // Pre-bound version of render\n        this.triggerRender = function () { return _this.render(); };\n        this.scheduleRender = function () { return sync.render(_this.triggerRender, false, true); };\n        // This function gets passed to the rendered component's `ref` prop\n        // and is used to mount/unmount the VisualElement\n        this.ref = function (element) {\n            element ? _this.mount(element) : _this.unmount();\n            if (!_this.externalRef)\n                return;\n            if (typeof _this.externalRef === \"function\") {\n                _this.externalRef(element);\n            }\n            else if (isRefObject(_this.externalRef)) {\n                _this.externalRef.current = element;\n            }\n        };\n        // Create a relationship with the provided parent.\n        this.parent = parent;\n        this.rootParent = parent ? parent.rootParent : this;\n        this.treePath = parent ? __spreadArrays(parent.treePath, [parent]) : [];\n        // Calculate the depth of this node in the VisualElement graph\n        this.depth = parent ? parent.depth + 1 : 0;\n        // A reference to any externally-defined React ref. This might live better\n        // outside the VisualElement and be handled in a hook.\n        this.externalRef = ref;\n    }\n    VisualElement.prototype.subscribe = function (child) {\n        var _this = this;\n        this.children.add(child);\n        return function () { return _this.children.delete(child); };\n    };\n    // Check whether this element has a MotionValue of the provided key\n    VisualElement.prototype.hasValue = function (key) {\n        return this.values.has(key);\n    };\n    // Add a MotionValue\n    VisualElement.prototype.addValue = function (key, value) {\n        if (this.hasValue(key))\n            this.removeValue(key);\n        this.values.set(key, value);\n        this.latest[key] = value.get();\n        if (this.element)\n            this.subscribeToValue(key, value);\n    };\n    // Remove a MotionValue\n    VisualElement.prototype.removeValue = function (key) {\n        var unsubscribe = this.valueSubscriptions.get(key);\n        unsubscribe && unsubscribe();\n        this.values.delete(key);\n        delete this.latest[key];\n        this.valueSubscriptions.delete(key);\n    };\n    VisualElement.prototype.getValue = function (key, defaultValue) {\n        var value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = new MotionValue(defaultValue);\n            this.addValue(key, value);\n        }\n        return value;\n    };\n    // Iterate over all MotionValues\n    VisualElement.prototype.forEachValue = function (callback) {\n        this.values.forEach(callback);\n    };\n    // Get the underlying rendered instance of this VisualElement. For instance in\n    // HTMLVisualElement this will be a HTMLElement.\n    VisualElement.prototype.getInstance = function () {\n        return this.element;\n    };\n    VisualElement.prototype.updateConfig = function (config) {\n        if (config === void 0) { config = {}; }\n        this.config = __assign({}, config);\n    };\n    // Set a single `latest` value\n    VisualElement.prototype.setSingleStaticValue = function (key, value) {\n        this.latest[key] = value;\n    };\n    // Statically set values to `latest` without needing a MotionValue\n    VisualElement.prototype.setStaticValues = function (values, value) {\n        if (typeof values === \"string\") {\n            this.setSingleStaticValue(values, value);\n        }\n        else {\n            for (var key in values) {\n                this.setSingleStaticValue(key, values[key]);\n            }\n        }\n    };\n    VisualElement.prototype.scheduleUpdateLayoutDelta = function () {\n        sync.update(this.rootParent.updateLayoutDelta, false, true);\n    };\n    // Subscribe to changes in a MotionValue\n    VisualElement.prototype.subscribeToValue = function (key, value) {\n        var _this = this;\n        var onChange = function (latest) {\n            _this.setSingleStaticValue(key, latest);\n            _this.latest[key] = latest;\n            _this.config.onUpdate && sync.update(_this.update, false, true);\n        };\n        var unsubscribeOnChange = value.onChange(onChange);\n        var unsubscribeOnRender = value.onRenderRequest(this.scheduleRender);\n        this.valueSubscriptions.set(key, function () {\n            unsubscribeOnChange();\n            unsubscribeOnRender();\n        });\n    };\n    // Mount the VisualElement with the actual DOM element\n    VisualElement.prototype.mount = function (element) {\n        var _this = this;\n        invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n        if (this.parent) {\n            this.removeFromParent = this.parent.subscribe(this);\n        }\n        /**\n         * Save the element to this.element as a semantic API, this.current to the VisualElement\n         * is compatible with existing RefObject APIs.\n         */\n        this.element = this.current = element;\n        // Subscribe to any pre-existing MotionValues\n        this.forEachValue(function (value, key) { return _this.subscribeToValue(key, value); });\n    };\n    // Unmount the VisualElement and cancel any scheduled updates\n    VisualElement.prototype.unmount = function () {\n        var _this = this;\n        this.forEachValue(function (_, key) { return _this.removeValue(key); });\n        cancelSync.update(this.update);\n        cancelSync.render(this.render);\n        this.removeFromParent && this.removeFromParent();\n    };\n    return VisualElement;\n}());\n\nfunction noop(any) {\n    return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n    return {\n        x: __assign({}, box.x),\n        y: __assign({}, box.y),\n    };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\nfunction delta() {\n    return {\n        x: __assign({}, zeroDelta),\n        y: __assign({}, zeroDelta),\n    };\n}\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n    test: function (v) { return v === \"auto\"; },\n    parse: function (v) { return v; },\n};\n/**\n * ValueType for ints\n */\nvar int = __assign(__assign({}, number), { transform: Math.round });\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = {\n    // Color props\n    color: color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    axes.forEach(function (axesKey) { return transformProps.push(operationKey + axesKey); });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n    if (enableHardwareAcceleration === void 0) { enableHardwareAcceleration = true; }\n    if (allowTransformNone === void 0) { allowTransformNone = true; }\n    // The transform string we're going to build into\n    var transformString = \"\";\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        if (key === \"z\")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable(key) {\n    return key.startsWith(\"--\");\n}\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, viewportBox) {\n    /**\n     * If latest is a string, we either presume it's already a percentage, in which case it'll\n     * already be stretched appropriately, or it's another value type which we don't support.\n     */\n    if (typeof latest !== \"number\")\n        return latest;\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, viewportBox.x);\n    var y = pixelsToPercent(latest, viewportBox.y);\n    return x + \"% \" + y + \"%\";\n}\nfunction correctBoxShadow(latest, _viewportBox, delta, treeScale) {\n    // GC Warning - this creates a function and object every frame\n    var shadow = complex.parse(latest);\n    var template = complex.createTransformer(latest);\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    // Scale x/y\n    shadow[1] /= xScale;\n    shadow[2] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[3] === \"number\")\n        shadow[3] /= averageScale;\n    // Spread\n    if (typeof shadow[4] === \"number\")\n        shadow[4] /= averageScale;\n    return template(shadow);\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar valueScaleCorrection = {\n    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n/**\n * @internal\n */\nfunction addScaleCorrection(correctors) {\n    for (var key in correctors) {\n        valueScaleCorrection[key] = correctors[key];\n    }\n}\n\nfunction createDeltaTransform(delta, treeScale) {\n    var x = delta.x.translate / treeScale.x;\n    var y = delta.y.translate / treeScale.y;\n    var scaleX = delta.x.scale;\n    var scaleY = delta.y.scale;\n    return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scaleX + \", \" + scaleY + \")\";\n}\n\n/**\n * Build style and CSS variables\n *\n * This function converts a Motion style prop:\n *\n * { x: 100, width: 100, originX: 0.5 }\n *\n * Into an object with default value types applied and default\n * transform order set:\n *\n * {\n *   transform: 'translateX(100px) translateZ(0)`,\n *   width: '100px',\n *   transformOrigin: '50% 50%'\n * }\n *\n * Styles are saved to `style` and CSS vars to `vars`.\n *\n * This function works with mutative data structures.\n */\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a, isLayoutProjectionEnabled, delta, deltaFinal, treeScale, targetBox) {\n    var enableHardwareAcceleration = _a.enableHardwareAcceleration, transformTemplate = _a.transformTemplate, allowTransformNone = _a.allowTransformNone;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = !!isLayoutProjectionEnabled;\n    var hasTransformOrigin = !!isLayoutProjectionEnabled;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable. Transforms and transform origins are kept seperately\n     * for further processing\n     */\n    for (var key in latest) {\n        var value = latest[key];\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = getDefaultValueType(key);\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag and enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            if (!transformIsNone)\n                continue;\n            // If all the transform keys we've so far encountered are their default value\n            // then check to see if this one isn't\n            var defaultValue = valueType.default !== undefined ? valueType.default : 0;\n            if (value !== defaultValue)\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            // If this is a transform origin, flag and enable further transform-origin processing\n            transformOrigin[key] = valueAsType;\n            hasTransformOrigin = true;\n        }\n        else if (key !== \"transform\" || typeof value !== \"function\") {\n            // Handle all remaining values. Decide which map to save to depending\n            // on whether this is a CSS variable\n            var bucket = isCSSVariable(key) ? vars : style;\n            // If we need to perform scale correction, and we have a handler for this\n            // value type (ie borderRadius), perform it\n            if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {\n                var corrected = valueScaleCorrection[key].process(value, targetBox, delta, treeScale);\n                /**\n                 * Scale-correctable values can define a number of other values to break\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n                 */\n                var applyTo = valueScaleCorrection[key].applyTo;\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        bucket[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    bucket[key] = corrected;\n                }\n            }\n            else {\n                bucket[key] = valueAsType;\n            }\n        }\n    }\n    // Only process transform if values aren't defaults\n    if (hasTransform || transformTemplate) {\n        if (!isLayoutProjectionEnabled) {\n            style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n        }\n        else {\n            style.transform = createDeltaTransform(deltaFinal, treeScale);\n            if (transformTemplate)\n                style.transform = transformTemplate(transform, style.transform);\n        }\n    }\n    // Only process transform origin if values aren't default\n    if (hasTransformOrigin) {\n        var originX = isLayoutProjectionEnabled\n            ? deltaFinal.x.origin * 100 + \"%\"\n            : transformOrigin.originX || \"50%\";\n        var originY = isLayoutProjectionEnabled\n            ? deltaFinal.y.origin * 100 + \"%\"\n            : transformOrigin.originY || \"50%\";\n        var originZ = transformOrigin.originZ || \"0\";\n        style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n    }\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n    var key = _a[0], scaleKey = _a[1], originKey = _a[2];\n    // Copy the current axis to the final axis before mutation\n    final.min = axis.min;\n    final.max = axis.max;\n    var originPoint = mix(axis.min, axis.max, transforms[originKey] || 0.5);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    var originPoint = mix(axis.min, axis.max, origin) - translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n    var key = _a[0], scaleKey = _a[1], originKey = _a[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n    removeAxisTransforms(box.x, transforms, xKeys);\n    removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within HTMLVisualElement.updateLayoutDelta\n */\nfunction applyTreeDeltas(box, treePath) {\n    var treeLength = treePath.length;\n    for (var i = 0; i < treeLength; i++) {\n        applyBoxDelta(box, treePath[i].delta);\n    }\n}\n\nvar clampProgress = clamp(0, 1);\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return distance(value, target) < maxDistance;\n}\n/**\n * Calculate the translate needed to be applied to source to get target\n */\nfunction calcTranslate(source, target, origin) {\n    var sourcePoint = mix(source.min, source.max, origin);\n    var targetPoint = mix(target.min, target.max, origin);\n    return targetPoint - sourcePoint;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = source.max - source.min;\n    var targetLength = target.max - target.min;\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    var sourceLength = source.max - source.min;\n    var targetLength = target.max - target.min;\n    delta.origin = origin === undefined ? calcOrigin(source, target) : origin;\n    delta.originPoint = mix(source.min, source.max, delta.origin);\n    delta.scale = targetLength / sourceLength;\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate = calcTranslate(source, target, delta.origin);\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, origin);\n    updateAxisDelta(delta.y, source.y, target.y, origin);\n}\n/**\n * Update the treeScale by incorporating the parent's latest scale into its treeScale.\n */\nfunction updateTreeScale(treeScale, parentTreeScale, parentDelta) {\n    treeScale.x = parentTreeScale.x * parentDelta.x.scale;\n    treeScale.y = parentTreeScale.y * parentDelta.y.scale;\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar overDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35,\n}); };\nvar linearTween = function () { return ({\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: overDampedSpring,\n    scaleY: overDampedSpring,\n    scale: overDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: overDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return __assign({ to: to }, transitionFactory(to));\n};\n\n/**\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\n * updates with `to` and then completes. By using this we can compose instant transitions\n * in with the same logic that applies `delay` or returns a `Promise` etc.\n *\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\n * the animation until after the duration finishes. This is for situations when you're **only**\n * animating non-animatable values and then setting something on `transitionEnd`. Really\n * you want this to fire after the \"animation\" finishes, rather than instantly.\n *\n * ```\n * animate={{\n *   display: 'block',\n *   transitionEnd: { display: 'none' }\n * }}\n * ```\n */\nvar just = function (_a) {\n    var to = _a.to, duration = _a.duration;\n    return action(function (_a) {\n        var update = _a.update, complete = _a.complete;\n        update(to);\n        duration ? delay(duration).start({ complete: complete }) : complete();\n    });\n};\n\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var x1 = definition[0], y1 = definition[1], x2 = definition[2], y2 = definition[3];\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function (v) {\n    return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar transitions = { tween: tween, spring: spring, keyframes: keyframes$1, inertia: inertia, just: just };\nvar transitionOptionParser = {\n    tween: function (opts) {\n        if (opts.ease) {\n            var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n            opts.ease = easingDefinitionToFunction(ease);\n        }\n        return opts;\n    },\n    keyframes: function (_a) {\n        var from = _a.from, to = _a.to, velocity = _a.velocity, opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n        if (opts.values && opts.values[0] === null) {\n            var values = __spreadArrays(opts.values);\n            values[0] = from;\n            opts.values = values;\n        }\n        if (opts.ease) {\n            opts.easings = isEasingArray(opts.ease)\n                ? opts.ease.map(easingDefinitionToFunction)\n                : easingDefinitionToFunction(opts.ease);\n        }\n        opts.ease = linear;\n        return opts;\n    },\n};\nvar isTransitionDefined = function (_a) {\n    var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n    return Object.keys(transition).length;\n};\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\n    var delay = transitionDefinition ? transitionDefinition.delay : 0;\n    // If no object, return default transition\n    // A better way to handle this would be to deconstruct out all the shared Orchestration props\n    // and see if there's any props remaining\n    if (transitionDefinition === undefined ||\n        !isTransitionDefined(transitionDefinition)) {\n        return __assign({ delay: delay }, getDefaultTransition(key, to));\n    }\n    var valueTransitionDefinition = transitionDefinition[key] ||\n        transitionDefinition.default ||\n        transitionDefinition;\n    if (valueTransitionDefinition.type === false) {\n        return {\n            delay: valueTransitionDefinition.hasOwnProperty(\"delay\")\n                ? valueTransitionDefinition.delay\n                : delay,\n            to: isKeyframesTarget(to)\n                ? to[to.length - 1]\n                : to,\n            type: \"just\",\n        };\n    }\n    else if (isKeyframesTarget(to)) {\n        return __assign(__assign({ values: to, duration: 0.8, delay: delay, ease: \"linear\" }, valueTransitionDefinition), { \n            // This animation must be keyframes if we're animating through an array\n            type: \"keyframes\" });\n    }\n    else {\n        return __assign({ type: \"tween\", to: to,\n            delay: delay }, valueTransitionDefinition);\n    }\n};\nvar preprocessOptions = function (type, opts) {\n    return transitionOptionParser[type]\n        ? transitionOptionParser[type](opts)\n        : opts;\n};\nvar getAnimation = function (key, value, target, transition) {\n    var origin = value.get();\n    var isOriginAnimatable = isAnimatable(key, origin);\n    var isTargetAnimatable = isAnimatable(key, target);\n    // TODO we could probably improve this check to ensure both values are of the same type -\n    // for instance 100 to #fff. This might live better in Popmotion.\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    // Parse the `transition` prop and return options for the Popmotion animation\n    var _a = getTransitionDefinition(key, target, transition), _b = _a.type, type = _b === void 0 ? \"tween\" : _b, transitionDefinition = __rest(_a, [\"type\"]);\n    // If this is an animatable pair of values, return an animation, otherwise use `just`\n    var actionFactory = isOriginAnimatable && isTargetAnimatable\n        ? transitions[type]\n        : just;\n    var opts = preprocessOptions(type, __assign({ from: origin, velocity: value.getVelocity() }, transitionDefinition));\n    // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n    if (isDurationAnimation(opts)) {\n        if (opts.duration) {\n            opts.duration = secondsToMilliseconds(opts.duration);\n        }\n        if (opts.repeatDelay) {\n            opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n        }\n    }\n    return [actionFactory, opts];\n};\n/**\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\n *\n * @internal\n */\nfunction startAnimation(key, value, target, _a) {\n    if (_a === void 0) { _a = {}; }\n    var _b = _a.delay, delay$1 = _b === void 0 ? 0 : _b, transition = __rest(_a, [\"delay\"]);\n    return value.start(function (complete) {\n        var activeAnimation;\n        var _a = getAnimation(key, value, target, transition), animationFactory = _a[0], _b = _a[1], valueDelay = _b.delay, options = __rest(_b, [\"delay\"]);\n        if (valueDelay !== undefined) {\n            delay$1 = valueDelay;\n        }\n        var animate = function () {\n            var animation = animationFactory(options);\n            // Bind animation opts to animation\n            activeAnimation = animation.start({\n                update: function (v) { return value.set(v); },\n                complete: complete,\n            });\n        };\n        // If we're delaying this animation, only resolve it **after** the delay to\n        // ensure the value's resolve velocity is up-to-date.\n        if (delay$1) {\n            activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n                complete: animate,\n            });\n        }\n        else {\n            animate();\n        }\n        return function () {\n            if (activeAnimation)\n                activeAnimation.stop();\n        };\n    });\n}\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n    var box = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\n/**\n * A VisualElement for HTMLElements\n */\nvar HTMLVisualElement = /** @class */ (function (_super) {\n    __extends(HTMLVisualElement, _super);\n    function HTMLVisualElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         *\n         */\n        _this.defaultConfig = {\n            enableHardwareAcceleration: true,\n            allowTransformNone: true,\n        };\n        /**\n         * A mutable record of styles we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.style = {};\n        /**\n         * A record of styles we only want to apply via React. This gets set in useMotionValues\n         * and applied in the render function. I'd prefer this to live somewhere else to decouple\n         * VisualElement from React but works for now.\n         */\n        _this.reactStyle = {};\n        /**\n         * A mutable record of CSS variables we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.vars = {};\n        /**\n         * A mutable record of transforms we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.transform = {};\n        /**\n         * A mutable record of transform origins we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.transformOrigin = {};\n        /**\n         * A mutable record of transform keys we want to apply to the rendered Element. We order\n         * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.transformKeys = [];\n        _this.config = _this.defaultConfig;\n        /**\n         * ========================================\n         * Layout\n         * ========================================\n         */\n        _this.isLayoutProjectionEnabled = false;\n        /**\n         * A set of layout update event handlers. These are only called once all layouts have been read,\n         * making it safe to perform DOM write operations.\n         */\n        _this.layoutUpdateListeners = new Set();\n        /**\n         * Keep track of whether the viewport box has been updated since the last render.\n         * If it has, we want to fire the onViewportBoxUpdate listener.\n         */\n        _this.hasViewportBoxUpdated = false;\n        /**\n         * The visual target we want to project our component into on a given frame\n         * before applying transforms defined in `animate` or `style`.\n         *\n         * This is considered mutable to avoid object creation on each frame.\n         */\n        _this.targetBoxFinal = axisBox();\n        /**\n         * The overall scale of the local coordinate system as transformed by all parents\n         * of this component. We use this for scale correction on our calculated layouts\n         * and scale-affected values like `boxShadow`.\n         *\n         * This is considered mutable to avoid object creation on each frame.\n         */\n        _this.treeScale = { x: 1, y: 1 };\n        /**\n         * The delta between the boxCorrected and the desired\n         * targetBox (before user-set transforms are applied). The calculated output will be\n         * handed to the renderer and used as part of the style correction calculations, for\n         * instance calculating how to display the desired border-radius correctly.\n         *\n         * This is considered mutable to avoid object creation on each frame.\n         */\n        _this.delta = delta();\n        /**\n         * The delta between the boxCorrected and the desired targetBoxFinal. The calculated\n         * output will be handed to the renderer and used to project the boxCorrected into\n         * the targetBoxFinal.\n         *\n         * This is considered mutable to avoid object creation on each frame.\n         */\n        _this.deltaFinal = delta();\n        /**\n         *\n         */\n        _this.stopLayoutAxisAnimation = {\n            x: function () { },\n            y: function () { },\n        };\n        _this.isTargetBoxLocked = false;\n        /**\n         *\n         */\n        _this.axisProgress = {\n            x: motionValue(0),\n            y: motionValue(0),\n        };\n        _this.updateLayoutDelta = function () {\n            _this.isLayoutProjectionEnabled && _this.box && _this.updateDeltas();\n            /**\n             * Ensure all children layouts are also updated.\n             *\n             * This uses a pre-bound function executor rather than a lamda to avoid creating a new function\n             * multiple times per frame (source of mid-animation GC)\n             */\n            _this.children.forEach(fireUpdateLayoutDelta);\n        };\n        return _this;\n    }\n    /**\n     * When a value is removed, we want to make sure it's removed from all rendered data structures.\n     */\n    HTMLVisualElement.prototype.removeValue = function (key) {\n        _super.prototype.removeValue.call(this, key);\n        delete this.vars[key];\n        delete this.style[key];\n    };\n    /**\n     * Empty the mutable data structures by re-creating them. We can do this every React render\n     * as the comparative workload to the rest of the render is very low and this is also when\n     * we want to reflect values that might have been removed by the render.\n     */\n    HTMLVisualElement.prototype.clean = function () {\n        this.style = {};\n        this.vars = {};\n        this.transform = {};\n    };\n    HTMLVisualElement.prototype.updateConfig = function (config) {\n        if (config === void 0) { config = {}; }\n        this.config = __assign(__assign({}, this.defaultConfig), config);\n    };\n    /**\n     * Read a value directly from the HTMLElement style.\n     */\n    HTMLVisualElement.prototype.read = function (key) {\n        return this.getComputedStyle()[key] || 0;\n    };\n    /**\n     * Read a value directly from the HTMLElement in case it's not defined by a Motion\n     * prop. If it's a transform, we just return a pre-defined default value as reading these\n     * out of a matrix is either error-prone or can incur a big payload for little benefit.\n     */\n    HTMLVisualElement.prototype.readNativeValue = function (key) {\n        if (isTransformProp(key)) {\n            var defaultValueType = getDefaultValueType(key);\n            return defaultValueType ? defaultValueType.default || 0 : 0;\n        }\n        else {\n            return this.read(key);\n        }\n    };\n    HTMLVisualElement.prototype.enableLayoutProjection = function () {\n        this.isLayoutProjectionEnabled = true;\n    };\n    HTMLVisualElement.prototype.hide = function () {\n        if (this.isVisible === false)\n            return;\n        this.isVisible = false;\n        this.scheduleRender();\n    };\n    HTMLVisualElement.prototype.show = function () {\n        if (this.isVisible === true)\n            return;\n        this.isVisible = true;\n        this.scheduleRender();\n    };\n    /**\n     * Register an event listener to fire when the layout is updated. We might want to expose support\n     * for this via a `motion` prop.\n     */\n    HTMLVisualElement.prototype.onLayoutUpdate = function (callback) {\n        var _this = this;\n        this.layoutUpdateListeners.add(callback);\n        return function () { return _this.layoutUpdateListeners.delete(callback); };\n    };\n    /**\n     * To be called when all layouts are successfully updated. In turn we can notify layoutUpdate\n     * subscribers.\n     */\n    HTMLVisualElement.prototype.layoutReady = function (config) {\n        var _this = this;\n        this.layoutUpdateListeners.forEach(function (listener) {\n            listener(_this.box, _this.prevViewportBox || _this.box, config);\n        });\n    };\n    /**\n     * Measure and return the Element's bounding box. We convert it to a AxisBox2D\n     * structure to make it easier to work on each individual axis generically.\n     */\n    HTMLVisualElement.prototype.getBoundingBox = function () {\n        var transformPagePoint = this.config.transformPagePoint;\n        return getBoundingBox(this.element, transformPagePoint);\n    };\n    HTMLVisualElement.prototype.getBoundingBoxWithoutTransforms = function () {\n        var bbox = this.getBoundingBox();\n        removeBoxTransforms(bbox, this.latest);\n        return bbox;\n    };\n    /**\n     * Return the computed style after a render.\n     */\n    HTMLVisualElement.prototype.getComputedStyle = function () {\n        return window.getComputedStyle(this.element);\n    };\n    /**\n     *\n     */\n    HTMLVisualElement.prototype.snapshotBoundingBox = function () {\n        this.prevViewportBox = this.getBoundingBoxWithoutTransforms();\n        /**\n         * Update targetBox to match the prevViewportBox. This is just to ensure\n         * that targetBox is affected by scroll in the same way as the measured box\n         */\n        var _a = this.axisProgress, x = _a.x, y = _a.y;\n        if (!this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating()) {\n            this.targetBox = copyAxisBox(this.prevViewportBox);\n        }\n    };\n    HTMLVisualElement.prototype.measureLayout = function () {\n        this.box = this.getBoundingBox();\n        this.boxCorrected = copyAxisBox(this.box);\n        if (!this.targetBox)\n            this.targetBox = copyAxisBox(this.box);\n    };\n    /**\n     * Ensure the targetBox reflects the latest visual box on screen\n     */\n    HTMLVisualElement.prototype.refreshTargetBox = function () {\n        this.targetBox = this.getBoundingBoxWithoutTransforms();\n    };\n    HTMLVisualElement.prototype.lockTargetBox = function () {\n        this.isTargetBoxLocked = true;\n    };\n    HTMLVisualElement.prototype.unlockTargetBox = function () {\n        this.stopLayoutAnimation();\n        this.isTargetBoxLocked = false;\n    };\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    HTMLVisualElement.prototype.resetTransform = function () {\n        var transformTemplate = this.config.transformTemplate;\n        this.element.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform\n        this.scheduleRender();\n    };\n    /**\n     * Set new min/max boundaries to project an axis into\n     */\n    HTMLVisualElement.prototype.setAxisTarget = function (axis, min, max) {\n        var targetAxis = this.targetBox[axis];\n        targetAxis.min = min;\n        targetAxis.max = max;\n        // Flag that we want to fire the onViewportBoxUpdate event handler\n        this.hasViewportBoxUpdated = true;\n        this.rootParent.scheduleUpdateLayoutDelta();\n    };\n    /**\n     *\n     */\n    HTMLVisualElement.prototype.startLayoutAxisAnimation = function (axis, transition) {\n        var _this = this;\n        var progress = this.axisProgress[axis];\n        var _a = this.targetBox[axis], min = _a.min, max = _a.max;\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n        progress.onChange(function (v) { return _this.setAxisTarget(axis, v, v + length); });\n        return startAnimation(axis, progress, 0, transition);\n    };\n    HTMLVisualElement.prototype.stopLayoutAnimation = function () {\n        var _this = this;\n        eachAxis(function (axis) { return _this.axisProgress[axis].stop(); });\n    };\n    /**\n     * Update the layout deltas to reflect the relative positions of the layout\n     * and the desired target box\n     */\n    HTMLVisualElement.prototype.updateDeltas = function () {\n        var _a, _b;\n        /**\n         * Reset the corrected box with the latest values from box, as we're then going\n         * to perform mutative operations on it.\n         */\n        resetBox(this.boxCorrected, this.box);\n        /**\n         * If this component has a parent, update this treeScale by incorporating the parent's\n         * delta into its treeScale.\n         */\n        if (this.parent) {\n            updateTreeScale(this.treeScale, this.parent.treeScale, this.parent.delta);\n        }\n        /**\n         * Apply all the parent deltas to this box to produce the corrected box. This\n         * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n         */\n        applyTreeDeltas(this.boxCorrected, this.treePath);\n        /**\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n         * This is the final box that we will then project into by calculating a transform delta and\n         * applying it to the corrected box.\n         */\n        applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);\n        /**\n         * Update the delta between the corrected box and the target box before user-set transforms were applied.\n         * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n         * for our layout reprojection, but still allow them to be scaled correctly by the user.\n         * It might be that to simplify this we may want to accept that user-set scale is also corrected\n         * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n         * to allow people to choose whether these styles are corrected based on just the\n         * layout reprojection or the final bounding box.\n         */\n        updateBoxDelta(this.delta, this.boxCorrected, this.targetBox);\n        /**\n         * Update the delta between the corrected box and the final target box, after\n         * user-set transforms are applied to it. This will be used by the renderer to\n         * create a transform style that will reproject the element from its actual layout\n         * into the desired bounding box.\n         */\n        updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal);\n        /**\n         * If we have a listener for the viewport box, fire it.\n         */\n        this.hasViewportBoxUpdated && ((_b = (_a = this.config).onViewportBoxUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, this.targetBox, this.delta));\n        this.hasViewportBoxUpdated = false;\n        /**\n         * Ensure this element renders on the next frame if the projection transform has changed.\n         */\n        var deltaTransform = createDeltaTransform(this.deltaFinal, this.treeScale);\n        deltaTransform !== this.deltaTransform && this.scheduleRender();\n        this.deltaTransform = deltaTransform;\n    };\n    /**\n     * ========================================\n     * Build & render\n     * ========================================\n     */\n    /**\n     * Build a style prop using the latest resolved MotionValues\n     */\n    HTMLVisualElement.prototype.build = function () {\n        if (this.isVisible !== undefined) {\n            this.style.visibility = this.isVisible ? \"visible\" : \"hidden\";\n        }\n        buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);\n    };\n    /**\n     * Render the Element by rebuilding and applying the latest styles and vars.\n     */\n    HTMLVisualElement.prototype.render = function () {\n        // Rebuild the latest animated values into style and vars caches.\n        this.build();\n        // Directly assign style into the Element's style prop. In tests Object.assign is the\n        // fastest way to assign styles.\n        Object.assign(this.element.style, this.style);\n        // Loop over any CSS variables and assign those.\n        for (var key in this.vars) {\n            this.element.style.setProperty(key, this.vars[key]);\n        }\n    };\n    return HTMLVisualElement;\n}(VisualElement));\n/**\n * Pre-bound version of updateLayoutDelta so we're not creating a new function multiple\n * times per frame.\n */\nvar fireUpdateLayoutDelta = function (child) {\n    return child.updateLayoutDelta();\n};\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n    return px.transform(progress * length);\n};\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\n    // Build the dash array\n    var pathLength = progressToPixels(length, totalLength);\n    var pathSpacing = progressToPixels(spacing, totalLength);\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = { x: 0, y: 0, width: 0, height: 0 };\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    /**\n     * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\n     */\n    buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (originX !== undefined || originY !== undefined || style.transform) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been measured\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n    }\n    return attrs;\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n]);\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\n/**\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\n * share data structures.\n */\nvar SVGVisualElement = /** @class */ (function (_super) {\n    __extends(SVGVisualElement, _super);\n    function SVGVisualElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable record of attributes we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.attrs = {};\n        /**\n         * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\n         */\n        _this.defaultConfig = {\n            enableHardwareAcceleration: false,\n        };\n        /**\n         * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\n         * being assigned to config\n         */\n        _this.config = _this.defaultConfig;\n        return _this;\n    }\n    /**\n     * Measure the SVG element on mount. This can affect page rendering so there might be a\n     * better time to perform this - for instance dynamically only if there's a transform-origin dependent\n     * transform being set (like rotate)\n     */\n    SVGVisualElement.prototype.mount = function (element) {\n        _super.prototype.mount.call(this, element);\n        this.measure();\n    };\n    /**\n     * Update the SVG dimensions and path length\n     */\n    SVGVisualElement.prototype.measure = function () {\n        try {\n            this.dimensions =\n                typeof this.element.getBBox ===\n                    \"function\"\n                    ? this.element.getBBox()\n                    : this.element.getBoundingClientRect();\n        }\n        catch (e) {\n            // Most likely trying to measure an unrendered element under Firefox\n            this.dimensions = { x: 0, y: 0, width: 0, height: 0 };\n        }\n        if (isPath(this.element)) {\n            this.totalPathLength = this.element.getTotalLength();\n        }\n    };\n    /**\n     * Empty the mutable data structures in case attrs have been removed between renders.\n     */\n    SVGVisualElement.prototype.clean = function () {\n        _super.prototype.clean.call(this);\n        this.attrs = {};\n    };\n    /**\n     * Read an attribute directly from the SVGElement\n     */\n    SVGVisualElement.prototype.read = function (key) {\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return this.element.getAttribute(key);\n    };\n    SVGVisualElement.prototype.build = function () {\n        buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n    };\n    SVGVisualElement.prototype.render = function () {\n        // Update HTML styles and CSS variables\n        _super.prototype.render.call(this);\n        // Loop through attributes and apply them to the SVGElement\n        for (var key in this.attrs) {\n            this.element.setAttribute(camelToDash(key), this.attrs[key]);\n        }\n    };\n    return SVGVisualElement;\n}(HTMLVisualElement));\nfunction isPath(element) {\n    return element.tagName === \"path\";\n}\n\n/**\n * @internal\n */\n/**\n * @internal\n */\nvar svgElements = [\n    \"animate\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\",\n    \"filter\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textPath\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nvar svgTagNames = new Set(svgElements);\n/**\n * Determine whether this is a HTML or SVG component based on if the provided\n * Component is a string and a recognised SVG tag. A potentially better way to\n * do this would be to offer a `motion.customSVG` function and determine this\n * when we generate the `motion.circle` etc components.\n */\nfunction isSVGComponent(Component) {\n    return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n\n/**\n * @public\n */\nvar PresenceContext = createContext(null);\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useOpaqueId when released in React\n    var id = useUniqueId();\n    useEffect(function () { return register(id); }, []);\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * @public\n */\nfunction useIsPresent() {\n    var context = useContext(PresenceContext);\n    return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useUniqueId = function () { return useConstant(incrementId); };\n\n/**\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\n * or SVGVisualElement for the component.\n */\nvar useDomVisualElement = function (Component, props, parent, isStatic, ref) {\n    var visualElement = useConstant(function () {\n        var DOMVisualElement = isSVGComponent(Component)\n            ? SVGVisualElement\n            : HTMLVisualElement;\n        return new DOMVisualElement(parent, ref);\n    });\n    visualElement.updateConfig(__assign({ enableHardwareAcceleration: !isStatic }, props));\n    visualElement.layoutId = props.layoutId;\n    var isPresent = useIsPresent();\n    visualElement.isPresent =\n        props.isPresent !== undefined ? props.isPresent : isPresent;\n    return visualElement;\n};\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"static\",\n    \"layout\",\n    \"layoutId\",\n    \"onLayoutAnimationComplete\",\n    \"onViewportBoxUpdate\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"whileHover\",\n    \"whileTap\",\n    \"onHoverEnd\",\n    \"onHoverStart\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\nvar isPropValid = function (key) { return !isValidMotionProp(key); };\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n    isPropValid = function (key) {\n        // Handle events explicitly as Emotion validates them all as true\n        if (key.startsWith(\"on\")) {\n            return !isValidMotionProp(key);\n        }\n        else {\n            return emotionIsPropValid_1(key);\n        }\n    };\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props) {\n    var domProps = {};\n    for (var key in props) {\n        if (isPropValid(key))\n            domProps[key] = props[key];\n    }\n    return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n    var drag = _a.drag;\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {\n        style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars),\n    };\n    if (!!drag) {\n        // Disable text selection\n        htmlProps.style.userSelect = \"none\";\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n    }\n    return htmlProps;\n}\n\n/**\n * Build React props for SVG elements\n */\nfunction buildSVGProps(visualElement) {\n    return __assign(__assign({}, visualElement.attrs), { style: __assign({}, visualElement.reactStyle) });\n}\n\nfunction render(Component, props, visualElement) {\n    // Only filter props from components we control, ie `motion.div`. If this\n    // is a custom component pass along everything provided to it.\n    var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n    /**\n     * Every render, empty and rebuild the animated values to be applied to our Element.\n     * During animation these data structures are used in a mutable fashion to reduce\n     * garbage collection, but between renders we can flush them to remove values\n     * that might have been taken out of the provided props.\n     */\n    visualElement.clean();\n    visualElement.build();\n    // Generate props to visually render this component\n    var visualProps = isSVGComponent(Component)\n        ? buildSVGProps(visualElement)\n        : buildHTMLProps(visualElement, props);\n    return createElement(Component, __assign(__assign(__assign({}, forwardedProps), { ref: visualElement.ref }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var token = match[1], fallback = match[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = parseCSSVariable(current), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved;\n    }\n    else if (isCSSVariable$1(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var target = __rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = __assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable$1(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable$1(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd && transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform)\n        return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n}; };\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a) {\n        var x = _a.x;\n        return x.max - x.min;\n    },\n    height: function (_a) {\n        var y = _a.y;\n        return y.max - y.min;\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.getBoundingBox();\n    var elementComputedStyle = visualElement.getComputedStyle();\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValues(\"display\", target.display || \"block\");\n    }\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    var targetBbox = visualElement.getBoundingBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = __assign({}, target);\n    transitionEnd = __assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var to = target[key];\n        var fromType = findDimensionValueType(from);\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n/**\n * Use callback either only on the initial render or on all renders. In concurrent mode\n * the \"initial\" render might run multiple times\n *\n * @param callback - Callback to run\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\n *\n * @public\n */\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n    if (isInitialOnly === void 0) { isInitialOnly = false; }\n    var isInitialRender = useRef(true);\n    if (!isInitialOnly || (isInitialOnly && isInitialRender.current)) {\n        callback();\n    }\n    isInitialRender.current = false;\n}\n\n/**\n * Control animations on one or more components.\n *\n * @public\n */\nvar AnimationControls = /** @class */ (function () {\n    function AnimationControls() {\n        /**\n         * Track whether the host component has mounted.\n         *\n         * @internal\n         */\n        this.hasMounted = false;\n        /**\n         * Pending animations that are started before a component is mounted.\n         *\n         * @internal\n         */\n        this.pendingAnimations = [];\n        /**\n         * A collection of linked component animation controls.\n         *\n         * @internal\n         */\n        this.componentControls = new Set();\n    }\n    /**\n     * Set variants on this and all child components.\n     *\n     * @param variants - The variants to set\n     *\n     * @internal\n     */\n    AnimationControls.prototype.setVariants = function (variants) {\n        this.variants = variants;\n        this.componentControls.forEach(function (controls) {\n            return controls.setVariants(variants);\n        });\n    };\n    /**\n     * Set a default transition on this and all child components\n     *\n     * @param transition - The default transition to set\n     *\n     * @internal\n     */\n    AnimationControls.prototype.setDefaultTransition = function (transition) {\n        this.defaultTransition = transition;\n        this.componentControls.forEach(function (controls) {\n            return controls.setDefaultTransition(transition);\n        });\n    };\n    /**\n     * Subscribes a component's animation controls to this.\n     *\n     * @param controls - The controls to subscribe\n     * @returns An unsubscribe function.\n     *\n     * @internal\n     */\n    AnimationControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        if (this.variants)\n            controls.setVariants(this.variants);\n        if (this.defaultTransition)\n            controls.setDefaultTransition(this.defaultTransition);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Starts an animation on all linked components.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * controls.start(\"variantLabel\")\n     * controls.start({\n     *   x: 0,\n     *   transition: { duration: 1 }\n     * })\n     * ```\n     *\n     * @param definition - Properties or variant label to animate to\n     * @param transition - Optional `transtion` to apply to a variant\n     * @returns - A `Promise` that resolves when all animations have completed.\n     *\n     * @public\n     */\n    AnimationControls.prototype.start = function (definition, transitionOverride) {\n        var _this = this;\n        if (this.hasMounted) {\n            var animations_1 = [];\n            this.componentControls.forEach(function (controls) {\n                var animation = controls.start(definition, {\n                    transitionOverride: transitionOverride,\n                });\n                animations_1.push(animation);\n            });\n            return Promise.all(animations_1);\n        }\n        else {\n            return new Promise(function (resolve) {\n                _this.pendingAnimations.push({\n                    animation: [definition, transitionOverride],\n                    resolve: resolve,\n                });\n            });\n        }\n    };\n    /**\n     * Instantly set to a set of properties or a variant.\n     *\n     * ```jsx\n     * // With properties\n     * controls.set({ opacity: 0 })\n     *\n     * // With variants\n     * controls.set(\"hidden\")\n     * ```\n     *\n     * @internalremarks\n     * We could perform a similar trick to `.start` where this can be called before mount\n     * and we maintain a list of of pending actions that get applied on mount. But the\n     * expectation of `set` is that it happens synchronously and this would be difficult\n     * to do before any children have even attached themselves. It's also poor practise\n     * and we should discourage render-synchronous `.start` calls rather than lean into this.\n     *\n     * @public\n     */\n    AnimationControls.prototype.set = function (definition) {\n        invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n        return this.componentControls.forEach(function (controls) {\n            return controls.apply(definition);\n        });\n    };\n    /**\n     * Stops animations on all linked components.\n     *\n     * ```jsx\n     * controls.stop()\n     * ```\n     *\n     * @public\n     */\n    AnimationControls.prototype.stop = function () {\n        this.componentControls.forEach(function (controls) { return controls.stop(); });\n    };\n    /**\n     * Initialises the animation controls.\n     *\n     * @internal\n     */\n    AnimationControls.prototype.mount = function () {\n        var _this = this;\n        this.hasMounted = true;\n        this.pendingAnimations.forEach(function (_a) {\n            var animation = _a.animation, resolve = _a.resolve;\n            return _this.start.apply(_this, animation).then(resolve);\n        });\n    };\n    /**\n     * Stops all child animations when the host component unmounts.\n     *\n     * @internal\n     */\n    AnimationControls.prototype.unmount = function () {\n        this.hasMounted = false;\n        this.stop();\n    };\n    return AnimationControls;\n}());\n/**\n * @internal\n */\nvar animationControls = function () { return new AnimationControls(); };\n\n/**\n * @internal\n */\nvar MotionContext = createContext({\n    static: false,\n});\nvar isVariantLabel = function (v) {\n    return typeof v === \"string\" || Array.isArray(v);\n};\nvar isAnimationControls = function (v) {\n    return v instanceof AnimationControls;\n};\n/**\n * Set up the context for children motion components.\n *\n * We also use this opportunity to apply `initial` values\n */\nvar useMotionContext = function (parentContext, controls, visualElement, isStatic, _a) {\n    if (isStatic === void 0) { isStatic = false; }\n    var initial = _a.initial, animate = _a.animate, variants = _a.variants, whileTap = _a.whileTap, whileHover = _a.whileHover, layoutId = _a.layoutId;\n    // Determine whether this is a root element of an AnimatePresence component\n    var presenceContext = useContext(PresenceContext);\n    var presenceId = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;\n    visualElement.isPresenceRoot = parentContext.presenceId !== presenceId;\n    // Override initial with that from a parent context, if defined\n    if ((presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== undefined) {\n        initial = presenceContext.initial;\n    }\n    var initialState;\n    if (initial === false && !isAnimationControls(animate)) {\n        initialState = animate;\n    }\n    else if (typeof initial !== \"boolean\") {\n        initialState = initial;\n    }\n    // Track mounted status so children can detect whether they were present during their\n    // parent's first render\n    var hasMounted = useRef(false);\n    // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n    // if we're being used to control variants, or if we're being passed animation controls.\n    // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n    // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n    // that this restriction is removed.\n    var shouldPropagateControls = variants ||\n        isVariantLabel(animate) ||\n        isVariantLabel(whileTap) ||\n        isVariantLabel(whileHover) ||\n        isAnimationControls(animate);\n    // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n    var targetInitial = isVariantLabel(initialState)\n        ? initialState\n        : parentContext.initial;\n    // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n    // the tree initially animates.\n    var targetAnimate = isVariantLabel(animate)\n        ? animate\n        : parentContext.animate;\n    // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n    // or in another non-animation/interaction environment.\n    var initialDependency = isStatic ? targetInitial : null;\n    // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n    // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n    // We want to do this as we rely on React's component rendering order each render cycle to determine\n    // the new order of any child components for the `staggerChildren` functionality.\n    var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate)\n        ? targetAnimate\n        : null;\n    // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n    // unlikely to change, by making the context an object it'll be considered a new value every render.\n    // So all child motion components will re-render as a result.\n    var context = useMemo(function () { return ({\n        controls: shouldPropagateControls\n            ? controls\n            : parentContext.controls,\n        initial: targetInitial,\n        animate: targetAnimate,\n        visualElement: visualElement,\n        hasMounted: hasMounted,\n        isReducedMotion: parentContext.isReducedMotion,\n        presenceId: presenceId,\n    }); }, [\n        initialDependency,\n        animateDependency,\n        parentContext.isReducedMotion,\n        animate,\n        layoutId,\n        presenceId,\n    ]);\n    // Update the `static` property every render. This is unlikely to change but also essentially free.\n    context.static = isStatic;\n    // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n    // in `initial`.\n    useInitialOrEveryRender(function () {\n        var initialToApply = initialState || parentContext.initial;\n        initialToApply && controls.apply(initialToApply);\n    }, !isStatic);\n    useEffect(function () {\n        hasMounted.current = true;\n    }, []);\n    return context;\n};\n\nvar checkShouldInheritVariant = function (_a) {\n    var animate = _a.animate, variants = _a.variants, _b = _a.inherit, inherit = _b === void 0 ? true : _b;\n    return (inherit &&\n        !!variants &&\n        (!animate || animate instanceof AnimationControls));\n};\n\nvar isMotionValue = function (value) {\n    return value instanceof MotionValue;\n};\n\n/**\n * Scrape props for MotionValues and add/remove them to this component's\n * VisualElement\n */\nfunction useMotionValues(visualElement, props) {\n    var prev = useConstant(empty);\n    /**\n     * Remove MotionValues that are no longer present\n     */\n    for (var key in prev) {\n        var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n        var existsAsProp = props[key];\n        var existsAsStyle = props.style && props.style[key];\n        var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n        var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n        var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n        var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n        if (transformRemoved || motionValueRemoved) {\n            visualElement.removeValue(key);\n            delete prev[key];\n        }\n    }\n    /**\n     * Add incoming MotionValues\n     */\n    addMotionValues(visualElement, prev, props);\n    if (props.style)\n        addMotionValues(visualElement, prev, props.style, true);\n    /**\n     * Transform custom values if provided a handler, ie size -> width/height\n     * Ideally we'd ditch this by removing support for size and other custom values from Framer.\n     */\n    if (props.transformValues) {\n        visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n    }\n}\n/**\n * Add incoming MotionValues\n *\n * TODO: Type the VisualElements properly\n */\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n    if (isStyle === void 0) { isStyle = false; }\n    if (isStyle)\n        visualElement.reactStyle = {};\n    for (var key in source) {\n        var value = source[key];\n        var foundMotionValue = false;\n        if (isMotionValue(value)) {\n            // If this is a MotionValue, add it if it isn't a reserved key\n            if (!reservedNames.has(key)) {\n                visualElement.addValue(key, value);\n                foundMotionValue = true;\n            }\n        }\n        else if (isTransformProp(key) || isTransformOriginProp(key)) {\n            // If this is a transform prop, always create a MotionValue\n            // to ensure we can reconcile them all together.\n            if (!visualElement.hasValue(key)) {\n                visualElement.addValue(key, motionValue(value));\n            }\n            else if (value !== prev[key]) {\n                // If the MotionValue already exists, update it with the\n                // latest incoming value\n                var motion = visualElement.getValue(key);\n                motion.set(value);\n            }\n            foundMotionValue = true;\n        }\n        else if (isStyle) {\n            visualElement.reactStyle[key] = value;\n        }\n        if (foundMotionValue)\n            prev[key] = value;\n    }\n}\n/**\n * These are props we accept as MotionValues but don't want to add\n * to the VisualElement\n */\nvar reservedNames = new Set([]);\nvar empty = function () { return ({}); };\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\n/**\n * Get the current value of every `MotionValue` in a `VisualElement`\n */\nvar getCurrent = function (visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n};\n/**\n * Get the current velocity of every `MotionValue` in a `VisualElement`\n */\nvar getVelocity = function (visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n};\n/**\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\n * check, just helps with typing.\n */\nvar isTargetResolver = function (p) {\n    return typeof p === \"function\";\n};\n/**\n * Check if value is a list of variant labels\n */\nvar isVariantLabels = function (v) { return Array.isArray(v); };\n/**\n * Control animations for a single component\n *\n * @internal\n */\nvar VisualElementAnimationControls = /** @class */ (function () {\n    function VisualElementAnimationControls(visualElement, _a) {\n        var _this = this;\n        var makeTargetAnimatable = _a.makeTargetAnimatable;\n        /**\n         * A reference to the component's latest props. We could probably ditch this in\n         * favour to a reference to the `custom` prop now we don't send all props through\n         * to target resolvers.\n         */\n        this.props = {};\n        /**\n         * The component's variants, as provided by `variants`\n         */\n        this.variants = {};\n        /**\n         * A set of values that we animate back to when a value is cleared of all overrides.\n         */\n        this.baseTarget = {};\n        /**\n         * A series of target overrides that we can animate to/from when overrides are set/cleared.\n         */\n        this.overrides = [];\n        /**\n         * A series of target overrides as they were originally resolved.\n         */\n        this.resolvedOverrides = [];\n        /**\n         * A Set of currently active override indexes\n         */\n        this.activeOverrides = new Set();\n        /**\n         * A Set of value keys that are currently animating.\n         */\n        this.isAnimating = new Set();\n        /**\n         * Check if the associated `VisualElement` has a key with the provided string.\n         * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\n         */\n        this.hasValue = function (key) { return !_this.visualElement.hasValue(key); };\n        this.visualElement = visualElement;\n        this.makeTargetAnimatable = makeTargetAnimatable;\n        this.visualElement.forEachValue(function (value, key) { return (_this.baseTarget[key] = value.get()); });\n    }\n    /**\n     * Set the reference to the component's props.\n     * @param props -\n     */\n    VisualElementAnimationControls.prototype.setProps = function (props) {\n        this.props = props;\n    };\n    /**\n     * Set the reference to the component's variants\n     * @param variants -\n     */\n    VisualElementAnimationControls.prototype.setVariants = function (variants) {\n        if (variants)\n            this.variants = variants;\n    };\n    /**\n     * Set the component's default transition\n     * @param transition -\n     */\n    VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n        if (transition)\n            this.defaultTransition = transition;\n    };\n    /**\n     * Set motion values without animation.\n     *\n     * @param definition -\n     * @param isActive -\n     */\n    VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.isActive, isActive = _c === void 0 ? new Set() : _c, priority = _b.priority;\n        var _d = this.resolveVariant(definition), target = _d.target, transitionEnd = _d.transitionEnd;\n        target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n        for (var key in target) {\n            if (isActive.has(key))\n                return;\n            isActive.add(key);\n            if (target) {\n                var targetValue = resolveFinalValueInKeyframes(target[key]);\n                if (this.visualElement.hasValue(key)) {\n                    var value = this.visualElement.getValue(key);\n                    value && value.set(targetValue);\n                }\n                else {\n                    this.visualElement.addValue(key, motionValue(targetValue));\n                }\n                if (!priority)\n                    this.baseTarget[key] = targetValue;\n            }\n        }\n    };\n    /**\n     * Allows `transformValues` to be set by a component that allows us to\n     * transform the values in a given `Target`. This allows Framer Library\n     * to extend Framer Motion to animate `Color` variables etc. Currently we have\n     * to manually support these extended types here in Framer Motion.\n     *\n     * @param values -\n     */\n    VisualElementAnimationControls.prototype.transformValues = function (values) {\n        var transformValues = this.props.transformValues;\n        return transformValues ? transformValues(values) : values;\n    };\n    /**\n     * Check a `Target` for new values we haven't animated yet, and add them\n     * to the `MotionValueMap`.\n     *\n     * Currently there's functionality here that is DOM-specific, we should allow\n     * this functionality to be injected by the factory that creates DOM-specific\n     * components.\n     *\n     * @param target -\n     */\n    VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n        var newValueKeys = Object.keys(target).filter(this.hasValue);\n        var numNewValues = newValueKeys.length;\n        if (!numNewValues)\n            return;\n        for (var i = 0; i < numNewValues; i++) {\n            var key = newValueKeys[i];\n            var targetValue = target[key];\n            var value = null;\n            // If this is a keyframes value, we can attempt to use the first value in the\n            // array as that's going to be the first value of the animation anyway\n            if (Array.isArray(targetValue)) {\n                value = targetValue[0];\n            }\n            // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n            // value from the DOM. It might be worth investigating whether to check props (for SVG)\n            // or props.style (for HTML) if the value exists there before attempting to read.\n            if (value === null) {\n                var readValue = this.visualElement.readNativeValue(key);\n                value = readValue !== undefined ? readValue : target[key];\n                invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n            }\n            if (typeof value === \"string\" && isNumericalString(value)) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(targetValue)) {\n                // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n                value = complex.getAnimatableNone(targetValue);\n            }\n            this.visualElement.addValue(key, motionValue(value));\n            this.baseTarget[key] = value;\n        }\n    };\n    /**\n     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\n     * @param variant -\n     */\n    VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n        if (!variant) {\n            return {\n                target: undefined,\n                transition: undefined,\n                transitionEnd: undefined,\n            };\n        }\n        if (isTargetResolver(variant)) {\n            // resolve current and velocity\n            variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n        }\n        var _a = variant.transition, transition = _a === void 0 ? this.defaultTransition : _a, transitionEnd = variant.transitionEnd, target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n        return { transition: transition, transitionEnd: transitionEnd, target: target };\n    };\n    /**\n     * Get the highest active override priority index\n     */\n    VisualElementAnimationControls.prototype.getHighestPriority = function () {\n        if (!this.activeOverrides.size)\n            return 0;\n        return Math.max.apply(Math, Array.from(this.activeOverrides));\n    };\n    /**\n     * Set an override. We add this layer of indirection so if, for instance, a tap gesture\n     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\n     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\n     * than the one that was resolved when the hover gesture animation started.\n     *\n     * @param definition -\n     * @param overrideIndex -\n     */\n    VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n        this.overrides[overrideIndex] = definition;\n        if (this.children) {\n            this.children.forEach(function (child) {\n                return child.setOverride(definition, overrideIndex);\n            });\n        }\n    };\n    /**\n     * Start an override animation.\n     * @param overrideIndex -\n     */\n    VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n        var override = this.overrides[overrideIndex];\n        if (override) {\n            return this.start(override, { priority: overrideIndex });\n        }\n    };\n    /**\n     * Clear an override. We check every value we animated to in this override to see if\n     * its present on any lower-priority overrides. If not, we animate it back to its base target.\n     * @param overrideIndex -\n     */\n    VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n        var _this = this;\n        if (this.children) {\n            this.children.forEach(function (child) { return child.clearOverride(overrideIndex); });\n        }\n        var override = this.overrides[overrideIndex];\n        if (!override)\n            return;\n        this.activeOverrides.delete(overrideIndex);\n        var highest = this.getHighestPriority();\n        this.resetIsAnimating();\n        if (highest) {\n            var highestOverride = this.overrides[highest];\n            highestOverride && this.startOverride(highest);\n        }\n        // Figure out which remaining values were affected by the override and animate those\n        var overrideTarget = this.resolvedOverrides[overrideIndex];\n        if (!overrideTarget)\n            return;\n        var remainingValues = {};\n        for (var key in this.baseTarget) {\n            if (overrideTarget[key] !== undefined) {\n                remainingValues[key] = this.baseTarget[key];\n            }\n        }\n        this.onStart();\n        this.animate(remainingValues).then(function () { return _this.onComplete(); });\n    };\n    /**\n     * Apply a target/variant without any animation\n     */\n    VisualElementAnimationControls.prototype.apply = function (definition) {\n        if (Array.isArray(definition)) {\n            return this.applyVariantLabels(definition);\n        }\n        else if (typeof definition === \"string\") {\n            return this.applyVariantLabels([definition]);\n        }\n        else {\n            this.setValues(definition);\n        }\n    };\n    /**\n     * Apply variant labels without animation\n     */\n    VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n        var _this = this;\n        var isActive = new Set();\n        var reversedList = __spreadArrays(variantLabelList).reverse();\n        reversedList.forEach(function (key) {\n            var _a = _this.resolveVariant(_this.variants[key]), target = _a.target, transitionEnd = _a.transitionEnd;\n            if (transitionEnd) {\n                _this.setValues(transitionEnd, { isActive: isActive });\n            }\n            if (target) {\n                _this.setValues(target, { isActive: isActive });\n            }\n            if (_this.children && _this.children.size) {\n                _this.children.forEach(function (child) {\n                    return child.applyVariantLabels(variantLabelList);\n                });\n            }\n        });\n    };\n    VisualElementAnimationControls.prototype.start = function (definition, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        if (opts.priority) {\n            this.activeOverrides.add(opts.priority);\n        }\n        this.resetIsAnimating(opts.priority);\n        var animation;\n        if (isVariantLabels(definition)) {\n            animation = this.animateVariantLabels(definition, opts);\n        }\n        else if (typeof definition === \"string\") {\n            animation = this.animateVariant(definition, opts);\n        }\n        else {\n            animation = this.animate(definition, opts);\n        }\n        this.onStart();\n        return animation.then(function () { return _this.onComplete(); });\n    };\n    VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride;\n        var _e = this.resolveVariant(animationDefinition), target = _e.target, transition = _e.transition, transitionEnd = _e.transitionEnd;\n        if (transitionOverride) {\n            transition = transitionOverride;\n        }\n        if (!target)\n            return Promise.resolve();\n        target = this.transformValues(target);\n        if (transitionEnd) {\n            transitionEnd = this.transformValues(transitionEnd);\n        }\n        this.checkForNewValues(target);\n        var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n        if (this.makeTargetAnimatable) {\n            var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n            target = animatable.target;\n            transitionEnd = animatable.transitionEnd;\n        }\n        if (priority) {\n            this.resolvedOverrides[priority] = target;\n        }\n        this.checkForNewValues(target);\n        var animations = [];\n        for (var key in target) {\n            var value = this.visualElement.getValue(key);\n            if (!value || !target || target[key] === undefined)\n                continue;\n            var valueTarget = target[key];\n            if (!priority) {\n                this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n            }\n            if (this.isAnimating.has(key))\n                continue;\n            this.isAnimating.add(key);\n            animations.push(startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition)));\n        }\n        var allAnimations = Promise.all(animations);\n        return transitionEnd\n            ? allAnimations.then(function () {\n                _this.setValues(transitionEnd, { priority: priority });\n            })\n            : allAnimations;\n    };\n    VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n        var _this = this;\n        var animations = __spreadArrays(variantLabels).reverse()\n            .map(function (label) { return _this.animateVariant(label, opts); });\n        return Promise.all(animations);\n    };\n    VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n        var _this = this;\n        var when = false;\n        var delayChildren = 0;\n        var staggerChildren = 0;\n        var staggerDirection = 1;\n        var priority = (opts && opts.priority) || 0;\n        var variant = this.variants[variantLabel];\n        var getAnimations = variant\n            ? function () { return _this.animate(variant, opts); }\n            : function () { return Promise.resolve(); };\n        var getChildrenAnimations = this.children\n            ? function () {\n                return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n            }\n            : function () { return Promise.resolve(); };\n        if (variant && this.children) {\n            var transition = this.resolveVariant(variant).transition;\n            if (transition) {\n                when = transition.when || when;\n                delayChildren = transition.delayChildren || delayChildren;\n                staggerChildren = transition.staggerChildren || staggerChildren;\n                staggerDirection =\n                    transition.staggerDirection || staggerDirection;\n            }\n        }\n        if (when) {\n            var _a = when === \"beforeChildren\"\n                ? [getAnimations, getChildrenAnimations]\n                : [getChildrenAnimations, getAnimations], first = _a[0], last = _a[1];\n            return first().then(last);\n        }\n        else {\n            return Promise.all([getAnimations(), getChildrenAnimations()]);\n        }\n    };\n    VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n        if (delayChildren === void 0) { delayChildren = 0; }\n        if (staggerChildren === void 0) { staggerChildren = 0; }\n        if (staggerDirection === void 0) { staggerDirection = 1; }\n        if (priority === void 0) { priority = 0; }\n        if (!this.children) {\n            return Promise.resolve();\n        }\n        var animations = [];\n        var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n        var generateStaggerDuration = staggerDirection === 1\n            ? function (i) { return i * staggerChildren; }\n            : function (i) { return maxStaggerDuration - i * staggerChildren; };\n        Array.from(this.children).forEach(function (childControls, i) {\n            var animation = childControls.animateVariant(variantLabel, {\n                priority: priority,\n                delay: delayChildren + generateStaggerDuration(i),\n            });\n            animations.push(animation);\n        });\n        return Promise.all(animations);\n    };\n    VisualElementAnimationControls.prototype.onStart = function () {\n        var onAnimationStart = this.props.onAnimationStart;\n        onAnimationStart && onAnimationStart();\n    };\n    VisualElementAnimationControls.prototype.onComplete = function () {\n        var onAnimationComplete = this.props.onAnimationComplete;\n        onAnimationComplete && onAnimationComplete();\n    };\n    VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n        var numOverrides = this.overrides.length;\n        for (var i = priority + 1; i < numOverrides; i++) {\n            var resolvedOverride = this.resolvedOverrides[i];\n            if (resolvedOverride) {\n                for (var key in resolvedOverride) {\n                    this.isAnimating.add(key);\n                }\n            }\n        }\n    };\n    VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n        if (priority === void 0) { priority = 0; }\n        this.isAnimating.clear();\n        // If this isn't the highest priority gesture, block the animation\n        // of anything that's currently being animated\n        if (priority < this.getHighestPriority()) {\n            this.checkOverrideIsAnimating(priority);\n        }\n        if (this.children) {\n            this.children.forEach(function (child) { return child.resetIsAnimating(priority); });\n        }\n    };\n    VisualElementAnimationControls.prototype.stop = function () {\n        this.visualElement.forEachValue(function (value) { return value.stop(); });\n    };\n    /**\n     * Add the controls of a child component.\n     * @param controls -\n     */\n    VisualElementAnimationControls.prototype.addChild = function (controls) {\n        if (!this.children) {\n            this.children = new Set();\n        }\n        this.children.add(controls);\n        // We set child overrides when `setOverride` is called, but also have to do it here\n        // as the first time `setOverride` is called all the children might not have been added yet.\n        this.overrides.forEach(function (override, i) {\n            override && controls.setOverride(override, i);\n        });\n    };\n    VisualElementAnimationControls.prototype.removeChild = function (controls) {\n        if (!this.children) {\n            return;\n        }\n        this.children.delete(controls);\n    };\n    VisualElementAnimationControls.prototype.resetChildren = function () {\n        if (this.children)\n            this.children.clear();\n    };\n    return VisualElementAnimationControls;\n}());\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\n/**\n * Creates an imperative set of controls to trigger animations.\n *\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\n *\n * @internal\n */\nfunction useVisualElementAnimation(visualElement, props, config) {\n    var subscribeToParentControls = checkShouldInheritVariant(props);\n    var variants = props.variants, transition = props.transition;\n    var parentControls = useContext(MotionContext).controls;\n    var presenceContext = useContext(PresenceContext);\n    var controls = useConstant(function () { return new VisualElementAnimationControls(visualElement, config); });\n    // Reset and resubscribe children every render to ensure stagger order is correct\n    if (!presenceContext || presenceContext.isPresent) {\n        controls.resetChildren();\n        controls.setProps(props);\n        controls.setVariants(variants);\n        controls.setDefaultTransition(transition);\n    }\n    // We have to subscribe to the parent controls within a useEffect rather than during render,\n    // as\n    useEffect(function () {\n        if (subscribeToParentControls && parentControls) {\n            parentControls.addChild(controls);\n        }\n    });\n    useEffect(function () {\n        return function () {\n            // Remove reference to onAnimationComplete from controls. All the MotionValues\n            // are unsubscribed from this component separately. We let animations run out\n            // as they might be animating other components.\n            var onAnimationComplete = props.onAnimationComplete, unmountProps = __rest(props, [\"onAnimationComplete\"]);\n            controls.setProps(unmountProps);\n            parentControls && parentControls.removeChild(controls);\n        };\n    }, []);\n    return controls;\n}\n\n/**\n * @internal\n */\nvar MotionPluginContext = createContext({\n    transformPagePoint: function (p) { return p; },\n    features: [],\n});\n/**\n * @remarks For now I think this should remain a private API for our own use\n * until we can figure out a nicer way of allowing people to add these\n *\n * @internal\n */\nfunction MotionPlugins(_a) {\n    var children = _a.children, props = __rest(_a, [\"children\"]);\n    var pluginContext = useContext(MotionPluginContext);\n    var value = useRef(__assign({}, pluginContext)).current;\n    // Mutative to prevent triggering rerenders in all listening\n    // components every time this component renders\n    for (var key in props) {\n        value[key] = props[key];\n    }\n    return (createElement(MotionPluginContext.Provider, { value: value }, children));\n}\n\nvar AnimatePropType;\n(function (AnimatePropType) {\n    AnimatePropType[\"Target\"] = \"Target\";\n    AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n    AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\nfunction shallowCompare(next, prev) {\n    if (prev === null)\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nvar hasUpdated = function (prev, next) {\n    return (next !== undefined &&\n        (Array.isArray(prev) && Array.isArray(next)\n            ? !shallowCompare(next, prev)\n            : prev !== next));\n};\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n    if (mergeTransitionEnd === void 0) { mergeTransitionEnd = false; }\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n    return mergeTransitionEnd\n        ? __assign(__assign({}, target), transitionEnd)\n        : target;\n}\n/**\n * Handle the `animate` prop when its an object of values, ie:\n *\n * ```jsx\n * <motion.div animate={{ opacity: 1 }} />\n * ```\n *\n * @internalremarks\n * It might be worth consolidating this with `use-variants`\n *\n * ```jsx\n * <motion.div animate=\"visible\" />\n * ```\n *\n * @param target\n * @param controls\n * @param values\n * @param transition\n *\n * @internal\n */\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n    var isInitialRender = useRef(true);\n    var prevValues = useRef(null);\n    if (!prevValues.current) {\n        prevValues.current = targetWithoutTransition(targetAndTransition, true);\n    }\n    useEffect(function () {\n        var targetToAnimate = {};\n        // These are the values we're actually animating\n        var animatingTarget = targetWithoutTransition(targetAndTransition);\n        // This is the target as it'll be once transitionEnd values are applied\n        var finalTarget = targetWithoutTransition(targetAndTransition, true);\n        // Detect which values have changed between renders\n        for (var key in animatingTarget) {\n            // This value should animate on mount if this value doesn't already exist (wasn't\n            // defined in `style` or `initial`) or if it does exist and it's already changed.\n            var shouldAnimateOnMount = isInitialRender.current &&\n                (!visualElement.hasValue(key) ||\n                    visualElement.getValue(key).get() !== finalTarget[key]);\n            // If this value has updated between renders or it's we're animating this value on mount,\n            // add it to the animate target.\n            var isValidValue = finalTarget[key] !== null;\n            var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n            if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n                targetToAnimate[key] = animatingTarget[key];\n            }\n        }\n        isInitialRender.current = false;\n        prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n        if (Object.keys(targetToAnimate).length) {\n            controls.start(__assign(__assign({}, targetToAnimate), { transition: targetAndTransition.transition || defaultTransition, transitionEnd: targetAndTransition.transitionEnd }));\n        }\n    }, [targetAndTransition]);\n}\n\nvar labelsToArray = function (label) {\n    if (!label) {\n        return [];\n    }\n    if (Array.isArray(label)) {\n        return label;\n    }\n    return [label];\n};\nvar resolveVariantLabels = function (variant) {\n    var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n    return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\n * When values in this array change, React re-runs the dependency. However if the array\n * contains a variable number of items, React throws an error.\n */\nvar asDependencyList = function (list) { return [\n    list.join(\",\"),\n]; };\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\n    return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\n * Handle variants and the `animate` prop when its set as variant labels.\n *\n * @param initial - Initial variant(s)\n * @param animate - Variant(s) to animate to\n * @param inherit - `true` is inheriting animations from parent\n * @param controls - Animation controls\n *\n * @internal\n */\nfunction useVariants(initial, animate, inherit, controls) {\n    var targetVariants = resolveVariantLabels(animate);\n    var context = useContext(MotionContext);\n    var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n    var hasMounted = useRef(false);\n    useEffect(function () {\n        var shouldAnimate = false;\n        if (inherit) {\n            // If we're inheriting variant changes and the parent has already\n            // mounted when this component loads, we need to manually trigger\n            // this animation.\n            shouldAnimate = !!parentAlreadyMounted;\n            targetVariants = resolveVariantLabels(context.animate);\n        }\n        else {\n            shouldAnimate =\n                hasMounted.current ||\n                    hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n        }\n        shouldAnimate && controls.start(targetVariants);\n        hasMounted.current = true;\n    }, asDependencyList(targetVariants));\n}\n\n/**\n * `useAnimationGroupSubscription` allows a component to subscribe to an\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\n *\n * @param animation\n * @param controls\n *\n * @internal\n */\nfunction useAnimationGroupSubscription(animation, controls) {\n    var unsubscribe = useMemo(function () { return animation.subscribe(controls); }, [\n        animation,\n    ]);\n    useEffect(function () { return function () {\n        unsubscribe && unsubscribe();\n    }; }, [unsubscribe]);\n}\n\nvar _a, _b;\nvar AnimatePropComponents = (_a = {},\n    _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n        var animate = _a.animate, controls = _a.controls, visualElement = _a.visualElement, transition = _a.transition;\n        return useAnimateProp(animate, controls, visualElement, transition);\n    }),\n    _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n        var animate = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, controls = _a.controls, initial = _a.initial;\n        return useVariants(initial, animate, inherit, controls);\n    }),\n    _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n        var animate = _a.animate, controls = _a.controls;\n        return useAnimationGroupSubscription(animate, controls);\n    }),\n    _a);\nvar isVariantLabel$1 = function (prop) {\n    return Array.isArray(prop) || typeof prop === \"string\";\n};\nvar isAnimationSubscription = function (_a) {\n    var animate = _a.animate;\n    return animate instanceof AnimationControls;\n};\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {},\n    _b[AnimatePropType.Target] = function (props) {\n        return (props.animate !== undefined &&\n            !isVariantLabel$1(props.animate) &&\n            !isAnimationSubscription(props));\n    },\n    _b[AnimatePropType.VariantLabel] = function (props) {\n        return (props.variants !== undefined ||\n            animationProps.some(function (key) { return typeof props[key] === \"string\"; }));\n    },\n    _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription,\n    _b);\nvar getAnimationComponent = function (props) {\n    var animatePropType = undefined;\n    for (var key in AnimatePropType) {\n        if (animatePropTypeTests[key](props)) {\n            animatePropType = key;\n        }\n    }\n    return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n\n/**\n * Load features via renderless components based on the provided MotionProps\n */\nfunction useFeatures(defaultFeatures, isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n    var plugins = useContext(MotionPluginContext);\n    // If this is a static component, or we're rendering on the server, we don't load\n    // any feature components\n    if (isStatic || typeof window === \"undefined\")\n        return null;\n    var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n    var numFeatures = allFeatures.length;\n    var features = [];\n    // TODO: Consolidate Animation feature loading strategy with other functionality components\n    var Animation = getAnimationComponent(props);\n    if (Animation) {\n        features.push(createElement(Animation, { key: \"animation\", initial: props.initial, animate: props.animate, variants: props.variants, transition: props.transition, controls: controls, inherit: shouldInheritVariant, visualElement: visualElement }));\n    }\n    // Decide which features we should render and add them to the returned array\n    for (var i = 0; i < numFeatures; i++) {\n        var _a = allFeatures[i], shouldRender = _a.shouldRender, key = _a.key, Component = _a.Component;\n        if (shouldRender(props, parentContext)) {\n            features.push(createElement(Component, __assign({ key: key }, props, { localContext: context, parentContext: parentContext, visualElement: visualElement, controls: controls })));\n        }\n    }\n    return features;\n}\n\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\nvar VisibilityAction;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    measureLayout: function (child) { return child.measureLayout(); },\n    layoutReady: function (child) { return child.layoutReady(); },\n};\n/**\n * Sort VisualElements by tree depth, so we process the highest elements first.\n */\nvar sortByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    var add = function (child) { return queue.add(child); };\n    var flush = function (_a) {\n        var _b = _a === void 0 ? defaultHandler : _a, measureLayout = _b.measureLayout, layoutReady = _b.layoutReady;\n        var order = Array.from(queue).sort(sortByDepth);\n        /**\n         * Write: Reset any transforms on children elements so we can read their actual layout\n         */\n        order.forEach(function (child) { return child.resetTransform(); });\n        /**\n         * Read: Measure the actual layout\n         */\n        order.forEach(measureLayout);\n        /**\n         * Write: Notify the VisualElements they're ready for further write operations.\n         */\n        order.forEach(layoutReady);\n        /**\n         * After all children have started animating, ensure any Entering components are set to Present.\n         * If we add deferred animations (set up all animations and then start them in two loops) this\n         * could be moved to the start loop. But it needs to happen after all the animations configs\n         * are generated in AnimateSharedLayout as this relies on presence data\n         */\n        order.forEach(function (child) {\n            if (child.isPresent)\n                child.presence = Presence.Present;\n        });\n        queue.clear();\n    };\n    return { add: add, flush: flush };\n}\nfunction isSharedLayout(context) {\n    return !!context.forceUpdate;\n}\nvar SharedLayoutContext = createContext(createBatcher());\n\nfunction useUnmountEffect(callback) {\n    return useEffect(function () { return function () { return callback(); }; }, []);\n}\n\nfunction useSnapshotOnUnmount(visualElement) {\n    var syncLayout = useContext(SharedLayoutContext);\n    useUnmountEffect(function () {\n        if (isSharedLayout(syncLayout))\n            syncLayout.remove(visualElement);\n    });\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(Component, _a) {\n    var defaultFeatures = _a.defaultFeatures, useVisualElement = _a.useVisualElement, render = _a.render, animationControlsConfig = _a.animationControlsConfig;\n    function MotionComponent(props, externalRef) {\n        var parentContext = useContext(MotionContext);\n        var shouldInheritVariant = checkShouldInheritVariant(props);\n        /**\n         * If a component isStatic, we only visually update it as a\n         * result of a React re-render, rather than any interactions or animations.\n         * If this component or any ancestor isStatic, we disable hardware acceleration\n         * and don't load any additional functionality.\n         */\n        var isStatic = parentContext.static || props.static || false;\n        /**\n         * Create a VisualElement for this component. A VisualElement provides a common\n         * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n         * providing a way of rendering to these APIs outside of the React render loop\n         * for more performant animations and interactions\n         */\n        var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n        /**\n         * Scrape MotionValues from props and add/remove them to/from\n         * the VisualElement as necessary.\n         */\n        useMotionValues(visualElement, props);\n        /**\n         * Create animation controls for the VisualElement. It might be\n         * interesting to try and combine this with VisualElement itself in a further refactor.\n         */\n        var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n        /**\n         * Build the MotionContext to pass on to the next `motion` component.\n         */\n        var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n        /**\n         * Load features as renderless components unless the component isStatic\n         */\n        var features = useFeatures(defaultFeatures, isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n        var component = render(Component, props, visualElement);\n        /**\n         *\n         */\n        useSnapshotOnUnmount(visualElement);\n        // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n        // all plugins and features has to execute.\n        return (createElement(Fragment, null,\n            createElement(MotionContext.Provider, { value: context }, component),\n            features));\n    }\n    return forwardRef(MotionComponent);\n}\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\nif (isBrowser) {\n    document.addEventListener(\"touchmove\", function (event) {\n        if (isViewportScrollBlocked) {\n            event.preventDefault();\n        }\n    }, { passive: false });\n}\nvar blockViewportScroll = function () { return (isViewportScrollBlocked = true); };\nvar unblockViewportScroll = function () { return (isViewportScrollBlocked = false); };\n\nfunction addDomEvent(target, eventName, handler, options) {\n    if (!handler)\n        return;\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    if (!eventHandler)\n        return undefined;\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    if (!handler)\n        return;\n    var listener = function (event) { return handler(event, extractEventInfo(event)); };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\";\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser$1 && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser$1 && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n/** @public */\nvar Point;\n(function (Point) {\n    /** @beta */\n    Point.subtract = function (a, b) {\n        return { x: a.x - b.x, y: a.y - b.y };\n    };\n    /** @beta */\n    Point.relativeTo = function (idOrElem) {\n        var elem;\n        var getElem = function () {\n            // Caching element here could be leaky because of React lifecycle\n            if (elem !== undefined)\n                return elem;\n            if (typeof idOrElem === \"string\") {\n                elem = document.getElementById(idOrElem);\n            }\n            else {\n                elem = idOrElem;\n            }\n            return elem;\n        };\n        return function (_a) {\n            var x = _a.x, y = _a.y;\n            var localElem = getElem();\n            if (!localElem)\n                return undefined;\n            var rect = localElem.getBoundingClientRect();\n            return {\n                x: x - rect.left - window.scrollX,\n                y: y - rect.top - window.scrollY,\n            };\n        };\n    };\n})(Point || (Point = {}));\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) { return _this.handlePointerMove(event, info); });\n        var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) { return _this.handlePointerUp(event, info); });\n        this.removeListeners = function () {\n            removeOnPointerMove && removeOnPointerMove();\n            removeOnPointerUp && removeOnPointerUp();\n        };\n    }\n    PanSession.prototype.handlePointerMove = function (event, info) {\n        this.lastMoveEvent = event;\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n        // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n        if (isMouseEvent(event) && event.buttons === 0) {\n            this.handlePointerUp(event, info);\n            return;\n        }\n        // Throttle mouse move event to once per frame\n        sync.update(this.updatePoint, true);\n    };\n    PanSession.prototype.handlePointerUp = function (event, info) {\n        this.end();\n        var onEnd = this.handlers.onEnd;\n        if (!onEnd)\n            return;\n        var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n        onEnd && onEnd(event, panInfo);\n    };\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n        unblockViewportScroll();\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: Point.subtract(point, lastDevicePoint(history)),\n        offset: Point.subtract(point, startDevicePoint(history)),\n        velocity: getVelocity$1(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity$1(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mix(min, point, elastic) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mix(max, point, elastic) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured axis.\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    var constraints = {};\n    var length = axis.max - axis.min;\n    if (min !== undefined) {\n        constraints.min = axis.min + min;\n    }\n    if (max !== undefined) {\n        constraints.max = Math.max(axis.min + max - length, axis.min + max);\n    }\n    return constraints;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = [max, min], min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        /**\n         * If this drag session has been manually triggered by the user, it might be from an event\n         * outside the draggable element. If snapToCursor is set to true, we need to measure the position\n         * of the element and snap it to the cursor.\n         */\n        snapToCursor && this.snapToCursor(originEvent);\n        var onSessionStart = function () {\n            // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n            // which has come out of the difficulty in us being able to do this once a scroll gesture\n            // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n            // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n            // trigger this once we've got a scroll direction determined. This approach sort-of worked\n            // but if the component was dragged too far in a single frame page scrolling would initiate.\n            blockViewportScroll();\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n        };\n        var onStart = function (event, info) {\n            var _a, _b;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _c = _this.props, drag = _c.drag, dragPropagation = _c.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            /**\n             * Record the progress of the mouse within the draggable element on each axis.\n             * onPan, we're going to use this to calculate a new bounding box for the element to\n             * project into. This will ensure that even if the DOM element moves via a relayout, it'll\n             * stick to the correct place under the pointer.\n             */\n            _this.prepareBoundingBox();\n            _this.visualElement.lockTargetBox();\n            /**\n             * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\n             * relative to the element's layout, or a ref to another element. Both need converting to\n             * viewport coordinates.\n             */\n            _this.resolveDragConstraints();\n            /**\n             * When dragging starts, we want to find where the cursor is relative to the bounding box\n             * of the element. Every frame, we calculate a new bounding box using this relative position\n             * and let the visualElement renderer figure out how to reproject the element into this bounding\n             * box.\n             *\n             * By doing it this way, rather than applying an x/y transform directly to the element,\n             * we can ensure the component always visually sticks to the cursor as we'd expect, even\n             * if the DOM element itself changes layout as a result of React updates the user might\n             * make based on the drag position.\n             */\n            var point = getViewportPointFromEvent(event).point;\n            eachAxis(function (axis) {\n                var _a = _this.visualElement.targetBox[axis], min = _a.min, max = _a.max;\n                _this.cursorProgress[axis] = cursorProgress\n                    ? cursorProgress[axis]\n                    : progress(min, max, point[axis]);\n            });\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", event);\n            _this.updateAxis(\"y\", event);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onEnd = function (event, info) { return _this.stop(event, info); };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onEnd: onEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    /**\n     * Ensure the component's layout and target bounding boxes are up-to-date.\n     */\n    VisualElementDragControls.prototype.prepareBoundingBox = function () {\n        var element = this.visualElement.getInstance();\n        var transform = element.style.transform;\n        this.visualElement.resetTransform();\n        this.visualElement.measureLayout();\n        element.style.transform = transform;\n        this.visualElement.refreshTargetBox();\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var dragConstraints = this.props.dragConstraints;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(this.visualElement.box, dragConstraints)\n                : calcRelativeConstraints(this.visualElement.box, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        unblockViewportScroll();\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a;\n        this.visualElement.unlockTargetBox();\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var _b = this.props, dragMomentum = _b.dragMomentum, dragElastic = _b.dragElastic, onDragEnd = _b.onDragEnd;\n        if (dragMomentum || dragElastic) {\n            var velocity = info.velocity;\n            this.animateDragEnd(velocity);\n        }\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (event) {\n        this.prepareBoundingBox();\n        this.cursorProgress.x = 0.5;\n        this.cursorProgress.y = 0.5;\n        this.updateAxis(\"x\", event);\n        this.updateAxis(\"y\", event);\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, event) {\n        var _a;\n        var _b = this.props, drag = _b.drag, dragElastic = _b.dragElastic;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.box[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        var point = getViewportPointFromEvent(event).point;\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setAxisTarget(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.updateProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? 0.35 : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = __assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        var momentumAnimations = eachAxis(function (axis) {\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = _this.constraints ? _this.constraints[axis] : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = __assign(__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.visualElement.startLayoutAxisAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        this.visualElement.stopLayoutAnimation();\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.prepareBoundingBox();\n        this.resolveDragConstraints();\n        eachAxis(function (axis) {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            // Calculate the position of the targetBox relative to the constraintsBox using the\n            // previously calculated progress\n            var _a = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n            _this.visualElement.setAxisTarget(axis, min, max);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging)\n                _this.resolveDragConstraints();\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevSnapshot = visualElement.prevSnapshot;\n        (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) &&\n            this.start(lastPointerEvent, {\n                cursorProgress: prevSnapshot.cursorProgress,\n            });\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props, visualElement) {\n    var groupDragControls = props.dragControls;\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n    var dragControls = useConstant(function () {\n        return new VisualElementDragControls({\n            visualElement: visualElement,\n        });\n    });\n    dragControls.updateProps(__assign(__assign({}, props), { transformPagePoint: transformPagePoint }));\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    // Mount the drag controls with the visualElement\n    useEffect(function () { return dragControls.mount(visualElement); }, []);\n}\n\nvar Drag = {\n    key: \"drag\",\n    shouldRender: function (props) { return !!props.drag; },\n    Component: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\n        return useDrag(props, visualElement);\n    }),\n};\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a, ref) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = useRef(null);\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\nvar getGesturePriority = function (gesture) {\n    return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a, ref) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, controls = _a.controls;\n    var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isTapping = useRef(false);\n    var cancelPointerEventListener = useRef(null);\n    function removePointerUp() {\n        cancelPointerEventListener.current &&\n            cancelPointerEventListener.current();\n        cancelPointerEventListener.current = null;\n    }\n    if (whileTap && controls) {\n        controls.setOverride(whileTap, tapGesturePriority);\n    }\n    // We load this event handler into a ref so we can later refer to\n    // onPointerUp.current which will always have reference to the latest props\n    var onPointerUp = useRef(null);\n    onPointerUp.current = function (event, info) {\n        var element = ref.current;\n        removePointerUp();\n        if (!isTapping.current || !element)\n            return;\n        isTapping.current = false;\n        if (controls && whileTap) {\n            controls.clearOverride(tapGesturePriority);\n        }\n        // Check the gesture lock - if we get it, it means no drag gesture is active\n        // and we can safely fire the tap gesture.\n        var openGestureLock = getGlobalLock(true);\n        if (!openGestureLock)\n            return;\n        openGestureLock();\n        if (!isNodeOrChild(element, event.target)) {\n            onTapCancel && onTapCancel(event, info);\n        }\n        else {\n            onTap && onTap(event, info);\n        }\n    };\n    function onPointerDown(event, info) {\n        removePointerUp();\n        cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) { return onPointerUp.current(event, info); });\n        var element = ref.current;\n        if (!element || isTapping.current)\n            return;\n        isTapping.current = true;\n        onTapStart && onTapStart(event, info);\n        if (controls && whileTap) {\n            controls.startOverride(tapGesturePriority);\n        }\n    }\n    usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\nvar filterTouch = function (listener) { return function (event, info) {\n    if (isMouseEvent(event))\n        listener(event, info);\n}; };\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useHoverGesture(_a, ref) {\n    var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, controls = _a.controls;\n    if (whileHover && controls) {\n        controls.setOverride(whileHover, hoverPriority);\n    }\n    usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n        if (onHoverStart)\n            onHoverStart(event, info);\n        if (whileHover && controls) {\n            controls.startOverride(hoverPriority);\n        }\n    }));\n    usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n        if (onHoverEnd)\n            onHoverEnd(event, info);\n        if (whileHover && controls) {\n            controls.clearOverride(hoverPriority);\n        }\n    }));\n}\n\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\nfunction useGestures(props, ref) {\n    usePanGesture(props, ref);\n    useTapGesture(props, ref);\n    useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"whileTap\",\n    \"whileHover\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n];\nvar Gestures = {\n    key: \"gestures\",\n    shouldRender: function (props) {\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\n    },\n    Component: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\n        useGestures(props, visualElement);\n    }),\n};\n\nvar Exit = {\n    key: \"exit\",\n    shouldRender: function (props) { return !!props.exit && !checkShouldInheritVariant(props); },\n    Component: makeRenderlessComponent(function (props) {\n        var animate = props.animate, controls = props.controls, exit = props.exit;\n        var _a = usePresence(), isPresent = _a[0], onExitComplete = _a[1];\n        var presenceContext = useContext(PresenceContext);\n        var isPlayingExitAnimation = useRef(false);\n        var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== undefined\n            ? presenceContext.custom\n            : props.custom;\n        useEffect(function () {\n            if (!isPresent) {\n                if (!isPlayingExitAnimation.current && exit) {\n                    controls.setProps(__assign(__assign({}, props), { custom: custom }));\n                    controls.start(exit).then(onExitComplete);\n                }\n                isPlayingExitAnimation.current = true;\n            }\n            else if (isPlayingExitAnimation.current &&\n                animate &&\n                typeof animate !== \"boolean\" &&\n                !(animate instanceof AnimationControls)) {\n                controls.start(animate);\n            }\n            if (isPresent) {\n                isPlayingExitAnimation.current = false;\n            }\n        }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n    }),\n};\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = mix(prev.min, next.min, p);\n    target.max = mix(prev.max, next.max, p);\n}\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    __extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.frameTarget = {\n            x: { min: 0, max: 0 },\n            y: { min: 0, max: 0 },\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.isTargetBoxLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    // If we're meant to show/hide the visualElement, do so\n                    visibilityAction === VisibilityAction.Hide\n                        ? visualElement.hide()\n                        : visualElement.show();\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], config);\n                }\n                else {\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setAxisTarget(axis, target[axis].min, target[axis].max);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.render();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                var _a, _b;\n                (_a = config.onLayoutAnimationComplete) === null || _a === void 0 ? void 0 : _a.call(config);\n                if (visualElement.isPresent) {\n                    visualElement.presence = Presence.Present;\n                }\n                else {\n                    (_b = config.onLayoutAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(config);\n                    _this.safeToRemove();\n                }\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var visualElement = this.props.visualElement;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the HTMLVisualElement.startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _b, _c;\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, crossfadeOpacity = _d.crossfadeOpacity;\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.axisProgress[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * If this is a crossfade animation, create a function that updates both the opacity of this component\n         * and the one being crossfaded out.\n         */\n        var crossfade = crossfadeOpacity && this.createCrossfadeAnimation(crossfadeOpacity);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max);\n            // If this is a crossfade animation, update both elements.\n            crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition);\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        this.stopAxisAnimation[axis] = function () {\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        return animation;\n    };\n    Animate.prototype.createCrossfadeAnimation = function (crossfadeOpacity) {\n        var visualElement = this.props.visualElement;\n        var opacity = visualElement.getValue(\"opacity\", 0);\n        return function (p) {\n            opacity.set(easeCrossfadeIn(mix(0, 1, p)));\n            crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));\n        };\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(Component));\nvar AnimateLayout = {\n    key: \"animate-layout\",\n    shouldRender: function (props) { return !!props.layout || !!props.layoutId; },\n    Component: function (props) {\n        var _a = usePresence(), safeToRemove = _a[1];\n        return createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));\n    },\n};\nfunction hasMoved(a, b) {\n    return hasAxisMoved(a.x, b.x) || hasAxisMoved(a.y, b.y);\n}\nfunction hasAxisMoved(a, b) {\n    return a.min !== b.min || a.max !== b.max;\n}\nvar defaultTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear$1);\n\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\nvar Measure = /** @class */ (function (_super) {\n    __extends(Measure, _super);\n    function Measure(props) {\n        var _this = _super.call(this, props) || this;\n        /**\n         * If this component isn't the child of a SyncContext, make it responsible for flushing\n         * the layout batcher\n         */\n        var syncLayout = props.syncLayout;\n        if (!isSharedLayout(syncLayout)) {\n            _this.componentDidUpdate = function () { return syncLayout.flush(); };\n        }\n        return _this;\n    }\n    /**\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\n     */\n    Measure.prototype.componentDidMount = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n    };\n    /**\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n     * handle the snapshotting.\n     *\n     * If it is stand-alone component, add it to the batcher.\n     */\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\n        if (isSharedLayout(syncLayout)) {\n            syncLayout.syncUpdate();\n        }\n        else {\n            visualElement.snapshotBoundingBox();\n            syncLayout.add(visualElement);\n        }\n        return null;\n    };\n    Measure.prototype.componentDidUpdate = function () { };\n    Measure.prototype.render = function () {\n        return null;\n    };\n    return Measure;\n}(React__default.Component));\nvar MeasureLayout = {\n    key: \"measure-layout\",\n    shouldRender: function (props) {\n        return !!props.drag || !!props.layout || !!props.layoutId;\n    },\n    Component: function (props) {\n        var syncLayout = useContext(SharedLayoutContext);\n        return React__default.createElement(Measure, __assign({}, props, { syncLayout: syncLayout }));\n    },\n};\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion.custom(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(defaultFeatures) {\n    var config = {\n        defaultFeatures: defaultFeatures,\n        useVisualElement: useDomVisualElement,\n        render: render,\n        animationControlsConfig: {\n            makeTargetAnimatable: parseDomVariant,\n        },\n    };\n    function custom(Component) {\n        return createMotionComponent(Component, config);\n    }\n    var componentCache = new Map();\n    function get(target, key) {\n        if (key === \"custom\")\n            return target.custom;\n        if (!componentCache.has(key)) {\n            componentCache.set(key, createMotionComponent(key, config));\n        }\n        return componentCache.get(key);\n    }\n    return new Proxy({ custom: custom }, { get: get });\n}\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy([\n    MeasureLayout,\n    Drag,\n    Gestures,\n    Exit,\n    AnimateLayout,\n]);\n/**\n * @public\n */\nvar m = /*@__PURE__*/ createMotionProxy([]);\n\nfunction useForceUpdate() {\n    var _a = useState(0), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    return useCallback(function () { return setForcedRenderCount(forcedRenderCount + 1); }, [\n        forcedRenderCount,\n    ]);\n}\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom;\n    var presenceChildren = useConstant(newChildrenMap);\n    var context = {\n        id: useConstant(getPresenceId),\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            presenceChildren.set(childId, true);\n            var allComplete = true;\n            presenceChildren.forEach(function (isComplete) {\n                if (!isComplete)\n                    allComplete = false;\n            });\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    };\n    useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    return (createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (createElement(Fragment, null, filteredChildren.map(function (child) { return (createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = __spreadArrays(filteredChildren);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (createElement(PresenceChild, { key: getChildKey(child), isPresent: true }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (createElement(Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nfunction createSwitchAnimation(child, stack) {\n    if (stack && child !== stack.lead) {\n        return { visibilityAction: VisibilityAction.Hide };\n    }\n    else if (stack &&\n        child.presence !== Presence.Entering &&\n        child === stack.lead &&\n        stack.lead !== stack.prevLead) {\n        return { visibilityAction: VisibilityAction.Show };\n    }\n    var originBox;\n    var targetBox;\n    if (child.presence === Presence.Entering) {\n        originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();\n    }\n    else if (child.presence === Presence.Exiting) {\n        targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();\n    }\n    return { originBox: originBox, targetBox: targetBox };\n}\nfunction createCrossfadeAnimation(child, stack) {\n    var _a, _b, _c;\n    var config = {};\n    var stackLead = stack && stack.lead;\n    var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;\n    if (stack && child === stackLead) {\n        if (child.presence === Presence.Entering) {\n            config.originBox = stack.getFollowOrigin();\n        }\n        else if (child.presence === Presence.Exiting) {\n            config.targetBox = stack.getFollowTarget();\n        }\n    }\n    else if (stack && child === stack.follow) {\n        config.transition = stack.getLeadTransition();\n        if (stackLeadPresence === Presence.Entering) {\n            config.targetBox = stack.getLeadTarget();\n        }\n        else if (stackLeadPresence === Presence.Exiting) {\n            config.originBox = stack.getLeadOrigin();\n        }\n    }\n    // If neither the lead or follow component is the root child of AnimatePresence,\n    // don't handle crossfade animations\n    if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {\n        return config;\n    }\n    if (!stack || child === stackLead) {\n        if (child.presence === Presence.Entering) {\n            config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue(\"opacity\", 0);\n        }\n    }\n    else if (stack && child === stack.follow) {\n        if (!stackLead || stackLeadPresence === Presence.Entering) ;\n        else if (stackLeadPresence === Presence.Exiting) {\n            config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue(\"opacity\", 1);\n        }\n    }\n    else {\n        config.visibilityAction = VisibilityAction.Hide;\n    }\n    return config;\n}\n\n/**\n * For each layout animation, we want to identify two components\n * within a stack that will serve as the \"lead\" and \"follow\" components.\n *\n * In the switch animation, the lead component performs the entire animation.\n * It uses the follow bounding box to animate out from and back to. The follow\n * component is hidden.\n *\n * In the crossfade animation, both the lead and follow components perform\n * the entire animation, animating from the follow origin bounding box to the lead\n * target bounding box.\n *\n * Generalising a stack as First In Last Out, *searching from the end* we can\n * generally consider the lead component to be:\n *  - If the last child is present, the last child\n *  - If the last child is exiting, the last *encountered* exiting component\n */\nfunction findLeadAndFollow(stack, _a) {\n    var prevLead = _a[0], prevFollow = _a[1];\n    var lead = undefined;\n    var leadIndex = 0;\n    var follow = undefined;\n    // Find the lead child first\n    var numInStack = stack.length;\n    var lastIsPresent = false;\n    for (var i = numInStack - 1; i >= 0; i--) {\n        var child = stack[i];\n        var isLastInStack = i === numInStack - 1;\n        if (isLastInStack)\n            lastIsPresent = child.isPresent;\n        if (lastIsPresent) {\n            lead = child;\n        }\n        else {\n            // If the child before this will be present, make this the\n            // lead.\n            var prev = stack[i - 1];\n            if (prev && prev.isPresent)\n                lead = child;\n        }\n        if (lead) {\n            leadIndex = i;\n            break;\n        }\n    }\n    if (!lead)\n        lead = stack[0];\n    // Find the follow child\n    follow = stack[leadIndex - 1];\n    // If the lead component is exiting, find the closest follow\n    // present component\n    if (lead) {\n        for (var i = leadIndex - 1; i >= 0; i--) {\n            var child = stack[i];\n            if (child.isPresent) {\n                follow = child;\n                break;\n            }\n        }\n    }\n    // If the lead has changed and the previous lead still exists in the\n    // stack, set it to the previous lead. This allows us to differentiate between\n    // a, b, c(exit) -> a, b(exit), c(exit)\n    // and\n    // a, b(exit), c -> a, b(exit), c(exit)\n    if (lead !== prevLead &&\n        !lastIsPresent &&\n        follow === prevFollow &&\n        stack.find(function (stackChild) { return stackChild === prevLead; })) {\n        lead = prevLead;\n    }\n    return [lead, follow];\n}\nvar LayoutStack = /** @class */ (function () {\n    function LayoutStack() {\n        this.order = [];\n        // Track whether we've ever had a child\n        this.hasChildren = false;\n    }\n    LayoutStack.prototype.add = function (child) {\n        var _a;\n        var layoutOrder = child.config.layoutOrder;\n        if (layoutOrder === undefined) {\n            this.order.push(child);\n        }\n        else {\n            var index = this.order.findIndex(function (stackChild) {\n                return layoutOrder <= (stackChild.config.layoutOrder || 0);\n            });\n            if (index === -1) {\n                child.presence = this.hasChildren\n                    ? Presence.Entering\n                    : Presence.Present;\n                index = this.order.length;\n            }\n            this.order.splice(index, 0, child);\n        }\n        /**\n         *\n         */\n        // Load previous values from snapshot into this child\n        // TODO Neaten up\n        // TODO Double check when reimplementing move\n        // TODO Add isDragging status and\n        if (this.snapshot) {\n            child.prevSnapshot = this.snapshot;\n            // TODO Remove in favour of above\n            child.prevViewportBox = this.snapshot.boundingBox;\n            var latest = this.snapshot.latestMotionValues;\n            for (var key in latest) {\n                if (!child.hasValue(key)) {\n                    child.addValue(key, motionValue(latest[key]));\n                }\n                else {\n                    (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);\n                }\n            }\n        }\n        this.hasChildren = true;\n    };\n    LayoutStack.prototype.remove = function (child) {\n        var index = this.order.findIndex(function (stackChild) { return child === stackChild; });\n        if (index !== -1)\n            this.order.splice(index, 1);\n    };\n    LayoutStack.prototype.updateLeadAndFollow = function () {\n        this.prevLead = this.lead;\n        this.prevFollow = this.follow;\n        var _a = findLeadAndFollow(this.order, [\n            this.lead,\n            this.follow,\n        ]), lead = _a[0], follow = _a[1];\n        this.lead = lead;\n        this.follow = follow;\n    };\n    LayoutStack.prototype.updateSnapshot = function () {\n        if (!this.lead)\n            return;\n        var snapshot = {\n            boundingBox: this.lead.prevViewportBox,\n            latestMotionValues: {},\n        };\n        this.lead.forEachValue(function (value, key) {\n            var latest = value.get();\n            if (!isTransformProp(latest)) {\n                snapshot.latestMotionValues[key] = latest;\n            }\n        });\n        var dragControls = elementDragControls.get(this.lead);\n        if (dragControls && dragControls.isDragging) {\n            snapshot.isDragging = true;\n            snapshot.cursorProgress = dragControls.cursorProgress;\n        }\n        this.snapshot = snapshot;\n    };\n    LayoutStack.prototype.isLeadPresent = function () {\n        var _a;\n        return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n    };\n    LayoutStack.prototype.shouldStackAnimate = function () {\n        return true;\n        // return this.lead && this.lead?.isPresent\n        //     ? this.lead?.props?._shouldAnimate === true\n        //     : this.follow && this.follow?.props._shouldAnimate === true\n    };\n    LayoutStack.prototype.getFollowOrigin = function () {\n        var _a;\n        // This shouldAnimate check is quite specifically a fix for the optimisation made in Framer\n        // where components are kept in the tree ready to be re-used\n        return this.follow // && this.follow.shouldAnimate\n            ? this.follow.prevViewportBox\n            : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;\n    };\n    LayoutStack.prototype.getFollowTarget = function () {\n        var _a;\n        return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;\n    };\n    LayoutStack.prototype.getLeadOrigin = function () {\n        var _a;\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;\n    };\n    LayoutStack.prototype.getLeadTarget = function () {\n        var _a;\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;\n    };\n    LayoutStack.prototype.getLeadTransition = function () {\n        var _a;\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;\n    };\n    return LayoutStack;\n}());\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n        this.updateStacks();\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        /**\n         * In every layoutId stack, nominate a component to lead the animation and another\n         * to follow\n         */\n        this.updateStacks();\n        /**\n         * Decide which animation to use between shared layoutId components\n         */\n        var createAnimation = type === \"crossfade\"\n            ? createCrossfadeAnimation\n            : createSwitchAnimation;\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            measureLayout: function (child) { return child.measureLayout(); },\n            layoutReady: function (child) {\n                var layoutId = child.layoutId;\n                child.layoutReady(createAnimation(child, _this.getStack(layoutId)));\n            },\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return (stack.snapshot = undefined); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Snapshot children\n         */\n        this.children.forEach(function (child) { return child.snapshotBoundingBox(); });\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child.layoutId);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child.layoutId);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (id) {\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    return AnimateSharedLayout;\n}(Component));\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    return useConstant(function () { return motionValue(initial); });\n}\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\nvar isCustomValueType = function (v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function (v) {\n    return typeof v === \"function\";\n};\nfunction useTransform(parent, customTransform, to, options) {\n    var comparitor = isTransformer(customTransform)\n        ? [parent]\n        : [parent, customTransform.join(\",\"), to === null || to === void 0 ? void 0 : to.join(\",\")];\n    var transformer = useMemo(function () {\n        return isTransformer(customTransform)\n            ? customTransform\n            : transform(customTransform, to, options);\n    }, comparitor);\n    var initialValue = transformer(parent.get());\n    var value = useMotionValue(initialValue);\n    // Handle subscription to parent\n    var unsubscribe = useRef();\n    useMemo(function () {\n        unsubscribe.current && unsubscribe.current();\n        unsubscribe.current = parent.onChange(function (v) { return value.set(transformer(v)); });\n        // Manually set with the latest parent value in case we've re-parented\n        value.set(initialValue);\n    }, [parent, value, transformer]);\n    useUnmountEffect(function () { return unsubscribe.current && unsubscribe.current(); });\n    return value;\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @public\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useContext(MotionContext).visualElement;\n    invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\nfunction useOnChange(value, callback) {\n    useEffect(function () { return (isMotionValue(value) ? value.onChange(callback) : undefined); }, [value]);\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var activeSpringAnimation = useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    useMemo(function () {\n        return value.attach(function (v, set) {\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = spring(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config)).start(set);\n            return value.get();\n        });\n    }, Object.values(config));\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\nfunction createScrollMotionValues() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0),\n    };\n}\nfunction setProgress(offset, maxOffset, value) {\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n    var update = function () {\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n        // Set absolute positions\n        values.scrollX.set(xOffset);\n        values.scrollY.set(yOffset);\n        // Set 0-1 progress\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n    };\n    update();\n    return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function (element) { return function () {\n    return {\n        xOffset: element.scrollLeft,\n        yOffset: element.scrollTop,\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\n    };\n}; };\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        var element = ref.current;\n        invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n        if (!element)\n            return;\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n        return function () {\n            scrollListener && scrollListener();\n            resizeListener && resizeListener();\n        };\n    }, []);\n    return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\nfunction getViewportScrollOffsets() {\n    return {\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\n    };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n    hasListeners = true;\n    if (typeof window === \"undefined\")\n        return;\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n    addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n    useIsomorphicLayoutEffect(function () {\n        !hasListeners && addEventListeners();\n    }, []);\n    return viewportScrollValues;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n    var animationControls = useConstant(function () { return new AnimationControls(); });\n    useEffect(function () {\n        animationControls.mount();\n        return function () { return animationControls.unmount(); };\n    }, []);\n    return animationControls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    // TODO: After Framer X beta, remove this warning\n    warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n    var index = useRef(0);\n    var _a = useState(items[index.current]), item = _a[0], setItem = _a[1];\n    return [\n        item,\n        function (next) {\n            index.current =\n                typeof next !== \"number\"\n                    ? wrap(0, items.length, index.current + 1)\n                    : next;\n            setItem(items[index.current]);\n        },\n    ];\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion = motionValue(null);\nif (typeof window !== \"undefined\") {\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function () {\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.set(false);\n    }\n}\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n    return typeof isReducedMotion === \"boolean\"\n        ? isReducedMotion\n        : Boolean(prefersReduced);\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    var isReducedMotion = useContext(MotionContext).isReducedMotion;\n    var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n    useEffect(function () {\n        return prefersReducedMotion.onChange(function (v) {\n            setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n        });\n    }, [setShouldReduceMotion, isReducedMotion]);\n    return shouldReduceMotion;\n}\n\n/**\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\n * or disable device detection.\n *\n * @internal\n */\nfunction ReducedMotion(_a) {\n    var children = _a.children, enabled = _a.enabled;\n    var context = useContext(MotionContext);\n    context = useMemo(function () { return (__assign(__assign({}, context), { isReducedMotion: enabled })); }, [enabled]);\n    return (createElement(MotionContext.Provider, { value: context }, children));\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - A mouse/touch/pointer event.\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\n/**\n * Uses the ref that is passed in, or creates a new one\n * @param external - External ref\n * @internal\n */\nfunction useExternalRef(externalRef) {\n    // We're conditionally calling `useRef` here which is sort of naughty as hooks\n    // shouldn't be called conditionally. However, Framer Motion will break if this\n    // condition changes anyway. It might be possible to use an invariant here to\n    // make it explicit, but I expect changing `ref` is not normal behaviour.\n    var ref = !externalRef || typeof externalRef === \"function\"\n        ? useRef(null)\n        : externalRef;\n    // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n    // but `ref` types changing between renders would break Motion anyway. If we receive\n    // bug reports about this, we should track the provided ref and throw an invariant\n    // rather than move the conditional to inside the useEffect as this will be fired\n    // for every Frame component within Framer.\n    if (externalRef && typeof externalRef === \"function\") {\n        useEffect(function () {\n            externalRef(ref.current);\n            return function () { return externalRef(null); };\n        }, []);\n    }\n    return ref;\n}\n\n/**\n * This is just a very basic VisualElement, more of a hack to keep supporting useAnimatedState with\n * the latest APIs.\n */\nvar StateVisualElement = /** @class */ (function (_super) {\n    __extends(StateVisualElement, _super);\n    function StateVisualElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.initialState = {};\n        return _this;\n    }\n    StateVisualElement.prototype.updateLayoutDelta = function () { };\n    StateVisualElement.prototype.build = function () { };\n    StateVisualElement.prototype.clean = function () { };\n    StateVisualElement.prototype.getBoundingBox = function () {\n        return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };\n    };\n    StateVisualElement.prototype.readNativeValue = function (key) {\n        return this.initialState[key] || 0;\n    };\n    StateVisualElement.prototype.render = function () {\n        this.build();\n    };\n    return StateVisualElement;\n}(VisualElement));\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n    var _a = useState(initialState), animationState = _a[0], setAnimationState = _a[1];\n    var visualElement = useConstant(function () { return new StateVisualElement(); });\n    visualElement.updateConfig({\n        onUpdate: function (v) { return setAnimationState(__assign({}, v)); },\n    });\n    visualElement.initialState = initialState;\n    var controls = useVisualElementAnimation(visualElement, {}, {});\n    useEffect(function () {\n        visualElement.mount({});\n        return function () { return visualElement.unmount(); };\n    }, []);\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return controls.start(animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, VisualElementAnimationControls, addScaleCorrection, animationControls, createMotionComponent, isValidMotionProp, m, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };\n"]},"metadata":{},"sourceType":"module"}